use std::collections::{BTreeMap, HashMap, VecDeque};
use std::path::Path as FsPath;
use std::sync::Arc;
use std::time::SystemTime;

use autopilot_app::{InboxAuditEntry, InboxSnapshot, InboxThreadSummary};
use autopilot_inbox_domain::{
    PolicyDecision, classify_thread, compose_local_draft, infer_style_signature_from_bodies,
    risk_to_str,
};
use axum::body::to_bytes;
use axum::body::{Body, Bytes};
use axum::extract::{Form, Path, Query, Request, State};
use axum::http::header::{
    ACCEPT_ENCODING, AUTHORIZATION, CACHE_CONTROL, CONTENT_ENCODING, CONTENT_TYPE, COOKIE, ETAG,
    IF_NONE_MATCH, SET_COOKIE, VARY,
};
use axum::http::{HeaderMap, HeaderValue, Method, StatusCode};
use axum::middleware::{self, Next};
use axum::response::{IntoResponse, Redirect, Response};
use axum::routing::{delete, get, patch, post};
use axum::{Json, Router};
use base64::Engine as _;
use base64::engine::general_purpose::{STANDARD, URL_SAFE_NO_PAD};
use chrono::{Duration, NaiveDate, SecondsFormat, Utc};
use hmac::{Hmac, Mac};
use openagents_client_core::compatibility::{
    ClientCompatibilityHandshake, CompatibilityFailure, CompatibilitySurface, CompatibilityWindow,
    negotiate_compatibility,
};
use openagents_l402::Bolt11;
use openagents_runtime_client::{
    RuntimeClientError, RuntimeInternalClient, RuntimeWorkerHeartbeatRequest,
    RuntimeWorkerRegisterRequest, RuntimeWorkerTransitionRequest,
};
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use tokio::sync::Mutex;
use tower::ServiceBuilder;
use tower_http::request_id::{MakeRequestUuid, PropagateRequestIdLayer, SetRequestIdLayer};
use tower_http::trace::TraceLayer;
use uuid::Uuid;

pub mod api_envelope;
pub mod auth;
mod auth_routes;
pub mod codex_threads;
pub mod config;
pub mod domain_store;
pub mod khala_token;
pub mod observability;
pub mod openapi;
mod render;
pub mod route_split;
mod runtime_admin;
pub mod runtime_routing;
mod stats;
mod sync_handlers;
pub mod sync_token;
pub mod vercel_sse_adapter;
pub mod web_htmx;
pub mod web_maud;

use crate::api_envelope::{
    ApiErrorCode, ApiErrorDetail, ApiErrorResponse, error_response_with_status, forbidden_error,
    not_found_error, ok_data, unauthorized_error, validation_error,
};
use crate::auth::{
    AuthError, AuthService, AuthUser, PolicyCheckRequest, SessionBundle, SessionRevocationReason,
    SessionRevocationRequest, SessionRevocationTarget,
};
use crate::auth_routes::{
    auth_register, current_session, list_sessions, local_test_login, login_email, login_page,
    login_verify, me, revoke_sessions, send_email_code, verify_email_code, web_logout,
};
use crate::codex_threads::{
    AutopilotThreadProjection, CodexThreadStore, ThreadMessageProjection, ThreadProjection,
    ThreadStoreError,
};
use crate::config::Config;
use crate::domain_store::{
    AutopilotAggregate, CreateAutopilotInput, CreateL402PaywallInput, CreateShoutInput,
    DomainStore, DomainStoreError, L402GatewayEventRecord, L402PaywallRecord, L402ReceiptRecord,
    MarkWebhookEventVerifiedInput, RecordInboxAuditInput, RecordL402GatewayEventInput,
    RecordWebhookEventInput, SendWhisperInput, ShoutRecord, UpdateAutopilotInput,
    UpdateL402PaywallInput, UpsertAutopilotPolicyInput, UpsertAutopilotProfileInput,
    UpsertGoogleIntegrationInput, UpsertInboxThreadStateInput, UpsertResendIntegrationInput,
    UpsertRuntimeDriverOverrideInput, UpsertUserSparkWalletInput, UserIntegrationRecord,
    UserSparkWalletRecord, WhisperRecord, ZoneCount,
};
use crate::khala_token::{KhalaTokenError, KhalaTokenIssueRequest, KhalaTokenIssuer};
use crate::observability::{AuditEvent, Observability};
use crate::openapi::{
    ROUTE_AGENT_PAYMENTS_BALANCE, ROUTE_AGENT_PAYMENTS_INVOICE, ROUTE_AGENT_PAYMENTS_PAY,
    ROUTE_AGENT_PAYMENTS_SEND_SPARK, ROUTE_AGENT_PAYMENTS_WALLET, ROUTE_AGENTS_ME_BALANCE,
    ROUTE_AGENTS_ME_WALLET, ROUTE_AUTH_EMAIL, ROUTE_AUTH_LOGOUT, ROUTE_AUTH_REFRESH,
    ROUTE_AUTH_REGISTER, ROUTE_AUTH_SESSION, ROUTE_AUTH_SESSIONS, ROUTE_AUTH_SESSIONS_REVOKE,
    ROUTE_AUTH_VERIFY, ROUTE_AUTOPILOTS, ROUTE_AUTOPILOTS_BY_ID, ROUTE_AUTOPILOTS_STREAM,
    ROUTE_AUTOPILOTS_THREADS, ROUTE_INBOX_REFRESH, ROUTE_INBOX_REPLY_SEND,
    ROUTE_INBOX_THREAD_APPROVE, ROUTE_INBOX_THREAD_DETAIL, ROUTE_INBOX_THREAD_REJECT,
    ROUTE_INBOX_THREADS, ROUTE_KHALA_TOKEN, ROUTE_L402_DEPLOYMENTS, ROUTE_L402_PAYWALL_BY_ID,
    ROUTE_L402_PAYWALLS, ROUTE_L402_SETTLEMENTS, ROUTE_L402_TRANSACTION_BY_ID,
    ROUTE_L402_TRANSACTIONS, ROUTE_L402_WALLET, ROUTE_LEGACY_CHAT_STREAM,
    ROUTE_LEGACY_CHATS_STREAM, ROUTE_LIGHTNING_OPS_CONTROL_PLANE_MUTATION,
    ROUTE_LIGHTNING_OPS_CONTROL_PLANE_QUERY, ROUTE_ME, ROUTE_OPENAPI_JSON, ROUTE_ORGS_ACTIVE,
    ROUTE_ORGS_MEMBERSHIPS, ROUTE_PAYMENTS_INVOICE, ROUTE_PAYMENTS_PAY, ROUTE_PAYMENTS_SEND_SPARK,
    ROUTE_POLICY_AUTHORIZE, ROUTE_RUNTIME_CODEX_WORKER_BY_ID, ROUTE_RUNTIME_CODEX_WORKER_EVENTS,
    ROUTE_RUNTIME_CODEX_WORKER_REQUESTS, ROUTE_RUNTIME_CODEX_WORKER_STOP,
    ROUTE_RUNTIME_CODEX_WORKER_STREAM, ROUTE_RUNTIME_CODEX_WORKERS,
    ROUTE_RUNTIME_INTERNAL_SECRET_FETCH, ROUTE_RUNTIME_SKILLS_RELEASE,
    ROUTE_RUNTIME_SKILLS_SKILL_SPEC_PUBLISH, ROUTE_RUNTIME_SKILLS_SKILL_SPECS,
    ROUTE_RUNTIME_SKILLS_TOOL_SPECS, ROUTE_RUNTIME_THREAD_MESSAGES, ROUTE_RUNTIME_THREADS,
    ROUTE_RUNTIME_TOOLS_EXECUTE, ROUTE_RUNTIME_WORKER_BY_ID, ROUTE_RUNTIME_WORKER_HEARTBEAT,
    ROUTE_RUNTIME_WORKER_STATUS, ROUTE_RUNTIME_WORKERS, ROUTE_SETTINGS_AUTOPILOT,
    ROUTE_SETTINGS_INTEGRATIONS_GOOGLE, ROUTE_SETTINGS_INTEGRATIONS_GOOGLE_CALLBACK,
    ROUTE_SETTINGS_INTEGRATIONS_GOOGLE_REDIRECT, ROUTE_SETTINGS_INTEGRATIONS_RESEND,
    ROUTE_SETTINGS_INTEGRATIONS_RESEND_TEST, ROUTE_SETTINGS_PROFILE, ROUTE_SHOUTS,
    ROUTE_SHOUTS_ZONES, ROUTE_SMOKE_STREAM, ROUTE_SYNC_TOKEN, ROUTE_TOKENS, ROUTE_TOKENS_BY_ID,
    ROUTE_TOKENS_CURRENT, ROUTE_V1_AUTH_SESSION, ROUTE_V1_AUTH_SESSIONS,
    ROUTE_V1_AUTH_SESSIONS_REVOKE, ROUTE_V1_CONTROL_ROUTE_SPLIT_EVALUATE,
    ROUTE_V1_CONTROL_ROUTE_SPLIT_OVERRIDE, ROUTE_V1_CONTROL_ROUTE_SPLIT_STATUS,
    ROUTE_V1_CONTROL_RUNTIME_ROUTING_EVALUATE, ROUTE_V1_CONTROL_RUNTIME_ROUTING_OVERRIDE,
    ROUTE_V1_CONTROL_RUNTIME_ROUTING_STATUS, ROUTE_V1_CONTROL_STATUS, ROUTE_V1_SYNC_TOKEN,
    ROUTE_WEBHOOKS_RESEND, ROUTE_WHISPERS, ROUTE_WHISPERS_READ, openapi_document,
};
use crate::render::{
    apply_html_security_headers, apply_static_security_headers,
    chat_thread_select_fragment_response, chat_views_for_bundle,
    feed_items_append_fragment_response, feed_main_select_fragment_response,
    session_view_from_bundle, web_fragment_response, web_response_for_page, web_shell_entry,
};
use crate::route_split::{
    HtmxModeDecision, HtmxModeTarget, RouteSplitDecision, RouteSplitService, RouteTarget,
};
use crate::runtime_admin::{
    route_split_evaluate, route_split_override, route_split_status, runtime_routing_evaluate,
    runtime_routing_override, runtime_routing_status,
};
use crate::runtime_routing::{RuntimeDriver, RuntimeRoutingResolveInput, RuntimeRoutingService};
use crate::stats::{
    compute_fleet_fragment, compute_main_fragment, compute_metrics_fragment, compute_page,
    stats_main_fragment, stats_metrics_fragment, stats_page, stats_pools_fragment,
    web_compute_provider_disable,
};
use crate::sync_handlers::sync_token;
use crate::sync_token::{SyncTokenError, SyncTokenIssueRequest, SyncTokenIssuer};
use crate::web_htmx::{
    HtmxRequest, classify_request as classify_htmx_request,
    notice_response as htmx_notice_response, redirect_response as htmx_redirect_response,
    set_push_url_header as htmx_set_push_url_header, set_trigger_header as htmx_set_trigger_header,
};
use crate::web_maud::{
    ChatMessageView, ChatThreadView, ComputeDeviceView, ComputeMetricsView, ComputeProviderView,
    FeedItemView, FeedZoneView, IntegrationStatusView, L402DeploymentView, L402PaywallView,
    L402TransactionView, L402WalletSummaryView, LiquidityPoolView, LiquidityStatsMetricsView,
    SessionView, WebBody, WebPage,
    render_chat_thread_select_fragment as render_maud_chat_thread_select_fragment,
    render_compute_fleet_fragment as render_maud_compute_fleet_fragment,
    render_compute_metrics_fragment as render_maud_compute_metrics_fragment,
    render_feed_items_append_fragment as render_maud_feed_items_append_fragment,
    render_feed_main_select_fragment as render_maud_feed_main_select_fragment,
    render_main_fragment as render_maud_main_fragment, render_page as render_maud_page,
    render_stats_metrics_fragment as render_maud_stats_metrics_fragment,
    render_stats_pools_fragment as render_maud_stats_pools_fragment,
};

const SERVICE_NAME: &str = "openagents-control-service";
const CHALLENGE_COOKIE_NAME: &str = "oa_magic_challenge";
const AUTH_ACCESS_COOKIE_NAME: &str = "oa_access_token";
const AUTH_REFRESH_COOKIE_NAME: &str = "oa_refresh_token";
const LOCAL_TEST_AUTH_COOKIE_NAME: &str = "oa_local_test_auth";
const CACHE_API_NO_STORE: &str = "no-store";
const CACHE_IMMUTABLE_ONE_YEAR: &str = "public, max-age=31536000, immutable";
const CACHE_SHORT_LIVED: &str = "public, max-age=60";
const CACHE_MANIFEST: &str = "no-cache, no-store, must-revalidate";
const HTML_CONTENT_SECURITY_POLICY: &str = "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob:; font-src 'self' data:; connect-src 'self' ws: wss:; object-src 'none'; base-uri 'self'; frame-ancestors 'none'; form-action 'self'";
const HTML_REFERRER_POLICY: &str = "strict-origin-when-cross-origin";
const HTML_X_FRAME_OPTIONS: &str = "DENY";
const HTML_PERMISSIONS_POLICY: &str = "camera=(), microphone=(), geolocation=()";
const X_CONTENT_TYPE_OPTIONS_NOSNIFF: &str = "nosniff";
const CORS_ALLOW_HEADERS: &str = "authorization,content-type,x-request-id,x-xsrf-token,x-client";
const CORS_ALLOW_METHODS: &str = "GET,POST,PATCH,DELETE,OPTIONS";
const CORS_MAX_AGE_SECONDS: &str = "600";
const CORS_VARY_HEADERS: &str =
    "Origin, Access-Control-Request-Method, Access-Control-Request-Headers";
const HEADER_OA_CLIENT_BUILD_ID: &str = "x-oa-client-build-id";
const HEADER_OA_COMPAT_CODE: &str = "x-oa-compatibility-code";
const HEADER_OA_COMPAT_MAX_BUILD: &str = "x-oa-compatibility-max-client-build-id";
const HEADER_OA_COMPAT_MAX_SCHEMA: &str = "x-oa-compatibility-max-schema-version";
const HEADER_OA_COMPAT_MIN_BUILD: &str = "x-oa-compatibility-min-client-build-id";
const HEADER_OA_COMPAT_MIN_SCHEMA: &str = "x-oa-compatibility-min-schema-version";
const HEADER_OA_COMPAT_PROTOCOL: &str = "x-oa-compatibility-protocol-version";
const HEADER_OA_COMPAT_UPGRADE_REQUIRED: &str = "x-oa-compatibility-upgrade-required";
const HEADER_OA_PROTOCOL_VERSION: &str = "x-oa-protocol-version";
const HEADER_OA_SMOKE: &str = "x-oa-smoke";
const HEADER_OA_SMOKE_SECRET: &str = "x-oa-smoke-secret";
const HEADER_OA_SCHEMA_VERSION: &str = "x-oa-schema-version";
const HEADER_X_FORWARDED_FOR: &str = "x-forwarded-for";
const HEADER_X_REAL_IP: &str = "x-real-ip";
const HEADER_CONTENT_SECURITY_POLICY: &str = "content-security-policy";
const HEADER_PERMISSIONS_POLICY: &str = "permissions-policy";
const HEADER_REFERRER_POLICY: &str = "referrer-policy";
const RUNTIME_INTERNAL_BODY_HASH_HEADER: &str = "x-oa-internal-body-sha256";
const RUNTIME_INTERNAL_KEY_ID_HEADER: &str = "x-oa-internal-key-id";
const RUNTIME_INTERNAL_NONCE_HEADER: &str = "x-oa-internal-nonce";
const RUNTIME_INTERNAL_SIGNATURE_HEADER: &str = "x-oa-internal-signature";
const RUNTIME_INTERNAL_TIMESTAMP_HEADER: &str = "x-oa-internal-timestamp";
const HEADER_X_CONTENT_TYPE_OPTIONS: &str = "x-content-type-options";
const HEADER_X_FRAME_OPTIONS: &str = "x-frame-options";
const MAINTENANCE_BYPASS_QUERY_PARAM: &str = "maintenance_bypass";
const MAINTENANCE_CACHE_CONTROL: &str = "no-store, no-cache, must-revalidate";
const THROTTLE_AUTH_EMAIL_LIMIT: usize = 30;
const THROTTLE_AUTH_EMAIL_WINDOW_SECONDS: i64 = 60;
const THROTTLE_LOGIN_EMAIL_LIMIT: usize = 6;
const THROTTLE_LOGIN_EMAIL_WINDOW_SECONDS: i64 = 60;
const THROTTLE_LOGIN_VERIFY_LIMIT: usize = 10;
const THROTTLE_LOGIN_VERIFY_WINDOW_SECONDS: i64 = 60;
const THROTTLE_THREAD_MESSAGE_LIMIT: usize = 60;
const THROTTLE_THREAD_MESSAGE_WINDOW_SECONDS: i64 = 60;
const THROTTLE_CODEX_CONTROL_REQUEST_LIMIT: usize = 60;
const THROTTLE_CODEX_CONTROL_REQUEST_WINDOW_SECONDS: i64 = 60;
const RESEND_WEBHOOK_PROVIDER: &str = "resend";
const RESEND_SVIX_ID_HEADER: &str = "svix-id";
const RESEND_SVIX_TIMESTAMP_HEADER: &str = "svix-timestamp";
const RESEND_SVIX_SIGNATURE_HEADER: &str = "svix-signature";
const RUNTIME_INTERNAL_NONCE_GRACE_SECONDS: i64 = 5;
const RUNTIME_INTERNAL_MAX_BODY_BYTES: usize = 1024 * 1024;
const CODEX_CONTROL_METHOD_ALLOWLIST: &[&str] = &[
    "thread/start",
    "thread/resume",
    "turn/start",
    "turn/interrupt",
    "thread/list",
    "thread/read",
];
const AUTOPILOT_AUTHENTICATED_TOOLS: &[&str] = &[
    "openagents_api",
    "lightning_l402_fetch",
    "lightning_l402_approve",
    "lightning_l402_paywall_create",
    "lightning_l402_paywall_update",
    "lightning_l402_paywall_delete",
];
const AUTOPILOT_ALL_TOOLS: &[&str] = &[
    "chat_login",
    "openagents_api",
    "lightning_l402_fetch",
    "lightning_l402_approve",
    "lightning_l402_paywall_create",
    "lightning_l402_paywall_update",
    "lightning_l402_paywall_delete",
];
const AUTOPILOT_GUEST_ALLOWED_TOOLS: &[&str] = &["chat_login", "openagents_api"];
type HmacSha256 = Hmac<Sha256>;

#[derive(Clone)]
struct AppState {
    config: Arc<Config>,
    auth: AuthService,
    observability: Observability,
    route_split: RouteSplitService,
    runtime_routing: RuntimeRoutingService,
    khala_token_issuer: KhalaTokenIssuer,
    sync_token_issuer: SyncTokenIssuer,
    codex_thread_store: CodexThreadStore,
    _domain_store: DomainStore,
    runtime_revocation_client: Option<RuntimeRevocationClient>,
    throttle_state: ThrottleState,
    codex_control_receipts: CodexControlReceiptState,
    runtime_tool_receipts: RuntimeToolReceiptState,
    runtime_skill_registry: RuntimeSkillRegistryState,
    runtime_workers: RuntimeWorkerState,
    lightning_ops_control_plane: LightningOpsControlPlaneState,
    runtime_internal_nonces: RuntimeInternalNonceState,
    google_oauth_states: GoogleOauthStateStore,
    started_at: SystemTime,
}

#[derive(Clone, Default)]
struct ThrottleState {
    buckets: Arc<Mutex<HashMap<String, VecDeque<i64>>>>,
}

#[derive(Clone, Default)]
struct RuntimeInternalNonceState {
    entries: Arc<Mutex<HashMap<String, i64>>>,
}

#[derive(Clone, Default)]
struct CodexControlReceiptState {
    entries: Arc<Mutex<HashMap<String, serde_json::Value>>>,
}

#[derive(Clone, Default)]
struct RuntimeToolReceiptState {
    entries: Arc<Mutex<HashMap<String, serde_json::Value>>>,
}

#[derive(Clone, Default)]
struct RuntimeSkillRegistryState {
    tool_specs: Arc<Mutex<HashMap<String, serde_json::Value>>>,
    skill_specs: Arc<Mutex<HashMap<String, serde_json::Value>>>,
    releases: Arc<Mutex<HashMap<String, serde_json::Value>>>,
}

#[derive(Clone, Default)]
struct RuntimeWorkerState {
    workers: Arc<Mutex<HashMap<String, RuntimeWorkerRecord>>>,
    events: Arc<Mutex<HashMap<String, Vec<RuntimeWorkerEventRecord>>>>,
}

#[derive(Clone, Default)]
struct GoogleOauthStateStore {
    entries: Arc<Mutex<HashMap<String, String>>>,
}

#[derive(Clone, Default)]
struct LightningOpsControlPlaneState {
    store: Arc<Mutex<LightningOpsControlPlaneStore>>,
}

#[derive(Default)]
struct LightningOpsControlPlaneStore {
    deployments: HashMap<String, LightningOpsDeploymentRecord>,
    gateway_events: Vec<LightningOpsGatewayEventRecord>,
    invoices: HashMap<String, LightningOpsInvoiceRecord>,
    settlements: HashMap<String, LightningOpsSettlementRecord>,
    global_security: Option<LightningOpsGlobalSecurityRecord>,
    owner_controls: HashMap<String, LightningOpsOwnerControlRecord>,
    credential_roles: HashMap<String, LightningOpsCredentialRoleRecord>,
}

#[derive(Clone)]
struct LightningOpsDeploymentRecord {
    deployment_id: String,
    paywall_id: Option<String>,
    owner_id: Option<String>,
    config_hash: String,
    image_digest: Option<String>,
    status: String,
    diagnostics: Option<serde_json::Value>,
    metadata: Option<serde_json::Value>,
    request_id: Option<String>,
    applied_at_ms: Option<i64>,
    rolled_back_from: Option<String>,
    created_at: chrono::DateTime<Utc>,
    updated_at: chrono::DateTime<Utc>,
}

#[derive(Clone)]
struct LightningOpsGatewayEventRecord {
    event_id: String,
    paywall_id: String,
    owner_id: String,
    event_type: String,
    level: String,
    request_id: Option<String>,
    metadata: Option<serde_json::Value>,
    created_at: chrono::DateTime<Utc>,
}

#[derive(Clone)]
struct LightningOpsInvoiceRecord {
    invoice_id: String,
    paywall_id: String,
    owner_id: String,
    amount_msats: i64,
    status: String,
    payment_hash: Option<String>,
    payment_request: Option<String>,
    payment_proof_ref: Option<String>,
    request_id: Option<String>,
    settled_at_ms: Option<i64>,
    created_at: chrono::DateTime<Utc>,
    updated_at: chrono::DateTime<Utc>,
}

#[derive(Clone)]
struct LightningOpsSettlementRecord {
    settlement_id: String,
    paywall_id: String,
    owner_id: String,
    invoice_id: Option<String>,
    amount_msats: i64,
    payment_proof_ref: String,
    request_id: Option<String>,
    metadata: Option<serde_json::Value>,
    created_at: chrono::DateTime<Utc>,
}

#[derive(Clone)]
struct LightningOpsGlobalSecurityRecord {
    global_pause: bool,
    deny_reason_code: Option<String>,
    deny_reason: Option<String>,
    updated_by: Option<String>,
    updated_at_ms: i64,
}

#[derive(Clone)]
struct LightningOpsOwnerControlRecord {
    owner_id: String,
    kill_switch: bool,
    deny_reason_code: Option<String>,
    deny_reason: Option<String>,
    updated_by: Option<String>,
    updated_at_ms: i64,
}

#[derive(Clone)]
struct LightningOpsCredentialRoleRecord {
    role: String,
    status: String,
    version: i64,
    fingerprint: Option<String>,
    note: Option<String>,
    updated_at_ms: i64,
    last_rotated_at_ms: Option<i64>,
    revoked_at_ms: Option<i64>,
}

#[derive(Clone)]
struct RuntimeWorkerRecord {
    worker_id: String,
    owner_user_id: String,
    status: String,
    latest_seq: u64,
    workspace_ref: Option<String>,
    codex_home_ref: Option<String>,
    adapter: String,
    metadata: Option<serde_json::Value>,
    started_at: Option<chrono::DateTime<Utc>>,
    stopped_at: Option<chrono::DateTime<Utc>>,
    last_heartbeat_at: Option<chrono::DateTime<Utc>>,
    heartbeat_stale_after_ms: u64,
    updated_at: chrono::DateTime<Utc>,
}

#[derive(Clone)]
struct RuntimeWorkerEventRecord {
    seq: u64,
    event_type: String,
    payload: serde_json::Value,
    occurred_at: chrono::DateTime<Utc>,
}

#[derive(Clone)]
struct RuntimeRevocationClient {
    endpoint_url: String,
    signature_secret: String,
    signature_ttl_seconds: u64,
    http: reqwest::Client,
}

#[derive(Debug, Serialize)]
struct RuntimeRevocationRequest {
    session_ids: Vec<String>,
    device_ids: Vec<String>,
    reason: String,
}

#[derive(Debug, Serialize)]
struct HealthResponse {
    status: &'static str,
    service: &'static str,
    version: &'static str,
    uptime_seconds: u64,
    auth_provider: &'static str,
}

#[derive(Debug, Serialize)]
struct ReadinessResponse {
    status: &'static str,
    static_dir: String,
}

#[derive(Debug, Serialize)]
struct CompatibilityErrorDetail {
    code: String,
    message: String,
}

#[derive(Debug, Serialize)]
struct CompatibilityErrorResponse {
    message: String,
    error: CompatibilityErrorDetail,
    compatibility: CompatibilityFailure,
}

#[derive(Debug, Deserialize)]
struct SendEmailCodeRequest {
    email: String,
}

#[derive(Debug, Deserialize)]
struct LoginEmailForm {
    email: String,
}

#[derive(Debug, Deserialize)]
struct VerifyEmailCodeRequest {
    code: String,
    #[serde(default)]
    challenge_id: Option<String>,
    #[serde(default, alias = "deviceId")]
    device_id: Option<String>,
}

#[derive(Debug, Deserialize)]
struct LoginVerifyForm {
    code: String,
    #[serde(default, alias = "challengeId")]
    challenge_id: Option<String>,
}

#[derive(Debug, Deserialize)]
struct AuthRegisterRequest {
    email: String,
    #[serde(default)]
    name: Option<String>,
    #[serde(default, alias = "tokenName")]
    token_name: Option<String>,
    #[serde(default, alias = "tokenAbilities")]
    token_abilities: Option<Vec<String>>,
    #[serde(default, alias = "createAutopilot")]
    create_autopilot: Option<bool>,
    #[serde(default, alias = "autopilotDisplayName")]
    autopilot_display_name: Option<String>,
}

#[derive(Debug, Deserialize)]
struct RefreshSessionRequest {
    #[serde(default)]
    refresh_token: Option<String>,
    #[serde(default)]
    rotate_refresh_token: Option<bool>,
    #[serde(default)]
    device_id: Option<String>,
}

#[derive(Debug, Deserialize)]
struct ListSessionsRequest {
    #[serde(default)]
    device_id: Option<String>,
}

#[derive(Debug, Deserialize)]
struct RevokeSessionsRequest {
    #[serde(default)]
    session_id: Option<String>,
    #[serde(default)]
    device_id: Option<String>,
    #[serde(default)]
    revoke_all_sessions: Option<bool>,
    #[serde(default)]
    include_current: Option<bool>,
    #[serde(default)]
    reason: Option<SessionRevocationReason>,
}

#[derive(Debug, Deserialize)]
struct SetActiveOrgRequest {
    org_id: String,
}

#[derive(Debug, Deserialize)]
struct PolicyAuthorizeRequest {
    #[serde(default)]
    org_id: Option<String>,
    #[serde(default)]
    required_scopes: Vec<String>,
    #[serde(default)]
    requested_topics: Vec<String>,
}

#[derive(Debug, Deserialize)]
struct MeQuery {
    #[serde(default)]
    chat_limit: Option<usize>,
}

#[derive(Debug, Deserialize)]
struct AutopilotListQuery {
    #[serde(default)]
    limit: Option<usize>,
}

#[derive(Debug, Deserialize)]
struct AutopilotThreadListQuery {
    #[serde(default)]
    limit: Option<usize>,
}

#[derive(Debug, Deserialize)]
struct AutopilotStreamQuery {
    #[serde(default, alias = "conversationId")]
    conversation_id: Option<String>,
    #[serde(default, alias = "threadId")]
    thread_id: Option<String>,
}

#[derive(Debug, Deserialize, Default)]
struct L402AutopilotQuery {
    #[serde(default)]
    autopilot: Option<String>,
}

#[derive(Debug, Deserialize, Default)]
struct L402TransactionsQuery {
    #[serde(default)]
    autopilot: Option<String>,
    #[serde(default, alias = "perPage")]
    per_page: Option<usize>,
    #[serde(default)]
    page: Option<usize>,
}

#[derive(Debug, Deserialize)]
struct L402PaywallCreateRequestPayload {
    name: String,
    #[serde(alias = "hostRegexp")]
    host_regexp: String,
    #[serde(alias = "pathRegexp")]
    path_regexp: String,
    #[serde(alias = "priceMsats")]
    price_msats: u64,
    upstream: String,
    #[serde(default)]
    enabled: Option<bool>,
    #[serde(default, alias = "metadata")]
    meta: Option<serde_json::Value>,
}

#[derive(Debug, Deserialize, Default)]
struct L402PaywallUpdateRequestPayload {
    #[serde(default)]
    name: Option<String>,
    #[serde(default, alias = "hostRegexp")]
    host_regexp: Option<String>,
    #[serde(default, alias = "pathRegexp")]
    path_regexp: Option<String>,
    #[serde(default, alias = "priceMsats")]
    price_msats: Option<u64>,
    #[serde(default)]
    upstream: Option<String>,
    #[serde(default)]
    enabled: Option<bool>,
    #[serde(default, alias = "metadata")]
    meta: Option<serde_json::Value>,
}

#[derive(Debug, Deserialize, Default)]
struct AgentPaymentsWalletUpsertRequestPayload {
    #[serde(default)]
    mnemonic: Option<String>,
}

#[derive(Debug, Deserialize)]
struct AgentPaymentsCreateInvoiceRequestPayload {
    #[serde(alias = "amountSats")]
    amount_sats: u64,
    #[serde(default)]
    description: Option<String>,
}

#[derive(Debug, Deserialize)]
struct AgentPaymentsPayInvoiceRequestPayload {
    invoice: String,
    #[serde(default, alias = "maxAmountSats")]
    max_amount_sats: Option<u64>,
    #[serde(default, alias = "maxAmountMsats")]
    max_amount_msats: Option<u64>,
    #[serde(default, alias = "timeoutMs")]
    timeout_ms: Option<u64>,
    #[serde(default)]
    host: Option<String>,
}

#[derive(Debug, Deserialize)]
struct AgentPaymentsSendSparkRequestPayload {
    #[serde(alias = "sparkAddress")]
    spark_address: String,
    #[serde(alias = "amountSats")]
    amount_sats: u64,
    #[serde(default, alias = "timeoutMs")]
    timeout_ms: Option<u64>,
}

#[derive(Debug, Clone)]
struct AgentInvoicePaymentResult {
    payment_id: Option<String>,
    preimage: String,
    status: String,
    raw: serde_json::Value,
}

#[derive(Debug, Clone)]
struct AgentInvoicePaymentError {
    status: StatusCode,
    code: String,
    message: String,
}

#[derive(Debug, Deserialize, Default)]
struct ShoutsIndexQuery {
    #[serde(default)]
    zone: Option<String>,
    #[serde(default)]
    limit: Option<String>,
    #[serde(default, alias = "beforeId")]
    before_id: Option<String>,
    #[serde(default)]
    since: Option<String>,
}

#[derive(Debug, Deserialize, Default)]
struct FeedPageQuery {
    #[serde(default)]
    zone: Option<String>,
    #[serde(default)]
    limit: Option<String>,
    #[serde(default, alias = "beforeId")]
    before_id: Option<String>,
    #[serde(default)]
    since: Option<String>,
}

#[derive(Debug, Deserialize, Default)]
struct ShoutsZonesQuery {
    #[serde(default)]
    limit: Option<String>,
}

#[derive(Debug, Deserialize, Default)]
struct ShoutStoreRequestPayload {
    #[serde(default)]
    body: Option<String>,
    #[serde(default)]
    text: Option<String>,
    #[serde(default)]
    zone: Option<String>,
}

#[derive(Debug, Deserialize, Default)]
struct WhispersIndexQuery {
    #[serde(default)]
    with: Option<String>,
    #[serde(default)]
    limit: Option<String>,
    #[serde(default, alias = "beforeId")]
    before_id: Option<String>,
}

#[derive(Debug, Deserialize, Default)]
struct WhisperStoreRequestPayload {
    #[serde(default, alias = "recipientId")]
    recipient_id: Option<String>,
    #[serde(default, alias = "recipientHandle")]
    recipient_handle: Option<String>,
    #[serde(default)]
    body: Option<String>,
}

#[derive(Debug, Deserialize, Default)]
struct UpsertResendIntegrationRequestPayload {
    #[serde(default, alias = "resendApiKey")]
    resend_api_key: Option<String>,
    #[serde(default, alias = "senderEmail")]
    sender_email: Option<String>,
    #[serde(default, alias = "senderName")]
    sender_name: Option<String>,
}

#[derive(Debug, Deserialize, Default)]
struct GoogleOauthCallbackQuery {
    #[serde(default)]
    error: Option<String>,
    #[serde(default)]
    state: Option<String>,
    #[serde(default)]
    code: Option<String>,
}

#[derive(Debug, Deserialize, Default)]
struct InboxThreadsQuery {
    #[serde(default)]
    limit: Option<String>,
}

#[derive(Debug, Deserialize, Default)]
struct InboxRefreshRequestPayload {
    #[serde(default)]
    limit: Option<u64>,
}

#[derive(Debug, Deserialize, Default)]
struct InboxDraftActionRequestPayload {
    #[serde(default)]
    detail: Option<String>,
}

#[derive(Debug, Deserialize, Default)]
struct InboxSendReplyRequestPayload {
    #[serde(default)]
    body: Option<String>,
}

#[derive(Debug, Serialize)]
struct InboxSnapshotEnvelope {
    request_id: String,
    source: String,
    snapshot: InboxSnapshot,
}

#[derive(Debug, Serialize)]
struct InboxThreadDetailResponse {
    request_id: String,
    thread_id: String,
    thread: InboxThreadSummary,
    messages: Vec<InboxThreadMessage>,
    audit_log: Vec<InboxAuditEntry>,
}

#[derive(Debug, Serialize, Clone)]
struct InboxThreadMessage {
    id: String,
    from: Option<String>,
    to: Option<String>,
    subject: Option<String>,
    snippet: String,
    body: String,
    created_at: Option<String>,
}

#[derive(Debug, Serialize)]
struct InboxReplySendResponse {
    request_id: String,
    thread_id: String,
    message_id: String,
    status: String,
}

#[derive(Debug, Clone, Deserialize, Serialize, Default)]
struct GoogleIntegrationSecretPayload {
    #[serde(default)]
    refresh_token: Option<String>,
    #[serde(default)]
    access_token: Option<String>,
    #[serde(default)]
    scope: Option<String>,
    #[serde(default)]
    token_type: Option<String>,
    #[serde(default)]
    expires_at: Option<String>,
    #[serde(default)]
    obtained_at: Option<String>,
}

#[derive(Debug, Deserialize, Default)]
struct GmailThreadListResponse {
    #[serde(default)]
    threads: Vec<GmailThreadListItem>,
}

#[derive(Debug, Deserialize, Default)]
struct GmailThreadListItem {
    id: String,
}

#[derive(Debug, Deserialize, Default)]
struct GmailThreadResponse {
    id: String,
    #[serde(default)]
    snippet: Option<String>,
    #[serde(default)]
    messages: Vec<GmailMessage>,
}

#[derive(Debug, Deserialize, Default)]
struct GmailMessage {
    id: String,
    #[serde(default)]
    snippet: Option<String>,
    #[serde(default, rename = "internalDate")]
    internal_date: Option<String>,
    #[serde(default)]
    payload: Option<GmailMessagePayload>,
}

#[derive(Debug, Deserialize, Default)]
struct GmailMessagePayload {
    #[serde(default, rename = "mimeType")]
    mime_type: Option<String>,
    #[serde(default)]
    headers: Vec<GmailHeader>,
    #[serde(default)]
    body: Option<GmailBody>,
    #[serde(default)]
    parts: Vec<GmailMessagePayload>,
}

#[derive(Debug, Deserialize, Default)]
struct GmailHeader {
    name: String,
    value: String,
}

#[derive(Debug, Deserialize, Default)]
struct GmailBody {
    #[serde(default)]
    data: Option<String>,
}

#[derive(Debug, Deserialize)]
struct CreateAutopilotRequestPayload {
    #[serde(default)]
    handle: Option<String>,
    #[serde(default, alias = "displayName")]
    display_name: Option<String>,
    #[serde(default)]
    avatar: Option<String>,
    #[serde(default)]
    tagline: Option<String>,
    #[serde(default)]
    status: Option<String>,
    #[serde(default)]
    visibility: Option<String>,
}

#[derive(Debug, Deserialize)]
struct CreateAutopilotThreadRequestPayload {
    #[serde(default)]
    title: Option<String>,
}

#[derive(Debug, Deserialize)]
struct UpdateAutopilotRequestPayload {
    #[serde(default, alias = "displayName")]
    display_name: Option<String>,
    #[serde(default)]
    status: Option<String>,
    #[serde(default)]
    visibility: Option<String>,
    #[serde(default)]
    avatar: Option<String>,
    #[serde(default)]
    tagline: Option<String>,
    #[serde(default)]
    profile: Option<UpdateAutopilotProfilePayload>,
    #[serde(default)]
    policy: Option<UpdateAutopilotPolicyPayload>,
}

#[derive(Debug, Deserialize, Default)]
struct UpdateAutopilotProfilePayload {
    #[serde(default, alias = "ownerDisplayName")]
    owner_display_name: Option<String>,
    #[serde(default, alias = "personaSummary")]
    persona_summary: Option<String>,
    #[serde(default, alias = "autopilotVoice")]
    autopilot_voice: Option<String>,
    #[serde(default)]
    principles: Option<serde_json::Value>,
    #[serde(default)]
    preferences: Option<serde_json::Value>,
    #[serde(default, alias = "onboardingAnswers")]
    onboarding_answers: Option<serde_json::Value>,
    #[serde(default, alias = "schemaVersion")]
    schema_version: Option<u16>,
}

#[derive(Debug, Deserialize, Default)]
struct UpdateAutopilotPolicyPayload {
    #[serde(default, alias = "modelProvider")]
    model_provider: Option<String>,
    #[serde(default)]
    model: Option<String>,
    #[serde(default, alias = "toolAllowlist")]
    tool_allowlist: Option<Vec<String>>,
    #[serde(default, alias = "toolDenylist")]
    tool_denylist: Option<Vec<String>>,
    #[serde(default, alias = "l402RequireApproval")]
    l402_require_approval: Option<bool>,
    #[serde(default, alias = "l402MaxSpendMsatsPerCall")]
    l402_max_spend_msats_per_call: Option<u64>,
    #[serde(default, alias = "l402MaxSpendMsatsPerDay")]
    l402_max_spend_msats_per_day: Option<u64>,
    #[serde(default, alias = "l402AllowedHosts")]
    l402_allowed_hosts: Option<Vec<String>>,
    #[serde(default, alias = "dataPolicy")]
    data_policy: Option<serde_json::Value>,
}

#[derive(Debug, Deserialize)]
struct CreateTokenRequestPayload {
    name: String,
    #[serde(default)]
    abilities: Option<Vec<String>>,
    #[serde(default, alias = "expiresAt")]
    expires_at: Option<String>,
}

#[derive(Debug, Deserialize)]
struct KhalaTokenRequestPayload {
    #[serde(default)]
    scope: Vec<String>,
    #[serde(default)]
    workspace_id: Option<String>,
    #[serde(default)]
    role: Option<String>,
}

#[derive(Debug, Deserialize)]
struct UpdateProfileRequestPayload {
    name: String,
}

#[derive(Debug, Deserialize)]
struct DeleteProfileRequestPayload {
    email: String,
}

#[derive(Debug, Deserialize)]
struct UpdateSettingsAutopilotRequestPayload {
    #[serde(default, alias = "displayName")]
    display_name: Option<String>,
    #[serde(default)]
    tagline: Option<String>,
    #[serde(default, alias = "ownerDisplayName")]
    owner_display_name: Option<String>,
    #[serde(default, alias = "personaSummary")]
    persona_summary: Option<String>,
    #[serde(default, alias = "autopilotVoice")]
    autopilot_voice: Option<String>,
    #[serde(default, alias = "principlesText")]
    principles_text: Option<String>,
}

#[derive(Debug, Deserialize)]
struct SyncTokenRequestPayload {
    #[serde(default)]
    scopes: Vec<String>,
    #[serde(default)]
    topics: Vec<String>,
    #[serde(default)]
    ttl_seconds: Option<u32>,
    #[serde(default)]
    device_id: Option<String>,
}

#[derive(Debug, Deserialize)]
struct RouteSplitOverrideRequest {
    target: String,
    #[serde(default)]
    domain: Option<String>,
}

#[derive(Debug, Deserialize)]
struct RouteSplitEvaluateRequest {
    path: String,
    #[serde(default)]
    cohort_key: Option<String>,
}

#[derive(Debug, Deserialize)]
struct RuntimeRoutingEvaluateRequest {
    thread_id: String,
    #[serde(default)]
    user_id: Option<String>,
    #[serde(default)]
    autopilot_id: Option<String>,
}

#[derive(Debug, Deserialize)]
struct RuntimeRoutingOverrideRequest {
    scope_type: String,
    scope_id: String,
    driver: String,
    #[serde(default)]
    is_active: Option<bool>,
    #[serde(default)]
    reason: Option<String>,
    #[serde(default)]
    meta: Option<serde_json::Value>,
}

#[derive(Debug, Deserialize)]
struct SendThreadMessageRequest {
    text: String,
}

#[derive(Debug, Deserialize, Default)]
struct WebChatSendForm {
    text: String,
}

#[derive(Debug, Deserialize, Default)]
struct WebShoutForm {
    body: String,
    #[serde(default)]
    zone: Option<String>,
}

#[derive(Debug, Deserialize, Default)]
struct WebL402PaywallCreateForm {
    name: String,
    host_regexp: String,
    path_regexp: String,
    price_msats: String,
    upstream: String,
    #[serde(default)]
    enabled: Option<String>,
}

#[derive(Debug, Deserialize, Default)]
struct WebRouteSplitEvaluateForm {
    path: String,
    #[serde(default)]
    cohort_key: Option<String>,
}

#[derive(Debug, Deserialize, Default)]
struct WebRouteSplitOverrideForm {
    target: String,
    #[serde(default)]
    domain: Option<String>,
}

#[derive(Debug, Deserialize, Default)]
struct WebRuntimeRoutingEvaluateForm {
    thread_id: String,
    #[serde(default)]
    autopilot_id: Option<String>,
}

#[derive(Debug, Deserialize, Default)]
struct WebRuntimeRoutingOverrideForm {
    scope_type: String,
    scope_id: String,
    driver: String,
    #[serde(default)]
    is_active: Option<String>,
    #[serde(default)]
    reason: Option<String>,
}

#[derive(Debug, Deserialize, Default)]
struct WebLightningOpsForm {
    function_name: String,
    #[serde(default)]
    args_json: Option<String>,
}

#[derive(Debug, Deserialize)]
struct RuntimeCodexWorkerControlRequestEnvelope {
    request: RuntimeCodexWorkerControlRequest,
}

#[derive(Debug, Deserialize)]
struct RuntimeCodexWorkerControlRequest {
    request_id: String,
    method: String,
    #[serde(default)]
    params: serde_json::Value,
    #[serde(default)]
    request_version: Option<String>,
    #[serde(default)]
    source: Option<String>,
    #[serde(default)]
    session_id: Option<String>,
    #[serde(default)]
    thread_id: Option<String>,
}

#[derive(Debug, Deserialize)]
struct RuntimeCodexWorkersListQuery {
    #[serde(default)]
    status: Option<String>,
    #[serde(default)]
    workspace_ref: Option<String>,
    #[serde(default)]
    limit: Option<usize>,
}

#[derive(Debug, Deserialize)]
struct RuntimeCodexWorkerCreateRequestPayload {
    #[serde(default)]
    worker_id: Option<String>,
    #[serde(default)]
    workspace_ref: Option<String>,
    #[serde(default)]
    codex_home_ref: Option<String>,
    #[serde(default)]
    adapter: Option<String>,
    #[serde(default)]
    metadata: Option<serde_json::Value>,
}

#[derive(Debug, Deserialize)]
struct RuntimeCodexWorkerEventEnvelope {
    event: RuntimeCodexWorkerEventPayload,
}

#[derive(Debug, Deserialize)]
struct RuntimeCodexWorkerEventPayload {
    event_type: String,
    #[serde(default)]
    payload: Option<serde_json::Value>,
}

#[derive(Debug, Deserialize)]
struct RuntimeCodexWorkerStopRequestPayload {
    #[serde(default)]
    reason: Option<String>,
}

#[derive(Debug, Deserialize)]
struct RuntimeCodexWorkerStreamQuery {
    #[serde(default)]
    cursor: Option<u64>,
    #[serde(default)]
    tail_ms: Option<u32>,
}

#[derive(Debug, Deserialize)]
struct RuntimeToolsExecuteRequestPayload {
    #[serde(alias = "toolPack")]
    tool_pack: String,
    #[serde(default)]
    mode: Option<String>,
    #[serde(default)]
    manifest: Option<serde_json::Value>,
    #[serde(default, alias = "manifestRef")]
    manifest_ref: Option<serde_json::Value>,
    request: serde_json::Value,
    #[serde(default)]
    policy: Option<serde_json::Value>,
    #[serde(default, alias = "runId")]
    run_id: Option<String>,
    #[serde(default, alias = "threadId")]
    thread_id: Option<String>,
    #[serde(default, alias = "userId")]
    user_id: Option<serde_json::Value>,
}

#[derive(Debug, Deserialize)]
struct RuntimeToolSpecUpsertRequestPayload {
    tool_spec: serde_json::Value,
    #[serde(default)]
    state: Option<String>,
}

#[derive(Debug, Deserialize)]
struct RuntimeSkillSpecUpsertRequestPayload {
    skill_spec: serde_json::Value,
    #[serde(default)]
    state: Option<String>,
}

#[derive(Debug, Deserialize)]
struct LegacyChatsListQuery {
    #[serde(default)]
    limit: Option<usize>,
}

#[derive(Debug, Deserialize)]
struct LegacyCreateChatRequest {
    #[serde(default)]
    title: Option<String>,
}

#[derive(Debug, Deserialize)]
struct LocalTestLoginQuery {
    email: String,
    #[serde(default)]
    name: Option<String>,
    #[serde(default)]
    expires: Option<i64>,
    #[serde(default)]
    signature: Option<String>,
}

pub fn build_router(config: Config) -> Router {
    build_router_with_observability(config, Observability::default())
}

pub fn build_router_with_observability(config: Config, observability: Observability) -> Router {
    let auth = AuthService::from_config(&config);
    let route_split = RouteSplitService::from_config(&config);
    let runtime_routing = RuntimeRoutingService::from_config(&config);
    let khala_token_issuer = KhalaTokenIssuer::from_config(&config);
    let sync_token_issuer = SyncTokenIssuer::from_config(&config);
    let codex_thread_store = CodexThreadStore::from_config(&config);
    let domain_store = DomainStore::from_config(&config);
    let runtime_revocation_client = RuntimeRevocationClient::from_config(&config);
    let state = AppState {
        config: Arc::new(config),
        auth,
        observability,
        route_split,
        runtime_routing,
        khala_token_issuer,
        sync_token_issuer,
        codex_thread_store,
        _domain_store: domain_store,
        runtime_revocation_client,
        throttle_state: ThrottleState::default(),
        codex_control_receipts: CodexControlReceiptState::default(),
        runtime_tool_receipts: RuntimeToolReceiptState::default(),
        runtime_skill_registry: RuntimeSkillRegistryState::default(),
        runtime_workers: RuntimeWorkerState::default(),
        lightning_ops_control_plane: LightningOpsControlPlaneState::default(),
        runtime_internal_nonces: RuntimeInternalNonceState::default(),
        google_oauth_states: GoogleOauthStateStore::default(),
        started_at: SystemTime::now(),
    };
    let compatibility_state = state.clone();
    let maintenance_state = state.clone();
    let auth_email_throttle_state = state.clone();
    let login_email_throttle_state = state.clone();
    let login_verify_throttle_state = state.clone();
    let local_test_login_throttle_state = state.clone();
    let thread_message_throttle_state = state.clone();
    let codex_control_request_throttle_state = state.clone();
    let authenticated_routes_state = state.clone();
    let runtime_internal_state = state.clone();
    let workos_session_state = state.clone();
    let admin_state = state.clone();
    let runtime_internal_secret_fetch_path =
        normalize_route_path(&state.config.runtime_internal_secret_fetch_path);

    let web_auth_router = Router::new()
        .route("/login", get(login_page))
        .route(
            "/login/email",
            post(login_email).route_layer(middleware::from_fn_with_state(
                login_email_throttle_state,
                throttle_login_email_gate,
            )),
        )
        .route(
            "/login/verify",
            post(login_verify).route_layer(middleware::from_fn_with_state(
                login_verify_throttle_state,
                throttle_login_verify_gate,
            )),
        )
        .route("/logout", post(web_logout))
        .route(
            "/internal/test-login",
            get(local_test_login).route_layer(middleware::from_fn_with_state(
                local_test_login_throttle_state,
                throttle_auth_email_gate,
            )),
        );

    let public_api_router = Router::new()
        .route(
            ROUTE_LIGHTNING_OPS_CONTROL_PLANE_QUERY,
            post(lightning_ops_control_plane_query),
        )
        .route(
            ROUTE_LIGHTNING_OPS_CONTROL_PLANE_MUTATION,
            post(lightning_ops_control_plane_mutation),
        )
        .route(
            runtime_internal_secret_fetch_path.as_str(),
            post(runtime_internal_secret_fetch).route_layer(middleware::from_fn_with_state(
                runtime_internal_state,
                runtime_internal_request_gate,
            )),
        )
        .route(
            ROUTE_AUTH_EMAIL,
            post(send_email_code).route_layer(middleware::from_fn_with_state(
                auth_email_throttle_state,
                throttle_auth_email_gate,
            )),
        )
        .route(
            ROUTE_AUTH_REGISTER,
            post(auth_register).route_layer(middleware::from_fn_with_state(
                state.clone(),
                throttle_auth_email_gate,
            )),
        )
        .route(ROUTE_AUTH_VERIFY, post(verify_email_code))
        .route(ROUTE_AUTH_REFRESH, post(refresh_session))
        .route(ROUTE_SHOUTS, get(shouts_index))
        .route(ROUTE_SHOUTS_ZONES, get(shouts_zones))
        .route(ROUTE_SMOKE_STREAM, get(smoke_stream))
        .route(ROUTE_WEBHOOKS_RESEND, post(webhooks_resend_store));

    let protected_api_router = Router::new()
        .route(ROUTE_AUTH_SESSION, get(current_session))
        .route(ROUTE_AUTH_SESSIONS, get(list_sessions))
        .route(ROUTE_AUTH_SESSIONS_REVOKE, post(revoke_sessions))
        .route(ROUTE_AUTH_LOGOUT, post(logout_session))
        .route(ROUTE_ME, get(me))
        .route(
            ROUTE_AUTOPILOTS,
            get(list_autopilots).post(create_autopilot),
        )
        .route(
            ROUTE_AUTOPILOTS_BY_ID,
            get(show_autopilot).patch(update_autopilot),
        )
        .route(
            ROUTE_AUTOPILOTS_THREADS,
            get(list_autopilot_threads).post(create_autopilot_thread),
        )
        .route(ROUTE_AUTOPILOTS_STREAM, post(autopilot_stream))
        .route(
            ROUTE_TOKENS,
            get(list_personal_access_tokens)
                .post(create_personal_access_token)
                .delete(delete_all_personal_access_tokens),
        )
        .route(
            ROUTE_SETTINGS_PROFILE,
            get(settings_profile_show)
                .patch(settings_profile_update)
                .delete(settings_profile_delete),
        )
        .route(ROUTE_SETTINGS_AUTOPILOT, patch(settings_autopilot_update))
        .route(
            ROUTE_SETTINGS_INTEGRATIONS_RESEND,
            post(settings_integrations_resend_upsert)
                .delete(settings_integrations_resend_disconnect),
        )
        .route(
            ROUTE_SETTINGS_INTEGRATIONS_RESEND_TEST,
            post(settings_integrations_resend_test),
        )
        .route(
            ROUTE_SETTINGS_INTEGRATIONS_GOOGLE_REDIRECT,
            get(settings_integrations_google_redirect),
        )
        .route(
            ROUTE_SETTINGS_INTEGRATIONS_GOOGLE_CALLBACK,
            get(settings_integrations_google_callback),
        )
        .route(
            ROUTE_SETTINGS_INTEGRATIONS_GOOGLE,
            delete(settings_integrations_google_disconnect),
        )
        .route(ROUTE_INBOX_THREADS, get(inbox_threads_index))
        .route(ROUTE_INBOX_REFRESH, post(inbox_refresh))
        .route(ROUTE_INBOX_THREAD_DETAIL, get(inbox_thread_detail))
        .route(ROUTE_INBOX_THREAD_APPROVE, post(inbox_thread_approve))
        .route(ROUTE_INBOX_THREAD_REJECT, post(inbox_thread_reject))
        .route(ROUTE_INBOX_REPLY_SEND, post(inbox_thread_reply_send))
        .route(
            ROUTE_TOKENS_CURRENT,
            delete(delete_current_personal_access_token),
        )
        .route(ROUTE_TOKENS_BY_ID, delete(delete_personal_access_token))
        .route(ROUTE_KHALA_TOKEN, post(khala_token))
        .route(ROUTE_ORGS_MEMBERSHIPS, get(org_memberships))
        .route(ROUTE_ORGS_ACTIVE, post(set_active_org))
        .route(ROUTE_POLICY_AUTHORIZE, post(policy_authorize))
        .route(ROUTE_SYNC_TOKEN, post(sync_token))
        .route(ROUTE_SHOUTS, post(shouts_store))
        .route(ROUTE_WHISPERS, get(whispers_index).post(whispers_store))
        .route(ROUTE_WHISPERS_READ, patch(whispers_read))
        .route(
            ROUTE_AGENT_PAYMENTS_WALLET,
            get(agent_payments_wallet).post(agent_payments_upsert_wallet),
        )
        .route(ROUTE_AGENT_PAYMENTS_BALANCE, get(agent_payments_balance))
        .route(
            ROUTE_AGENT_PAYMENTS_INVOICE,
            post(agent_payments_create_invoice),
        )
        .route(ROUTE_AGENT_PAYMENTS_PAY, post(agent_payments_pay_invoice))
        .route(
            ROUTE_AGENT_PAYMENTS_SEND_SPARK,
            post(agent_payments_send_spark),
        )
        .route(
            ROUTE_AGENTS_ME_WALLET,
            get(agent_payments_wallet).post(agent_payments_upsert_wallet),
        )
        .route(ROUTE_AGENTS_ME_BALANCE, get(agent_payments_balance))
        .route(ROUTE_PAYMENTS_INVOICE, post(agent_payments_create_invoice))
        .route(ROUTE_PAYMENTS_PAY, post(agent_payments_pay_invoice))
        .route(ROUTE_PAYMENTS_SEND_SPARK, post(agent_payments_send_spark))
        .route(ROUTE_L402_WALLET, get(l402_wallet))
        .route(ROUTE_L402_TRANSACTIONS, get(l402_transactions))
        .route(ROUTE_L402_TRANSACTION_BY_ID, get(l402_transaction_show))
        .route(ROUTE_L402_PAYWALLS, get(l402_paywalls))
        .route(
            ROUTE_L402_PAYWALLS,
            post(l402_paywall_create).route_layer(middleware::from_fn_with_state(
                admin_state.clone(),
                admin_email_gate,
            )),
        )
        .route(
            ROUTE_L402_PAYWALL_BY_ID,
            patch(l402_paywall_update)
                .delete(l402_paywall_delete)
                .route_layer(middleware::from_fn_with_state(
                    admin_state.clone(),
                    admin_email_gate,
                )),
        )
        .route(ROUTE_L402_SETTLEMENTS, get(l402_settlements))
        .route(ROUTE_L402_DEPLOYMENTS, get(l402_deployments))
        .route(
            "/api/chat/guest-session",
            get(legacy_chat_guest_session_retired),
        )
        .route(ROUTE_LEGACY_CHAT_STREAM, post(legacy_chat_stream))
        .route(
            "/api/chats",
            get(legacy_chats_index).post(legacy_chats_store),
        )
        .route("/api/chats/:conversation_id", get(legacy_chats_show))
        .route(
            "/api/chats/:conversation_id/messages",
            get(legacy_chats_messages),
        )
        .route(ROUTE_LEGACY_CHATS_STREAM, post(legacy_chats_stream))
        .route("/api/chats/:conversation_id/runs", get(legacy_chats_runs))
        .route(
            "/api/chats/:conversation_id/runs/:run_id/events",
            get(legacy_chats_run_events),
        )
        .route(ROUTE_RUNTIME_TOOLS_EXECUTE, post(runtime_tools_execute))
        .route(
            ROUTE_RUNTIME_SKILLS_TOOL_SPECS,
            get(runtime_skill_tool_specs_list).post(runtime_skill_tool_spec_store),
        )
        .route(
            ROUTE_RUNTIME_SKILLS_SKILL_SPECS,
            get(runtime_skill_specs_list).post(runtime_skill_spec_store),
        )
        .route(
            ROUTE_RUNTIME_SKILLS_SKILL_SPEC_PUBLISH,
            post(runtime_skill_spec_publish),
        )
        .route(
            ROUTE_RUNTIME_SKILLS_RELEASE,
            get(runtime_skill_release_show),
        )
        .route(ROUTE_RUNTIME_THREADS, get(list_runtime_threads))
        .route(
            ROUTE_RUNTIME_THREAD_MESSAGES,
            get(list_runtime_thread_messages)
                .post(send_thread_message)
                .route_layer(middleware::from_fn_with_state(
                    thread_message_throttle_state,
                    throttle_thread_message_gate,
                )),
        )
        .route(
            ROUTE_RUNTIME_CODEX_WORKERS,
            get(runtime_codex_workers_index).post(runtime_codex_workers_create),
        )
        .route(
            ROUTE_RUNTIME_CODEX_WORKER_BY_ID,
            get(runtime_codex_worker_show),
        )
        .route(
            ROUTE_RUNTIME_CODEX_WORKER_STREAM,
            get(runtime_codex_worker_stream),
        )
        .route(
            ROUTE_RUNTIME_CODEX_WORKER_EVENTS,
            post(runtime_codex_worker_events),
        )
        .route(
            ROUTE_RUNTIME_CODEX_WORKER_STOP,
            post(runtime_codex_worker_stop),
        )
        .route(
            ROUTE_RUNTIME_CODEX_WORKER_REQUESTS,
            post(runtime_codex_worker_request).route_layer(middleware::from_fn_with_state(
                codex_control_request_throttle_state,
                throttle_codex_control_request_gate,
            )),
        )
        .route(
            ROUTE_RUNTIME_WORKERS,
            get(runtime_workers_index).post(runtime_workers_create),
        )
        .route(ROUTE_RUNTIME_WORKER_BY_ID, get(runtime_worker_show))
        .route(
            ROUTE_RUNTIME_WORKER_HEARTBEAT,
            post(runtime_worker_heartbeat),
        )
        .route(ROUTE_RUNTIME_WORKER_STATUS, post(runtime_worker_transition))
        .route(ROUTE_V1_AUTH_SESSION, get(current_session))
        .route(ROUTE_V1_AUTH_SESSIONS, get(list_sessions))
        .route(ROUTE_V1_AUTH_SESSIONS_REVOKE, post(revoke_sessions))
        .route(ROUTE_V1_CONTROL_STATUS, get(control_status))
        .route(ROUTE_V1_CONTROL_ROUTE_SPLIT_STATUS, get(route_split_status))
        .route(
            ROUTE_V1_CONTROL_ROUTE_SPLIT_OVERRIDE,
            post(route_split_override).route_layer(middleware::from_fn_with_state(
                admin_state.clone(),
                admin_email_gate,
            )),
        )
        .route(
            ROUTE_V1_CONTROL_ROUTE_SPLIT_EVALUATE,
            post(route_split_evaluate),
        )
        .route(
            ROUTE_V1_CONTROL_RUNTIME_ROUTING_STATUS,
            get(runtime_routing_status),
        )
        .route(
            ROUTE_V1_CONTROL_RUNTIME_ROUTING_EVALUATE,
            post(runtime_routing_evaluate),
        )
        .route(
            ROUTE_V1_CONTROL_RUNTIME_ROUTING_OVERRIDE,
            post(runtime_routing_override).route_layer(middleware::from_fn_with_state(
                admin_state,
                admin_email_gate,
            )),
        )
        .route(ROUTE_V1_SYNC_TOKEN, post(sync_token))
        .route_layer(middleware::from_fn_with_state(
            workos_session_state,
            workos_session_gate,
        ))
        .route_layer(middleware::from_fn_with_state(
            authenticated_routes_state,
            auth_session_gate,
        ));

    Router::new()
        .route("/", get(web_shell_entry))
        .route("/compute", get(compute_page))
        .route("/compute/fragments/main", get(compute_main_fragment))
        .route("/compute/fragments/metrics", get(compute_metrics_fragment))
        .route("/compute/fragments/fleet", get(compute_fleet_fragment))
        .route(
            "/compute/providers/:worker_id/disable",
            post(web_compute_provider_disable),
        )
        .route("/stats", get(stats_page))
        .route("/stats/fragments/main", get(stats_main_fragment))
        .route("/stats/fragments/metrics", get(stats_metrics_fragment))
        .route("/stats/fragments/pools", get(stats_pools_fragment))
        .route("/feed", get(feed_page))
        .route("/feed/fragments/main", get(feed_main_fragment))
        .route("/feed/fragments/items", get(feed_items_fragment))
        .route("/feed/shout", post(web_feed_shout))
        .route(
            "/settings/profile/update",
            post(web_settings_profile_update),
        )
        .route(
            "/settings/profile/delete",
            post(web_settings_profile_delete),
        )
        .route(
            "/settings/integrations/resend/upsert",
            post(web_settings_resend_upsert),
        )
        .route(
            "/settings/integrations/resend/test-request",
            post(web_settings_resend_test),
        )
        .route(
            "/settings/integrations/resend/disconnect",
            post(web_settings_resend_disconnect),
        )
        .route(
            "/settings/integrations/google/connect",
            get(web_settings_google_connect),
        )
        .route(
            "/settings/integrations/google/disconnect",
            post(web_settings_google_disconnect),
        )
        .route("/l402/paywalls/web/create", post(web_l402_paywall_create))
        .route(
            "/l402/paywalls/web/:paywall_id/toggle",
            post(web_l402_paywall_toggle),
        )
        .route(
            "/l402/paywalls/web/:paywall_id/delete",
            post(web_l402_paywall_delete),
        )
        .route(
            "/admin/route-split/evaluate",
            post(web_admin_route_split_evaluate),
        )
        .route(
            "/admin/route-split/override",
            post(web_admin_route_split_override),
        )
        .route(
            "/admin/runtime-routing/evaluate",
            post(web_admin_runtime_routing_evaluate),
        )
        .route(
            "/admin/runtime-routing/override",
            post(web_admin_runtime_routing_override),
        )
        .route(
            "/admin/lightning-ops/query",
            post(web_admin_lightning_ops_query),
        )
        .route(
            "/admin/lightning-ops/mutation",
            post(web_admin_lightning_ops_mutation),
        )
        .route("/chat/new", post(web_chat_new_thread))
        .route(
            "/chat/fragments/thread/:thread_id",
            get(web_chat_thread_fragment),
        )
        .route("/chat/:thread_id/send", post(web_chat_send_message))
        .route("/healthz", get(health))
        .route("/readyz", get(readiness))
        .merge(web_auth_router)
        .merge(public_api_router)
        .merge(protected_api_router)
        .route(ROUTE_OPENAPI_JSON, get(openapi_spec))
        .route("/sw.js", get(static_service_worker))
        .route("/manifest.json", get(static_manifest))
        .route("/assets/*path", get(static_asset))
        .route("/*path", get(web_shell_entry))
        .with_state(state)
        .layer(middleware::from_fn_with_state(
            maintenance_state,
            maintenance_mode_gate,
        ))
        .layer(middleware::from_fn_with_state(
            compatibility_state,
            control_compatibility_gate,
        ))
        .layer(middleware::from_fn(api_non_http_behavior_gate))
        .layer(
            ServiceBuilder::new()
                .layer(SetRequestIdLayer::x_request_id(MakeRequestUuid))
                .layer(PropagateRequestIdLayer::x_request_id())
                .layer(TraceLayer::new_for_http()),
        )
}

impl RuntimeRevocationClient {
    fn from_config(config: &Config) -> Option<Self> {
        let base_url = config.runtime_sync_revoke_base_url.as_ref()?;
        let secret = config.runtime_signature_secret.as_ref()?;
        let revoke_path = config.runtime_sync_revoke_path.trim();
        if revoke_path.is_empty() {
            return None;
        }

        let normalized_path = if revoke_path.starts_with('/') {
            revoke_path.to_string()
        } else {
            format!("/{revoke_path}")
        };

        Some(Self {
            endpoint_url: format!("{}{}", base_url.trim_end_matches('/'), normalized_path),
            signature_secret: secret.clone(),
            signature_ttl_seconds: config.runtime_signature_ttl_seconds.max(30),
            http: reqwest::Client::new(),
        })
    }

    async fn revoke_sessions(
        &self,
        session_ids: Vec<String>,
        device_ids: Vec<String>,
        reason: SessionRevocationReason,
    ) -> Result<(), String> {
        if session_ids.is_empty() && device_ids.is_empty() {
            return Ok(());
        }

        let token = self
            .signature_token()
            .map_err(|error| format!("failed to sign runtime revocation token: {error}"))?;

        let response = self
            .http
            .post(&self.endpoint_url)
            .header("x-oa-runtime-signature", token)
            .json(&RuntimeRevocationRequest {
                session_ids,
                device_ids,
                reason: reason.as_str().to_string(),
            })
            .send()
            .await
            .map_err(|error| format!("runtime revocation request failed: {error}"))?;

        if response.status().is_success() {
            return Ok(());
        }

        let status = response.status();
        let body = response.text().await.unwrap_or_default();
        Err(format!("runtime revocation rejected ({status}): {body}"))
    }

    fn signature_token(&self) -> Result<String, anyhow::Error> {
        let now = Utc::now().timestamp().max(0) as u64;
        let payload = serde_json::json!({
            "iat": now,
            "exp": now + self.signature_ttl_seconds,
            "nonce": format!("revk_{}", uuid::Uuid::new_v4().simple()),
        });
        let payload_bytes = serde_json::to_vec(&payload)?;
        let payload_segment = URL_SAFE_NO_PAD.encode(payload_bytes);

        let mut mac = HmacSha256::new_from_slice(self.signature_secret.as_bytes())?;
        mac.update(payload_segment.as_bytes());
        let signature = mac.finalize().into_bytes();
        let signature_segment = URL_SAFE_NO_PAD.encode(signature);

        Ok(format!("v1.{payload_segment}.{signature_segment}"))
    }
}

async fn health(State(state): State<AppState>) -> Json<HealthResponse> {
    let uptime_seconds = match state.started_at.elapsed() {
        Ok(duration) => duration.as_secs(),
        Err(_) => 0,
    };

    Json(HealthResponse {
        status: "ok",
        service: SERVICE_NAME,
        version: env!("CARGO_PKG_VERSION"),
        uptime_seconds,
        auth_provider: state.auth.provider_name(),
    })
}

async fn readiness(State(state): State<AppState>) -> impl IntoResponse {
    let static_dir = state.config.static_dir.to_string_lossy().to_string();

    if state.config.static_dir.is_dir() {
        return (
            StatusCode::OK,
            Json(ReadinessResponse {
                status: "ready",
                static_dir,
            }),
        );
    }

    (
        StatusCode::SERVICE_UNAVAILABLE,
        Json(ReadinessResponse {
            status: "not_ready",
            static_dir,
        }),
    )
}

async fn auth_session_gate(
    State(state): State<AppState>,
    mut request: Request,
    next: Next,
) -> Response {
    match session_bundle_from_headers(&state, request.headers()).await {
        Ok(bundle) => {
            request.extensions_mut().insert(bundle);
            next.run(request).await
        }
        Err(response) => response.into_response(),
    }
}

async fn workos_session_gate(
    State(state): State<AppState>,
    request: Request,
    next: Next,
) -> Response {
    if state.auth.provider_name() != "workos" {
        return next.run(request).await;
    }

    let bundle = if let Some(existing) = request.extensions().get::<SessionBundle>() {
        existing.clone()
    } else {
        match session_bundle_from_headers(&state, request.headers()).await {
            Ok(bundle) => bundle,
            Err(response) => return response.into_response(),
        }
    };

    let workos_user_id = bundle.user.workos_user_id.trim();
    if workos_user_id.is_empty() {
        return unauthorized_error("WorkOS session required.").into_response();
    }

    if workos_user_id.starts_with("test_local_") && !state.config.auth_local_test_login_enabled {
        return unauthorized_error("WorkOS session required.").into_response();
    }

    next.run(request).await
}

async fn admin_email_gate(State(state): State<AppState>, request: Request, next: Next) -> Response {
    let bundle = if let Some(existing) = request.extensions().get::<SessionBundle>() {
        existing.clone()
    } else {
        match session_bundle_from_headers(&state, request.headers()).await {
            Ok(bundle) => bundle,
            Err(response) => return response.into_response(),
        }
    };

    if !is_admin_email(&bundle.user.email, &state.config.admin_emails) {
        return forbidden_error("Forbidden.").into_response();
    }

    next.run(request).await
}

async fn throttle_auth_email_gate(
    State(state): State<AppState>,
    request: Request,
    next: Next,
) -> Response {
    let key = format!("auth.email:{}", request_identity_key(request.headers()));
    match consume_throttle_token(
        &state.throttle_state,
        &key,
        THROTTLE_AUTH_EMAIL_LIMIT,
        THROTTLE_AUTH_EMAIL_WINDOW_SECONDS,
    )
    .await
    {
        Ok(()) => next.run(request).await,
        Err(retry_after_seconds) => error_response_with_status(
            StatusCode::TOO_MANY_REQUESTS,
            ApiErrorCode::RateLimited,
            format!("Too many requests. Retry in {retry_after_seconds}s."),
        )
        .into_response(),
    }
}

async fn throttle_login_email_gate(
    State(state): State<AppState>,
    request: Request,
    next: Next,
) -> Response {
    let key = format!("auth.web.email:{}", request_identity_key(request.headers()));
    match consume_throttle_token(
        &state.throttle_state,
        &key,
        THROTTLE_LOGIN_EMAIL_LIMIT,
        THROTTLE_LOGIN_EMAIL_WINDOW_SECONDS,
    )
    .await
    {
        Ok(()) => next.run(request).await,
        Err(retry_after_seconds) => error_response_with_status(
            StatusCode::TOO_MANY_REQUESTS,
            ApiErrorCode::RateLimited,
            format!("Too many requests. Retry in {retry_after_seconds}s."),
        )
        .into_response(),
    }
}

async fn throttle_login_verify_gate(
    State(state): State<AppState>,
    request: Request,
    next: Next,
) -> Response {
    let key = format!(
        "auth.web.verify:{}",
        request_identity_key(request.headers())
    );
    match consume_throttle_token(
        &state.throttle_state,
        &key,
        THROTTLE_LOGIN_VERIFY_LIMIT,
        THROTTLE_LOGIN_VERIFY_WINDOW_SECONDS,
    )
    .await
    {
        Ok(()) => next.run(request).await,
        Err(retry_after_seconds) => error_response_with_status(
            StatusCode::TOO_MANY_REQUESTS,
            ApiErrorCode::RateLimited,
            format!("Too many requests. Retry in {retry_after_seconds}s."),
        )
        .into_response(),
    }
}

async fn throttle_thread_message_gate(
    State(state): State<AppState>,
    request: Request,
    next: Next,
) -> Response {
    if request.method() != Method::POST {
        return next.run(request).await;
    }

    let key = format!(
        "runtime.thread.message:{}",
        request_identity_key(request.headers())
    );
    match consume_throttle_token(
        &state.throttle_state,
        &key,
        THROTTLE_THREAD_MESSAGE_LIMIT,
        THROTTLE_THREAD_MESSAGE_WINDOW_SECONDS,
    )
    .await
    {
        Ok(()) => next.run(request).await,
        Err(retry_after_seconds) => error_response_with_status(
            StatusCode::TOO_MANY_REQUESTS,
            ApiErrorCode::RateLimited,
            format!("Too many requests. Retry in {retry_after_seconds}s."),
        )
        .into_response(),
    }
}

async fn throttle_codex_control_request_gate(
    State(state): State<AppState>,
    request: Request,
    next: Next,
) -> Response {
    if request.method() != Method::POST {
        return next.run(request).await;
    }

    let key = format!(
        "runtime.codex.control.request:{}",
        request_identity_key(request.headers())
    );
    match consume_throttle_token(
        &state.throttle_state,
        &key,
        THROTTLE_CODEX_CONTROL_REQUEST_LIMIT,
        THROTTLE_CODEX_CONTROL_REQUEST_WINDOW_SECONDS,
    )
    .await
    {
        Ok(()) => next.run(request).await,
        Err(retry_after_seconds) => error_response_with_status(
            StatusCode::TOO_MANY_REQUESTS,
            ApiErrorCode::RateLimited,
            format!("Too many requests. Retry in {retry_after_seconds}s."),
        )
        .into_response(),
    }
}

async fn runtime_internal_request_gate(
    State(state): State<AppState>,
    request: Request,
    next: Next,
) -> Response {
    let (parts, body) = request.into_parts();
    let body_bytes = match to_bytes(body, RUNTIME_INTERNAL_MAX_BODY_BYTES).await {
        Ok(bytes) => bytes,
        Err(_) => {
            return error_response_with_status(
                StatusCode::UNAUTHORIZED,
                ApiErrorCode::Unauthorized,
                "Invalid runtime internal request body.".to_string(),
            )
            .into_response();
        }
    };

    if let Err(response) =
        verify_runtime_internal_headers(&state, &parts.headers, &body_bytes).await
    {
        let request_id = request_id(&parts.headers);
        state.observability.audit(
            AuditEvent::new("runtime.internal.auth.rejected", request_id.clone())
                .with_attribute("path", parts.uri.path().to_string())
                .with_attribute("error_code", response.1.0.error.code.to_string()),
        );
        state
            .observability
            .increment_counter("runtime.internal.auth.rejected", &request_id);
        return response.into_response();
    }

    let request = Request::from_parts(parts, Body::from(body_bytes));
    next.run(request).await
}

async fn verify_runtime_internal_headers(
    state: &AppState,
    headers: &HeaderMap,
    body: &[u8],
) -> Result<(), (StatusCode, Json<ApiErrorResponse>)> {
    let secret = state
        .config
        .runtime_internal_shared_secret
        .as_ref()
        .filter(|value| !value.trim().is_empty())
        .ok_or_else(|| {
            runtime_internal_error(
                StatusCode::INTERNAL_SERVER_ERROR,
                "internal_auth_misconfigured",
                "runtime internal auth misconfigured",
            )
        })?;

    let provided_key_id =
        header_string(headers, RUNTIME_INTERNAL_KEY_ID_HEADER).unwrap_or_default();
    if provided_key_id.is_empty() || provided_key_id != state.config.runtime_internal_key_id {
        return Err(runtime_internal_error(
            StatusCode::UNAUTHORIZED,
            "invalid_key_id",
            "invalid key id",
        ));
    }

    let timestamp = header_string(headers, RUNTIME_INTERNAL_TIMESTAMP_HEADER).unwrap_or_default();
    let nonce = header_string(headers, RUNTIME_INTERNAL_NONCE_HEADER).unwrap_or_default();
    let provided_body_hash =
        header_string(headers, RUNTIME_INTERNAL_BODY_HASH_HEADER).unwrap_or_default();
    let provided_signature =
        header_string(headers, RUNTIME_INTERNAL_SIGNATURE_HEADER).unwrap_or_default();

    if timestamp.is_empty()
        || nonce.is_empty()
        || provided_body_hash.is_empty()
        || provided_signature.is_empty()
    {
        return Err(runtime_internal_error(
            StatusCode::UNAUTHORIZED,
            "missing_auth_headers",
            "missing auth headers",
        ));
    }

    let timestamp_epoch = timestamp.parse::<i64>().map_err(|_| {
        runtime_internal_error(
            StatusCode::UNAUTHORIZED,
            "invalid_timestamp",
            "invalid timestamp",
        )
    })?;

    let now_epoch = Utc::now().timestamp();
    let ttl_seconds = state.config.runtime_internal_signature_ttl_seconds as i64;
    if (now_epoch - timestamp_epoch).abs() > ttl_seconds {
        return Err(runtime_internal_error(
            StatusCode::UNAUTHORIZED,
            "signature_expired",
            "signature expired",
        ));
    }

    let computed_body_hash = sha256_hex(body);
    if computed_body_hash != provided_body_hash {
        return Err(runtime_internal_error(
            StatusCode::UNAUTHORIZED,
            "body_hash_mismatch",
            "body hash mismatch",
        ));
    }

    let payload = format!("{timestamp}\n{nonce}\n{computed_body_hash}");
    let mut mac = HmacSha256::new_from_slice(secret.as_bytes()).map_err(|_| {
        runtime_internal_error(
            StatusCode::INTERNAL_SERVER_ERROR,
            "internal_auth_misconfigured",
            "runtime internal auth misconfigured",
        )
    })?;
    mac.update(payload.as_bytes());
    let expected_signature = sha256_bytes_hex(&mac.finalize().into_bytes());
    if expected_signature != provided_signature {
        return Err(runtime_internal_error(
            StatusCode::UNAUTHORIZED,
            "invalid_signature",
            "invalid signature",
        ));
    }

    let replay_key = format!("{provided_key_id}:{nonce}");
    let expires_at = timestamp_epoch + ttl_seconds + RUNTIME_INTERNAL_NONCE_GRACE_SECONDS;
    let mut entries = state.runtime_internal_nonces.entries.lock().await;
    entries.retain(|_, expiry| *expiry > now_epoch);
    if entries.contains_key(&replay_key) {
        return Err(runtime_internal_error(
            StatusCode::UNAUTHORIZED,
            "nonce_replay",
            "nonce replay detected",
        ));
    }
    entries.insert(replay_key, expires_at);

    Ok(())
}

async fn consume_throttle_token(
    throttle_state: &ThrottleState,
    bucket_key: &str,
    max_requests: usize,
    window_seconds: i64,
) -> Result<(), i64> {
    let now_epoch = Utc::now().timestamp();
    let window_start = now_epoch - window_seconds;

    let mut buckets = throttle_state.buckets.lock().await;
    let bucket = buckets.entry(bucket_key.to_string()).or_default();

    while let Some(oldest) = bucket.front() {
        if *oldest < window_start {
            let _ = bucket.pop_front();
        } else {
            break;
        }
    }

    if bucket.len() >= max_requests {
        let retry_after = bucket
            .front()
            .map(|oldest| ((*oldest + window_seconds) - now_epoch).max(1))
            .unwrap_or(1);
        return Err(retry_after);
    }

    bucket.push_back(now_epoch);
    Ok(())
}

async fn session_bundle_from_headers(
    state: &AppState,
    headers: &HeaderMap,
) -> Result<SessionBundle, (StatusCode, Json<ApiErrorResponse>)> {
    let access_token =
        access_token_from_headers(headers).ok_or_else(|| unauthorized_error("Unauthenticated."))?;
    state
        .auth
        .session_or_pat_from_access_token(&access_token)
        .await
        .map_err(map_auth_error)
}

fn request_identity_key(headers: &HeaderMap) -> String {
    if let Some(access_token) = bearer_token(headers) {
        return format!("token:{access_token}");
    }

    if let Some(value) = header_string(headers, HEADER_X_FORWARDED_FOR) {
        let first_ip = value.split(',').next().unwrap_or_default().trim();
        if !first_ip.is_empty() {
            return format!("ip:{first_ip}");
        }
    }

    if let Some(value) = header_string(headers, HEADER_X_REAL_IP) {
        let ip = value.trim();
        if !ip.is_empty() {
            return format!("ip:{ip}");
        }
    }

    "ip:unknown".to_string()
}

fn is_api_request_path(path: &str) -> bool {
    path == "/api" || path.starts_with("/api/")
}

fn apply_api_non_http_headers(headers: &mut HeaderMap, origin: Option<&HeaderValue>) {
    let allow_origin = origin
        .cloned()
        .unwrap_or_else(|| HeaderValue::from_static("*"));
    headers.insert("access-control-allow-origin", allow_origin);
    headers.insert(
        "access-control-allow-methods",
        HeaderValue::from_static(CORS_ALLOW_METHODS),
    );
    headers.insert(
        "access-control-allow-headers",
        HeaderValue::from_static(CORS_ALLOW_HEADERS),
    );
    headers.insert(
        "access-control-max-age",
        HeaderValue::from_static(CORS_MAX_AGE_SECONDS),
    );
    headers.insert("vary", HeaderValue::from_static(CORS_VARY_HEADERS));
}

async fn api_non_http_behavior_gate(request: Request, next: Next) -> Response {
    let path = request.uri().path().to_string();
    let is_api = is_api_request_path(&path);
    let origin = request.headers().get("origin").cloned();

    if is_api && request.method() == Method::OPTIONS {
        let mut response = StatusCode::NO_CONTENT.into_response();
        apply_api_non_http_headers(response.headers_mut(), origin.as_ref());
        response
            .headers_mut()
            .insert(CACHE_CONTROL, HeaderValue::from_static(CACHE_API_NO_STORE));
        return response;
    }

    let mut response = next.run(request).await;
    if is_api {
        apply_api_non_http_headers(response.headers_mut(), origin.as_ref());
        if !response.headers().contains_key(CACHE_CONTROL) {
            response
                .headers_mut()
                .insert(CACHE_CONTROL, HeaderValue::from_static(CACHE_API_NO_STORE));
        }
    }
    response
}

fn is_admin_email(email: &str, admin_emails: &[String]) -> bool {
    let normalized_email = email.trim().to_lowercase();
    if normalized_email.is_empty() {
        return false;
    }

    admin_emails.iter().any(|configured| {
        let candidate = configured.trim().to_lowercase();
        !candidate.is_empty() && candidate == normalized_email
    })
}

fn sha256_hex(bytes: &[u8]) -> String {
    let digest = Sha256::digest(bytes);
    sha256_bytes_hex(&digest)
}

fn sha256_bytes_hex(bytes: &[u8]) -> String {
    let mut output = String::with_capacity(bytes.len() * 2);
    for byte in bytes {
        use std::fmt::Write as _;
        let _ = write!(&mut output, "{byte:02x}");
    }
    output
}

async fn maintenance_mode_gate(
    State(state): State<AppState>,
    request: Request,
    next: Next,
) -> Response {
    if !state.config.maintenance_mode_enabled {
        return next.run(request).await;
    }

    let path = request.uri().path().to_string();
    if maintenance_path_is_allowed(&path, &state.config.maintenance_allowed_paths) {
        return next.run(request).await;
    }

    if let Some(bypass_token) = state.config.maintenance_bypass_token.as_ref() {
        if let Some(candidate) =
            query_param_value(request.uri().query(), MAINTENANCE_BYPASS_QUERY_PARAM)
        {
            if candidate == *bypass_token {
                let now = Utc::now().timestamp().max(0) as u64;
                let expires_at = now + state.config.maintenance_bypass_cookie_ttl_seconds;
                if let Some(cookie_payload) =
                    maintenance_bypass_cookie_payload(bypass_token, expires_at)
                {
                    let mut response =
                        Redirect::temporary(&maintenance_redirect_location(request.uri()))
                            .into_response();
                    if let Ok(value) = HeaderValue::from_str(&maintenance_bypass_cookie(
                        &state.config.maintenance_bypass_cookie_name,
                        &cookie_payload,
                        state.config.maintenance_bypass_cookie_ttl_seconds,
                    )) {
                        response.headers_mut().insert(SET_COOKIE, value);
                    }
                    return response;
                }
            }
        }

        if let Some(cookie) = extract_cookie_value(
            request.headers(),
            &state.config.maintenance_bypass_cookie_name,
        ) {
            if maintenance_cookie_is_valid(&cookie, bypass_token) {
                return next.run(request).await;
            }
        }
    }

    maintenance_response()
}

async fn control_compatibility_gate(
    State(state): State<AppState>,
    request: Request,
    next: Next,
) -> Response {
    let path = request.uri().path().to_string();
    let Some(surface) = compatibility_surface_for_path(&path) else {
        return next.run(request).await;
    };
    if !state.config.compat_control_enforced {
        return next.run(request).await;
    }

    let header_snapshot = request.headers().clone();
    let request_id = request_id(&header_snapshot);

    match validate_control_compatibility(surface, &state.config, &header_snapshot) {
        Ok(()) => next.run(request).await,
        Err(failure) => {
            let client_name = header_string(&header_snapshot, "x-client")
                .unwrap_or_else(|| "unknown".to_string());
            let client_build_id = header_string(&header_snapshot, HEADER_OA_CLIENT_BUILD_ID)
                .unwrap_or_else(|| "missing".to_string());

            state
                .observability
                .increment_counter("compatibility.rejected.control", &request_id);
            state.observability.increment_counter(
                &format!("compatibility.rejected.control.{}", failure.code),
                &request_id,
            );
            state.observability.audit(
                AuditEvent::new("compatibility.rejected", request_id.clone())
                    .with_outcome("rejected")
                    .with_attribute("surface", compatibility_surface_label(surface))
                    .with_attribute("path", path)
                    .with_attribute("client", client_name)
                    .with_attribute("client_build_id", client_build_id)
                    .with_attribute("code", failure.code.clone())
                    .with_attribute("protocol_version", failure.protocol_version.clone()),
            );

            compatibility_failure_response(failure)
        }
    }
}

fn compatibility_surface_for_path(path: &str) -> Option<CompatibilitySurface> {
    if path.starts_with("/api/v1/control/") {
        return Some(CompatibilitySurface::ControlApi);
    }

    if path == ROUTE_V1_SYNC_TOKEN {
        return Some(CompatibilitySurface::ControlApi);
    }

    if path == ROUTE_LEGACY_CHAT_STREAM || is_legacy_chats_stream_path(path) {
        return Some(CompatibilitySurface::ControlApi);
    }

    None
}

fn is_legacy_chats_stream_path(path: &str) -> bool {
    let Some(remainder) = path.strip_prefix("/api/chats/") else {
        return false;
    };
    let Some(conversation_id) = remainder.strip_suffix("/stream") else {
        return false;
    };

    !conversation_id.is_empty() && !conversation_id.contains('/')
}

fn compatibility_surface_label(surface: CompatibilitySurface) -> &'static str {
    match surface {
        CompatibilitySurface::ControlApi => "control_api",
        CompatibilitySurface::KhalaWebSocket => "khala_websocket",
    }
}

fn validate_control_compatibility(
    surface: CompatibilitySurface,
    config: &Config,
    headers: &HeaderMap,
) -> Result<(), CompatibilityFailure> {
    let schema_version = header_string(headers, HEADER_OA_SCHEMA_VERSION)
        .and_then(|value| value.parse::<u32>().ok())
        .unwrap_or(0);

    let handshake = ClientCompatibilityHandshake {
        client_build_id: header_string(headers, HEADER_OA_CLIENT_BUILD_ID).unwrap_or_default(),
        protocol_version: header_string(headers, HEADER_OA_PROTOCOL_VERSION).unwrap_or_default(),
        schema_version,
    };

    let window = CompatibilityWindow {
        protocol_version: config.compat_control_protocol_version.clone(),
        min_client_build_id: config.compat_control_min_client_build_id.clone(),
        max_client_build_id: config.compat_control_max_client_build_id.clone(),
        min_schema_version: config.compat_control_min_schema_version,
        max_schema_version: config.compat_control_max_schema_version,
    };

    negotiate_compatibility(surface, &handshake, &window)
}

fn compatibility_failure_response(failure: CompatibilityFailure) -> Response {
    let code = failure.code.clone();
    let protocol_version = failure.protocol_version.clone();
    let min_client_build_id = failure.min_client_build_id.clone();
    let max_client_build_id = failure.max_client_build_id.clone();
    let min_schema_version = failure.min_schema_version;
    let max_schema_version = failure.max_schema_version;
    let upgrade_required = failure.upgrade_required;
    let message = failure.message.clone();
    let mut response = (
        StatusCode::UPGRADE_REQUIRED,
        Json(CompatibilityErrorResponse {
            message: message.clone(),
            error: CompatibilityErrorDetail {
                code: failure.code.clone(),
                message,
            },
            compatibility: failure,
        }),
    )
        .into_response();

    response
        .headers_mut()
        .insert(CACHE_CONTROL, HeaderValue::from_static("no-store"));
    response.headers_mut().insert(
        HEADER_OA_COMPAT_UPGRADE_REQUIRED,
        HeaderValue::from_static(if upgrade_required { "true" } else { "false" }),
    );
    if let Ok(value) = HeaderValue::from_str(&code) {
        response.headers_mut().insert(HEADER_OA_COMPAT_CODE, value);
    }
    if let Ok(value) = HeaderValue::from_str(&protocol_version) {
        response
            .headers_mut()
            .insert(HEADER_OA_COMPAT_PROTOCOL, value);
    }
    if let Ok(value) = HeaderValue::from_str(&min_client_build_id) {
        response
            .headers_mut()
            .insert(HEADER_OA_COMPAT_MIN_BUILD, value);
    }
    if let Some(max_client_build_id) = max_client_build_id
        && let Ok(value) = HeaderValue::from_str(&max_client_build_id)
    {
        response
            .headers_mut()
            .insert(HEADER_OA_COMPAT_MAX_BUILD, value);
    }
    if let Ok(value) = HeaderValue::from_str(&min_schema_version.to_string()) {
        response
            .headers_mut()
            .insert(HEADER_OA_COMPAT_MIN_SCHEMA, value);
    }
    if let Ok(value) = HeaderValue::from_str(&max_schema_version.to_string()) {
        response
            .headers_mut()
            .insert(HEADER_OA_COMPAT_MAX_SCHEMA, value);
    }

    response
}

async fn openapi_spec(
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let document = openapi_document();
    let encoded = serde_json::to_vec(&document).map_err(|_| {
        error_response_with_status(
            StatusCode::INTERNAL_SERVER_ERROR,
            ApiErrorCode::InternalError,
            "Failed to generate OpenAPI document.".to_string(),
        )
    })?;
    let etag = static_etag(&encoded);

    if if_none_match_matches(Some(&headers), &etag) {
        let mut response = Response::new(Body::empty());
        *response.status_mut() = StatusCode::NOT_MODIFIED;
        response
            .headers_mut()
            .insert(CACHE_CONTROL, HeaderValue::from_static(CACHE_MANIFEST));
        response.headers_mut().insert(
            ETAG,
            HeaderValue::from_str(&etag).map_err(|_| {
                error_response_with_status(
                    StatusCode::INTERNAL_SERVER_ERROR,
                    ApiErrorCode::InternalError,
                    "Failed to build OpenAPI etag header.".to_string(),
                )
            })?,
        );
        return Ok(response);
    }

    let mut response = Response::new(Body::from(encoded));
    *response.status_mut() = StatusCode::OK;
    response
        .headers_mut()
        .insert(CONTENT_TYPE, HeaderValue::from_static("application/json"));
    response
        .headers_mut()
        .insert(CACHE_CONTROL, HeaderValue::from_static(CACHE_MANIFEST));
    response.headers_mut().insert(
        ETAG,
        HeaderValue::from_str(&etag).map_err(|_| {
            error_response_with_status(
                StatusCode::INTERNAL_SERVER_ERROR,
                ApiErrorCode::InternalError,
                "Failed to build OpenAPI etag header.".to_string(),
            )
        })?,
    );

    Ok(response)
}

async fn smoke_stream(
    State(state): State<AppState>,
    headers: HeaderMap,
) -> Result<Response, (StatusCode, Json<ApiErrorResponse>)> {
    let expected_secret = state
        .config
        .smoke_stream_secret
        .as_deref()
        .unwrap_or_default()
        .trim()
        .to_string();
    let provided_secret = header_string(&headers, HEADER_OA_SMOKE_SECRET).unwrap_or_default();
    if expected_secret.is_empty()
        || provided_secret.is_empty()
        || !constant_time_eq(expected_secret.as_bytes(), provided_secret.as_bytes())
    {
        return Err(unauthorized_error("Unauthenticated."));
    }

    let mut response = ok_data(serde_json::json!({
        "status": "ok",
        "stream_protocol": "khala_ws",
        "delivery": {
            "transport": "khala_ws",
            "topic": "runtime.codex_worker_events",
            "scope": "runtime.codex_worker_events",
            "syncTokenRoute": ROUTE_SYNC_TOKEN,
            "sseEnabled": false,
        },
        "event_contract": {
            "chat": ["turn.start", "turn.finish", "turn.error", "turn.tool"],
            "worker": ["worker.event", "worker.response", "worker.stopped"],
        },
    }))
    .into_response();
    response
        .headers_mut()
        .insert(HEADER_OA_SMOKE, HeaderValue::from_static("1"));
    response
        .headers_mut()
        .insert(CACHE_CONTROL, HeaderValue::from_static("no-store"));
    response
        .headers_mut()
        .insert(CONTENT_TYPE, HeaderValue::from_static("application/json"));

    Ok(response)
}

async fn static_manifest(
    State(state): State<AppState>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let manifest_path = state.config.static_dir.join("manifest.json");
    let response = build_static_response(&manifest_path, CACHE_MANIFEST, Some(&headers))
        .await
        .map_err(map_static_error)?;
    Ok(response)
}

async fn static_service_worker(
    State(state): State<AppState>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let service_worker_path = state.config.static_dir.join("sw.js");
    let response = build_static_response(&service_worker_path, CACHE_MANIFEST, Some(&headers))
        .await
        .map_err(map_static_error)?;
    Ok(response)
}

async fn static_asset(
    State(state): State<AppState>,
    Path(path): Path<String>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let relative_path = normalize_static_path(&path)
        .ok_or_else(|| static_not_found(format!("Asset '{}' was not found.", path)))?;

    let static_root = state.config.static_dir.as_path();
    let preferred = static_root.join("assets").join(&relative_path);
    let fallback = static_root.join(&relative_path);

    let asset_path = if preferred.is_file() {
        preferred
    } else if fallback.is_file() {
        fallback
    } else {
        return Err(static_not_found(format!(
            "Asset '{}' was not found.",
            relative_path
        )));
    };

    let cache_control = if is_hashed_asset_path(&relative_path) {
        CACHE_IMMUTABLE_ONE_YEAR
    } else {
        CACHE_SHORT_LIVED
    };

    let response = build_static_response(&asset_path, cache_control, Some(&headers))
        .await
        .map_err(map_static_error)?;
    Ok(response)
}

async fn build_static_response(
    file_path: &FsPath,
    cache_control: &'static str,
    request_headers: Option<&HeaderMap>,
) -> Result<axum::response::Response, StaticResponseError> {
    let (served_path, content_encoding) = resolve_static_variant_path(file_path, request_headers);
    let bytes = tokio::fs::read(&served_path).await.map_err(|source| {
        if source.kind() == std::io::ErrorKind::NotFound {
            StaticResponseError::NotFound(format!(
                "Static file '{}' was not found.",
                served_path.display()
            ))
        } else {
            StaticResponseError::Io(source)
        }
    })?;
    let etag = static_etag(&bytes);

    if if_none_match_matches(request_headers, &etag) {
        let mut response = axum::response::Response::new(Body::empty());
        *response.status_mut() = StatusCode::NOT_MODIFIED;
        response
            .headers_mut()
            .insert(CACHE_CONTROL, HeaderValue::from_static(cache_control));
        response
            .headers_mut()
            .insert(VARY, HeaderValue::from_static("Accept-Encoding"));
        if let Some(content_encoding) = content_encoding {
            response
                .headers_mut()
                .insert(CONTENT_ENCODING, HeaderValue::from_static(content_encoding));
        }
        response.headers_mut().insert(
            ETAG,
            HeaderValue::from_str(&etag)
                .map_err(|_| StaticResponseError::InvalidHeader(etag.clone()))?,
        );
        apply_static_security_headers(response.headers_mut());
        return Ok(response);
    }

    let content_type = mime_guess::from_path(file_path).first_or_octet_stream();
    let mut response = axum::response::Response::new(Body::from(bytes));
    *response.status_mut() = StatusCode::OK;
    response.headers_mut().insert(
        CONTENT_TYPE,
        HeaderValue::from_str(content_type.as_ref())
            .map_err(|_| StaticResponseError::InvalidHeader(content_type.to_string()))?,
    );
    response
        .headers_mut()
        .insert(CACHE_CONTROL, HeaderValue::from_static(cache_control));
    response
        .headers_mut()
        .insert(VARY, HeaderValue::from_static("Accept-Encoding"));
    if let Some(content_encoding) = content_encoding {
        response
            .headers_mut()
            .insert(CONTENT_ENCODING, HeaderValue::from_static(content_encoding));
    }
    response.headers_mut().insert(
        ETAG,
        HeaderValue::from_str(&etag).map_err(|_| StaticResponseError::InvalidHeader(etag))?,
    );
    apply_static_security_headers(response.headers_mut());

    Ok(response)
}

fn resolve_static_variant_path(
    file_path: &FsPath,
    request_headers: Option<&HeaderMap>,
) -> (std::path::PathBuf, Option<&'static str>) {
    if accepts_static_encoding(request_headers, "br") {
        let mut compressed = file_path.as_os_str().to_os_string();
        compressed.push(".br");
        let compressed_path = std::path::PathBuf::from(compressed);
        if compressed_path.is_file() {
            return (compressed_path, Some("br"));
        }
    }

    if accepts_static_encoding(request_headers, "gzip") {
        let mut compressed = file_path.as_os_str().to_os_string();
        compressed.push(".gz");
        let compressed_path = std::path::PathBuf::from(compressed);
        if compressed_path.is_file() {
            return (compressed_path, Some("gzip"));
        }
    }

    (file_path.to_path_buf(), None)
}

fn accepts_static_encoding(request_headers: Option<&HeaderMap>, encoding: &str) -> bool {
    let Some(header_value) = request_headers
        .and_then(|headers| headers.get(ACCEPT_ENCODING))
        .and_then(|value| value.to_str().ok())
    else {
        return false;
    };

    for token in header_value.split(',') {
        let mut parts = token.trim().split(';');
        let Some(name) = parts.next().map(|value| value.trim().to_ascii_lowercase()) else {
            continue;
        };
        if name != encoding && name != "*" {
            continue;
        }

        let mut quality = 1.0f32;
        for part in parts {
            let part = part.trim();
            if let Some(value) = part.strip_prefix("q=") {
                quality = value.trim().parse::<f32>().unwrap_or(0.0);
            }
        }

        if quality > 0.0 {
            return true;
        }
    }

    false
}

fn static_etag(bytes: &[u8]) -> String {
    format!("\"{}\"", sha256_hex(bytes))
}

fn if_none_match_matches(request_headers: Option<&HeaderMap>, etag: &str) -> bool {
    let Some(header_value) = request_headers
        .and_then(|headers| headers.get(IF_NONE_MATCH))
        .and_then(|value| value.to_str().ok())
    else {
        return false;
    };

    let expected = normalize_etag_token(etag);
    for candidate in header_value.split(',') {
        let normalized = normalize_etag_token(candidate);
        if normalized == "*" || normalized == expected {
            return true;
        }
    }

    false
}

fn normalize_etag_token(value: &str) -> String {
    let trimmed = value.trim();
    let without_weak = trimmed.strip_prefix("W/").unwrap_or(trimmed).trim();
    without_weak.to_string()
}

#[derive(Debug, thiserror::Error)]
enum StaticResponseError {
    #[error("{0}")]
    NotFound(String),
    #[error("static file read failed: {0}")]
    Io(#[from] std::io::Error),
    #[error("invalid header value '{0}'")]
    InvalidHeader(String),
}

fn map_static_error(error: StaticResponseError) -> (StatusCode, Json<ApiErrorResponse>) {
    match error {
        StaticResponseError::NotFound(message) => static_not_found(message),
        StaticResponseError::Io(_) | StaticResponseError::InvalidHeader(_) => {
            error_response_with_status(
                StatusCode::INTERNAL_SERVER_ERROR,
                ApiErrorCode::StaticAssetError,
                "Failed to serve static asset.".to_string(),
            )
        }
    }
}

fn static_not_found(message: String) -> (StatusCode, Json<ApiErrorResponse>) {
    not_found_error(message)
}

fn normalize_static_path(path: &str) -> Option<String> {
    let trimmed = path.trim().trim_start_matches('/');
    if trimmed.is_empty() {
        return None;
    }

    let mut normalized_parts = Vec::new();
    for part in trimmed.split('/') {
        let segment = part.trim();
        if segment.is_empty() || segment == "." || segment == ".." {
            return None;
        }
        normalized_parts.push(segment);
    }

    Some(normalized_parts.join("/"))
}

fn is_hashed_asset_path(path: &str) -> bool {
    let Some(file_name) = FsPath::new(path)
        .file_name()
        .and_then(|value| value.to_str())
    else {
        return false;
    };

    let Some((stem, _ext)) = file_name.rsplit_once('.') else {
        return false;
    };

    let Some((_, hash_part)) = stem.rsplit_once('-') else {
        return false;
    };

    hash_part.len() >= 8 && hash_part.chars().all(|char| char.is_ascii_alphanumeric())
}

async fn web_chat_new_thread(State(state): State<AppState>, headers: HeaderMap) -> Response {
    let htmx = classify_htmx_request(&headers);
    let htmx_fragment_enabled =
        state.route_split.htmx_mode_for_path("/chat").await.mode == HtmxModeTarget::Fragment;
    let is_htmx = htmx.is_hx_request && htmx_fragment_enabled;
    let session = match session_bundle_from_headers(&state, &headers).await {
        Ok(session) => session,
        Err(_) => {
            if is_htmx {
                return htmx_redirect_response("/login");
            }
            return Redirect::temporary("/login").into_response();
        }
    };

    let thread_id = format!("thread_{}", Uuid::new_v4().simple());
    match state
        .codex_thread_store
        .create_thread_for_user(&session.user.id, &session.session.active_org_id, &thread_id)
        .await
    {
        Ok(thread) => {
            let location = format!("/chat/{}?status=thread-created", thread.thread_id);
            if is_htmx {
                match chat_views_for_bundle(&state, &session, Some(thread.thread_id.clone())).await
                {
                    Ok(views) => {
                        let session_view = session_view_from_bundle(&session);
                        chat_thread_select_fragment_response(
                            Some(&session_view),
                            Some("thread-created"),
                            &views.threads,
                            views.active_thread_id.as_deref(),
                            &views.messages,
                            Some(&format!("/chat/{}", thread.thread_id)),
                        )
                    }
                    Err(_) => htmx_notice_response(
                        "chat-status",
                        "thread-create-failed",
                        true,
                        StatusCode::UNPROCESSABLE_ENTITY,
                    ),
                }
            } else {
                Redirect::temporary(&location).into_response()
            }
        }
        Err(_) => {
            if is_htmx {
                htmx_notice_response(
                    "chat-status",
                    "thread-create-failed",
                    true,
                    StatusCode::UNPROCESSABLE_ENTITY,
                )
            } else {
                Redirect::temporary("/chat?status=thread-create-failed").into_response()
            }
        }
    }
}

async fn web_chat_thread_fragment(
    State(state): State<AppState>,
    Path(thread_id): Path<String>,
    headers: HeaderMap,
) -> Response {
    let htmx = classify_htmx_request(&headers);
    let htmx_fragment_enabled =
        state.route_split.htmx_mode_for_path("/chat").await.mode == HtmxModeTarget::Fragment;
    let is_htmx = htmx.is_hx_request && htmx_fragment_enabled;
    let normalized_thread_id = thread_id.trim().to_string();
    if !is_htmx {
        let location = if normalized_thread_id.is_empty() {
            "/chat".to_string()
        } else {
            format!("/chat/{normalized_thread_id}")
        };
        return Redirect::temporary(&location).into_response();
    }
    let session_bundle = match session_bundle_from_headers(&state, &headers).await {
        Ok(session) => session,
        Err(_) => return htmx_redirect_response("/login"),
    };
    if normalized_thread_id.is_empty() {
        return htmx_notice_response(
            "chat-status",
            "message-send-failed",
            true,
            StatusCode::UNPROCESSABLE_ENTITY,
        );
    }

    let views =
        match chat_views_for_bundle(&state, &session_bundle, Some(normalized_thread_id)).await {
            Ok(views) => views,
            Err(_) => {
                return htmx_notice_response(
                    "chat-status",
                    "message-send-failed",
                    true,
                    StatusCode::UNPROCESSABLE_ENTITY,
                );
            }
        };
    let session_view = session_view_from_bundle(&session_bundle);
    let push_url = views
        .active_thread_id
        .as_deref()
        .map(|thread_id| format!("/chat/{thread_id}"));
    chat_thread_select_fragment_response(
        Some(&session_view),
        None,
        &views.threads,
        views.active_thread_id.as_deref(),
        &views.messages,
        push_url.as_deref(),
    )
}

async fn web_chat_send_message(
    State(state): State<AppState>,
    Path(thread_id): Path<String>,
    headers: HeaderMap,
    Form(payload): Form<WebChatSendForm>,
) -> Response {
    let htmx = classify_htmx_request(&headers);
    let htmx_fragment_enabled =
        state.route_split.htmx_mode_for_path("/chat").await.mode == HtmxModeTarget::Fragment;
    let is_htmx = htmx.is_hx_request && htmx_fragment_enabled;
    let session = match session_bundle_from_headers(&state, &headers).await {
        Ok(session) => session,
        Err(_) => {
            if is_htmx {
                return htmx_redirect_response("/login");
            }
            return Redirect::temporary("/login").into_response();
        }
    };

    let normalized_thread_id = thread_id.trim().to_string();
    if normalized_thread_id.is_empty() {
        if is_htmx {
            return htmx_notice_response(
                "chat-status",
                "message-send-failed",
                true,
                StatusCode::UNPROCESSABLE_ENTITY,
            );
        }
        return Redirect::temporary("/chat?status=message-send-failed").into_response();
    }

    let text = payload.text.trim().to_string();
    if text.is_empty() {
        if is_htmx {
            return htmx_notice_response(
                "chat-status",
                "empty-body",
                true,
                StatusCode::UNPROCESSABLE_ENTITY,
            );
        }
        return Redirect::temporary(&format!("/chat/{normalized_thread_id}?status=empty-body"))
            .into_response();
    }
    if text.chars().count() > 20_000 {
        if is_htmx {
            return htmx_notice_response(
                "chat-status",
                "message-send-failed",
                true,
                StatusCode::UNPROCESSABLE_ENTITY,
            );
        }
        return Redirect::temporary(&format!(
            "/chat/{normalized_thread_id}?status=message-send-failed"
        ))
        .into_response();
    }

    match state
        .codex_thread_store
        .append_user_message(
            &session.user.id,
            &session.session.active_org_id,
            &normalized_thread_id,
            text,
        )
        .await
    {
        Ok(_) => {
            let location = format!("/chat/{normalized_thread_id}?status=message-sent");
            if is_htmx {
                let mut response =
                    htmx_notice_response("chat-status", "message-sent", false, StatusCode::OK);
                htmx_set_trigger_header(&mut response, "chat-message-sent");
                response
            } else {
                Redirect::temporary(&location).into_response()
            }
        }
        Err(_) => {
            if is_htmx {
                htmx_notice_response(
                    "chat-status",
                    "message-send-failed",
                    true,
                    StatusCode::UNPROCESSABLE_ENTITY,
                )
            } else {
                Redirect::temporary(&format!(
                    "/chat/{normalized_thread_id}?status=message-send-failed"
                ))
                .into_response()
            }
        }
    }
}

async fn web_feed_shout(
    State(state): State<AppState>,
    headers: HeaderMap,
    Form(payload): Form<WebShoutForm>,
) -> Response {
    let htmx = classify_htmx_request(&headers);
    let htmx_fragment_enabled =
        state.route_split.htmx_mode_for_path("/feed").await.mode == HtmxModeTarget::Fragment;
    let is_htmx = htmx.is_hx_request && htmx_fragment_enabled;
    let session = match session_bundle_from_headers(&state, &headers).await {
        Ok(session) => session,
        Err(_) => {
            if is_htmx {
                return htmx_redirect_response("/login");
            }
            return Redirect::temporary("/login").into_response();
        }
    };

    let body = payload.body.trim().to_string();
    if body.is_empty() {
        if is_htmx {
            return htmx_notice_response(
                "feed-status",
                "empty-body",
                true,
                StatusCode::UNPROCESSABLE_ENTITY,
            );
        }
        return Redirect::temporary("/feed?status=empty-body").into_response();
    }
    if body.chars().count() > 2000 {
        if is_htmx {
            return htmx_notice_response(
                "feed-status",
                "shout-post-failed",
                true,
                StatusCode::UNPROCESSABLE_ENTITY,
            );
        }
        return Redirect::temporary("/feed?status=shout-post-failed").into_response();
    }

    let zone = match normalize_shout_zone(payload.zone.as_deref(), "zone") {
        Ok(zone) => zone,
        Err(_) => {
            if is_htmx {
                return htmx_notice_response(
                    "feed-status",
                    "invalid-zone",
                    true,
                    StatusCode::UNPROCESSABLE_ENTITY,
                );
            }
            return Redirect::temporary("/feed?status=invalid-zone").into_response();
        }
    };

    let result = state
        ._domain_store
        .create_shout(CreateShoutInput {
            user_id: session.user.id,
            zone: zone.clone(),
            body,
        })
        .await;

    if result.is_err() {
        if is_htmx {
            return htmx_notice_response(
                "feed-status",
                "shout-post-failed",
                true,
                StatusCode::UNPROCESSABLE_ENTITY,
            );
        }
        return Redirect::temporary("/feed?status=shout-post-failed").into_response();
    }

    if is_htmx {
        let mut response =
            htmx_notice_response("feed-status", "shout-posted", false, StatusCode::OK);
        htmx_set_trigger_header(&mut response, "feed-shout-posted");
        return response;
    }

    if let Some(zone) = zone {
        let location = format!("/feed?zone={zone}&status=shout-posted");
        Redirect::temporary(&location).into_response()
    } else {
        Redirect::temporary("/feed?status=shout-posted").into_response()
    }
}

async fn web_settings_profile_update(
    State(state): State<AppState>,
    headers: HeaderMap,
    Form(payload): Form<UpdateProfileRequestPayload>,
) -> Response {
    let htmx = classify_htmx_request(&headers);
    let request_id = request_id(&headers);
    let bundle = match session_bundle_from_headers(&state, &headers).await {
        Ok(bundle) => bundle,
        Err(_) => {
            if htmx.is_hx_request {
                return htmx_redirect_response("/login");
            }
            return Redirect::temporary("/login").into_response();
        }
    };

    let normalized_name = payload.name.trim().to_string();
    if normalized_name.is_empty() || normalized_name.chars().count() > 255 {
        if htmx.is_hx_request {
            return htmx_notice_response(
                "settings-status",
                "profile-update-failed",
                true,
                StatusCode::UNPROCESSABLE_ENTITY,
            );
        }
        return Redirect::temporary("/settings/profile?status=profile-update-failed")
            .into_response();
    }

    let updated_user = match state
        .auth
        .update_profile_name(&bundle.user.id, normalized_name)
        .await
    {
        Ok(user) => user,
        Err(_) => {
            if htmx.is_hx_request {
                return htmx_notice_response(
                    "settings-status",
                    "profile-update-failed",
                    true,
                    StatusCode::UNPROCESSABLE_ENTITY,
                );
            }
            return Redirect::temporary("/settings/profile?status=profile-update-failed")
                .into_response();
        }
    };

    state.observability.audit(
        AuditEvent::new("profile.updated", request_id.clone())
            .with_user_id(updated_user.id.clone())
            .with_session_id(bundle.session.session_id.clone())
            .with_org_id(bundle.session.active_org_id.clone())
            .with_device_id(bundle.session.device_id.clone())
            .with_attribute("field_updated", "name".to_string())
            .with_attribute("source", "web".to_string()),
    );
    state
        .observability
        .increment_counter("profile.updated", &request_id);

    if htmx.is_hx_request {
        return htmx_notice_response("settings-status", "profile-updated", false, StatusCode::OK);
    }

    Redirect::temporary("/settings/profile?status=profile-updated").into_response()
}

async fn web_settings_profile_delete(
    State(state): State<AppState>,
    headers: HeaderMap,
    Form(payload): Form<DeleteProfileRequestPayload>,
) -> Response {
    let htmx = classify_htmx_request(&headers);
    let request_id = request_id(&headers);
    let bundle = match session_bundle_from_headers(&state, &headers).await {
        Ok(bundle) => bundle,
        Err(_) => {
            if htmx.is_hx_request {
                return htmx_redirect_response("/login");
            }
            return Redirect::temporary("/login").into_response();
        }
    };

    let normalized_email = payload.email.trim().to_lowercase();
    let user_email = bundle.user.email.trim().to_lowercase();
    if normalized_email.is_empty() || normalized_email != user_email {
        if htmx.is_hx_request {
            return htmx_notice_response(
                "settings-status",
                "profile-delete-failed",
                true,
                StatusCode::UNPROCESSABLE_ENTITY,
            );
        }
        return Redirect::temporary("/settings/profile?status=profile-delete-failed")
            .into_response();
    }

    let deleted_user = match state.auth.delete_profile(&bundle.user.id).await {
        Ok(user) => user,
        Err(_) => {
            if htmx.is_hx_request {
                return htmx_notice_response(
                    "settings-status",
                    "profile-delete-failed",
                    true,
                    StatusCode::UNPROCESSABLE_ENTITY,
                );
            }
            return Redirect::temporary("/settings/profile?status=profile-delete-failed")
                .into_response();
        }
    };

    state.observability.audit(
        AuditEvent::new("profile.deleted", request_id.clone())
            .with_user_id(deleted_user.id)
            .with_session_id(bundle.session.session_id)
            .with_org_id(bundle.session.active_org_id)
            .with_device_id(bundle.session.device_id)
            .with_attribute("source", "web".to_string()),
    );
    state
        .observability
        .increment_counter("profile.deleted", &request_id);

    let mut response = if htmx.is_hx_request {
        htmx_redirect_response("/login?status=profile-deleted")
    } else {
        Redirect::temporary("/login?status=profile-deleted").into_response()
    };
    let _ = append_set_cookie_header(&mut response, &clear_cookie(AUTH_ACCESS_COOKIE_NAME));
    let _ = append_set_cookie_header(&mut response, &clear_cookie(AUTH_REFRESH_COOKIE_NAME));
    let _ = append_set_cookie_header(&mut response, &clear_cookie(LOCAL_TEST_AUTH_COOKIE_NAME));
    response
}

async fn web_settings_resend_upsert(
    State(state): State<AppState>,
    headers: HeaderMap,
    Form(payload): Form<UpsertResendIntegrationRequestPayload>,
) -> Response {
    let htmx = classify_htmx_request(&headers);
    let request_id = request_id(&headers);
    let bundle = match session_bundle_from_headers(&state, &headers).await {
        Ok(bundle) => bundle,
        Err(_) => {
            if htmx.is_hx_request {
                return htmx_redirect_response("/login");
            }
            return Redirect::temporary("/login").into_response();
        }
    };

    let api_key = payload
        .resend_api_key
        .and_then(non_empty)
        .filter(|value| value.chars().count() >= 8 && value.chars().count() <= 4096);
    let Some(api_key) = api_key else {
        if htmx.is_hx_request {
            return htmx_notice_response(
                "settings-status",
                "settings-action-failed",
                true,
                StatusCode::UNPROCESSABLE_ENTITY,
            );
        }
        return Redirect::temporary("/settings/profile?status=settings-action-failed")
            .into_response();
    };
    let sender_email = match normalize_optional_email(payload.sender_email, "sender_email") {
        Ok(value) => value,
        Err(_) => {
            if htmx.is_hx_request {
                return htmx_notice_response(
                    "settings-status",
                    "settings-action-failed",
                    true,
                    StatusCode::UNPROCESSABLE_ENTITY,
                );
            }
            return Redirect::temporary("/settings/profile?status=settings-action-failed")
                .into_response();
        }
    };
    let sender_name =
        match normalize_optional_bounded_trimmed_string(payload.sender_name, "sender_name", 255) {
            Ok(value) => value,
            Err(_) => {
                if htmx.is_hx_request {
                    return htmx_notice_response(
                        "settings-status",
                        "settings-action-failed",
                        true,
                        StatusCode::UNPROCESSABLE_ENTITY,
                    );
                }
                return Redirect::temporary("/settings/profile?status=settings-action-failed")
                    .into_response();
            }
        };

    let result = match state
        ._domain_store
        .upsert_resend_integration(UpsertResendIntegrationInput {
            user_id: bundle.user.id.clone(),
            api_key,
            sender_email,
            sender_name,
        })
        .await
    {
        Ok(result) => result,
        Err(_) => {
            if htmx.is_hx_request {
                return htmx_notice_response(
                    "settings-status",
                    "settings-action-failed",
                    true,
                    StatusCode::UNPROCESSABLE_ENTITY,
                );
            }
            return Redirect::temporary("/settings/profile?status=settings-action-failed")
                .into_response();
        }
    };
    let status = match result.action.as_str() {
        "secret_created" => "resend-connected",
        "secret_rotated" => "resend-rotated",
        _ => "resend-updated",
    };

    state.observability.audit(
        AuditEvent::new("settings.integrations.resend.upserted", request_id.clone())
            .with_user_id(bundle.user.id)
            .with_session_id(bundle.session.session_id)
            .with_org_id(bundle.session.active_org_id)
            .with_device_id(bundle.session.device_id)
            .with_attribute("action", result.action)
            .with_attribute("status", status.to_string()),
    );
    state
        .observability
        .increment_counter("settings.integrations.resend.upserted", &request_id);

    if htmx.is_hx_request {
        return htmx_notice_response("settings-status", status, false, StatusCode::OK);
    }

    Redirect::temporary(&format!("/settings/profile?status={status}")).into_response()
}

async fn web_settings_resend_test(State(state): State<AppState>, headers: HeaderMap) -> Response {
    let htmx = classify_htmx_request(&headers);
    let request_id = request_id(&headers);
    let bundle = match session_bundle_from_headers(&state, &headers).await {
        Ok(bundle) => bundle,
        Err(_) => {
            if htmx.is_hx_request {
                return htmx_redirect_response("/login");
            }
            return Redirect::temporary("/login").into_response();
        }
    };

    let integration = match state
        ._domain_store
        .find_active_integration_secret(&bundle.user.id, "resend")
        .await
    {
        Ok(Some(integration)) => integration,
        _ => {
            if htmx.is_hx_request {
                return htmx_notice_response(
                    "settings-status",
                    "settings-action-failed",
                    true,
                    StatusCode::UNPROCESSABLE_ENTITY,
                );
            }
            return Redirect::temporary("/settings/profile?status=settings-action-failed")
                .into_response();
        }
    };

    if state
        ._domain_store
        .audit_integration_test_request(&bundle.user.id, "resend")
        .await
        .is_err()
    {
        if htmx.is_hx_request {
            return htmx_notice_response(
                "settings-status",
                "settings-action-failed",
                true,
                StatusCode::UNPROCESSABLE_ENTITY,
            );
        }
        return Redirect::temporary("/settings/profile?status=settings-action-failed")
            .into_response();
    }

    state.observability.audit(
        AuditEvent::new(
            "settings.integrations.resend.test_requested",
            request_id.clone(),
        )
        .with_user_id(bundle.user.id)
        .with_session_id(bundle.session.session_id)
        .with_org_id(bundle.session.active_org_id)
        .with_device_id(bundle.session.device_id)
        .with_attribute("integration_id", integration.id.to_string()),
    );
    state
        .observability
        .increment_counter("settings.integrations.resend.test_requested", &request_id);

    if htmx.is_hx_request {
        return htmx_notice_response(
            "settings-status",
            "resend-test-queued",
            false,
            StatusCode::OK,
        );
    }

    Redirect::temporary("/settings/profile?status=resend-test-queued").into_response()
}

async fn web_settings_resend_disconnect(
    State(state): State<AppState>,
    headers: HeaderMap,
) -> Response {
    let htmx = classify_htmx_request(&headers);
    let request_id = request_id(&headers);
    let bundle = match session_bundle_from_headers(&state, &headers).await {
        Ok(bundle) => bundle,
        Err(_) => {
            if htmx.is_hx_request {
                return htmx_redirect_response("/login");
            }
            return Redirect::temporary("/login").into_response();
        }
    };

    let revoked = match state
        ._domain_store
        .revoke_integration(&bundle.user.id, "resend")
        .await
    {
        Ok(revoked) => revoked,
        Err(_) => {
            if htmx.is_hx_request {
                return htmx_notice_response(
                    "settings-status",
                    "settings-action-failed",
                    true,
                    StatusCode::UNPROCESSABLE_ENTITY,
                );
            }
            return Redirect::temporary("/settings/profile?status=settings-action-failed")
                .into_response();
        }
    };

    state.observability.audit(
        AuditEvent::new(
            "settings.integrations.resend.disconnected",
            request_id.clone(),
        )
        .with_user_id(bundle.user.id)
        .with_session_id(bundle.session.session_id)
        .with_org_id(bundle.session.active_org_id)
        .with_device_id(bundle.session.device_id)
        .with_attribute("had_integration", revoked.is_some().to_string()),
    );
    state
        .observability
        .increment_counter("settings.integrations.resend.disconnected", &request_id);

    if htmx.is_hx_request {
        return htmx_notice_response(
            "settings-status",
            "resend-disconnected",
            false,
            StatusCode::OK,
        );
    }

    Redirect::temporary("/settings/profile?status=resend-disconnected").into_response()
}

async fn web_settings_google_connect(
    State(state): State<AppState>,
    headers: HeaderMap,
) -> Response {
    let htmx = classify_htmx_request(&headers);
    match settings_integrations_google_redirect(State(state), headers.clone()).await {
        Ok(response) => response,
        Err(_) => {
            if htmx.is_hx_request {
                htmx_notice_response(
                    "settings-status",
                    "settings-action-failed",
                    true,
                    StatusCode::UNPROCESSABLE_ENTITY,
                )
            } else {
                Redirect::temporary("/settings/profile?status=settings-action-failed")
                    .into_response()
            }
        }
    }
}

async fn web_settings_google_disconnect(
    State(state): State<AppState>,
    headers: HeaderMap,
) -> Response {
    let htmx = classify_htmx_request(&headers);
    let request_id = request_id(&headers);
    let bundle = match session_bundle_from_headers(&state, &headers).await {
        Ok(bundle) => bundle,
        Err(_) => {
            if htmx.is_hx_request {
                return htmx_redirect_response("/login");
            }
            return Redirect::temporary("/login").into_response();
        }
    };

    let revoked = match state
        ._domain_store
        .revoke_integration(&bundle.user.id, "google")
        .await
    {
        Ok(revoked) => revoked,
        Err(_) => {
            if htmx.is_hx_request {
                return htmx_notice_response(
                    "settings-status",
                    "settings-action-failed",
                    true,
                    StatusCode::UNPROCESSABLE_ENTITY,
                );
            }
            return Redirect::temporary("/settings/profile?status=settings-action-failed")
                .into_response();
        }
    };

    state.observability.audit(
        AuditEvent::new(
            "settings.integrations.google.disconnected",
            request_id.clone(),
        )
        .with_user_id(bundle.user.id)
        .with_session_id(bundle.session.session_id)
        .with_org_id(bundle.session.active_org_id)
        .with_device_id(bundle.session.device_id)
        .with_attribute("had_integration", revoked.is_some().to_string()),
    );
    state
        .observability
        .increment_counter("settings.integrations.google.disconnected", &request_id);

    if htmx.is_hx_request {
        return htmx_notice_response(
            "settings-status",
            "google-disconnected",
            false,
            StatusCode::OK,
        );
    }

    Redirect::temporary("/settings/profile?status=google-disconnected").into_response()
}

fn web_l402_status_response(
    is_hx_request: bool,
    status: &str,
    is_error: bool,
    status_code: StatusCode,
) -> Response {
    if is_hx_request {
        return htmx_notice_response("billing-status", status, is_error, status_code);
    }
    Redirect::temporary(&format!("/l402?status={status}")).into_response()
}

async fn web_l402_paywall_create(
    State(state): State<AppState>,
    headers: HeaderMap,
    Form(payload): Form<WebL402PaywallCreateForm>,
) -> Response {
    let htmx = classify_htmx_request(&headers);
    let bundle = match session_bundle_from_headers(&state, &headers).await {
        Ok(bundle) => bundle,
        Err(_) => {
            if htmx.is_hx_request {
                return htmx_redirect_response("/login");
            }
            return Redirect::temporary("/login").into_response();
        }
    };
    if !is_admin_email(&bundle.user.email, &state.config.admin_emails) {
        return web_l402_status_response(
            htmx.is_hx_request,
            "l402-admin-required",
            true,
            StatusCode::FORBIDDEN,
        );
    }

    let price_msats = payload
        .price_msats
        .trim()
        .parse::<u64>()
        .ok()
        .filter(|value| *value > 0);
    let Some(price_msats) = price_msats else {
        return web_l402_status_response(
            htmx.is_hx_request,
            "l402-action-failed",
            true,
            StatusCode::UNPROCESSABLE_ENTITY,
        );
    };

    let api_payload = L402PaywallCreateRequestPayload {
        name: payload.name,
        host_regexp: payload.host_regexp,
        path_regexp: payload.path_regexp,
        price_msats,
        upstream: payload.upstream,
        enabled: Some(payload.enabled.is_some()),
        meta: None,
    };

    match l402_paywall_create(State(state), headers.clone(), Json(api_payload)).await {
        Ok(_) => web_l402_status_response(
            htmx.is_hx_request,
            "l402-paywall-created",
            false,
            StatusCode::OK,
        ),
        Err(_) => web_l402_status_response(
            htmx.is_hx_request,
            "l402-action-failed",
            true,
            StatusCode::UNPROCESSABLE_ENTITY,
        ),
    }
}

async fn web_l402_paywall_toggle(
    State(state): State<AppState>,
    Path(paywall_id): Path<String>,
    headers: HeaderMap,
) -> Response {
    let htmx = classify_htmx_request(&headers);
    let bundle = match session_bundle_from_headers(&state, &headers).await {
        Ok(bundle) => bundle,
        Err(_) => {
            if htmx.is_hx_request {
                return htmx_redirect_response("/login");
            }
            return Redirect::temporary("/login").into_response();
        }
    };
    if !is_admin_email(&bundle.user.email, &state.config.admin_emails) {
        return web_l402_status_response(
            htmx.is_hx_request,
            "l402-admin-required",
            true,
            StatusCode::FORBIDDEN,
        );
    }

    let existing = match state
        ._domain_store
        .list_l402_paywalls_for_owner(&bundle.user.id, false)
        .await
    {
        Ok(rows) => rows.into_iter().find(|row| row.id == paywall_id),
        Err(_) => None,
    };
    let Some(existing) = existing else {
        return web_l402_status_response(
            htmx.is_hx_request,
            "l402-action-failed",
            true,
            StatusCode::UNPROCESSABLE_ENTITY,
        );
    };

    let update_payload = L402PaywallUpdateRequestPayload {
        enabled: Some(!existing.enabled),
        ..L402PaywallUpdateRequestPayload::default()
    };

    match l402_paywall_update(
        State(state),
        Path(existing.id),
        headers.clone(),
        Json(update_payload),
    )
    .await
    {
        Ok(_) => web_l402_status_response(
            htmx.is_hx_request,
            "l402-paywall-updated",
            false,
            StatusCode::OK,
        ),
        Err(_) => web_l402_status_response(
            htmx.is_hx_request,
            "l402-action-failed",
            true,
            StatusCode::UNPROCESSABLE_ENTITY,
        ),
    }
}

async fn web_l402_paywall_delete(
    State(state): State<AppState>,
    Path(paywall_id): Path<String>,
    headers: HeaderMap,
) -> Response {
    let htmx = classify_htmx_request(&headers);
    let bundle = match session_bundle_from_headers(&state, &headers).await {
        Ok(bundle) => bundle,
        Err(_) => {
            if htmx.is_hx_request {
                return htmx_redirect_response("/login");
            }
            return Redirect::temporary("/login").into_response();
        }
    };
    if !is_admin_email(&bundle.user.email, &state.config.admin_emails) {
        return web_l402_status_response(
            htmx.is_hx_request,
            "l402-admin-required",
            true,
            StatusCode::FORBIDDEN,
        );
    }

    match l402_paywall_delete(State(state), Path(paywall_id), headers.clone()).await {
        Ok(_) => web_l402_status_response(
            htmx.is_hx_request,
            "l402-paywall-deleted",
            false,
            StatusCode::OK,
        ),
        Err(_) => web_l402_status_response(
            htmx.is_hx_request,
            "l402-action-failed",
            true,
            StatusCode::UNPROCESSABLE_ENTITY,
        ),
    }
}

fn web_admin_status_response(
    is_hx_request: bool,
    status: &str,
    is_error: bool,
    status_code: StatusCode,
) -> Response {
    if is_hx_request {
        return htmx_notice_response("admin-status", status, is_error, status_code);
    }
    Redirect::temporary(&format!("/admin?status={status}")).into_response()
}

fn html_escape(text: &str) -> String {
    text.replace('&', "&amp;")
        .replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('"', "&quot;")
        .replace('\'', "&#39;")
}

fn web_admin_result_fragment_response(
    is_hx_request: bool,
    status: &str,
    is_error: bool,
    status_code: StatusCode,
    payload: serde_json::Value,
) -> Response {
    if is_hx_request {
        let pretty = serde_json::to_string_pretty(&payload).unwrap_or_else(|_| "{}".to_string());
        let status_text = match status {
            "admin-action-completed" => "Admin action completed.",
            "admin-action-failed" => "Admin action failed.",
            "admin-forbidden" => "Admin role required.",
            _ => "Action completed.",
        };
        let status_class = if is_error {
            "oa-notice error"
        } else {
            "oa-notice"
        };
        let fragment = format!(
            "<article id=\"admin-result\" class=\"oa-card\"><h3>Result</h3><pre class=\"oa-json\">{}</pre></article><div id=\"admin-status\" class=\"{}\" hx-swap-oob=\"outerHTML\">{}</div>",
            html_escape(&pretty),
            status_class,
            html_escape(status_text)
        );
        let mut response = crate::web_htmx::fragment_response(fragment, status_code);
        apply_html_security_headers(response.headers_mut());
        return response;
    }

    Redirect::temporary(&format!("/admin?status={status}")).into_response()
}

async fn web_admin_bundle(
    state: &AppState,
    headers: &HeaderMap,
    is_hx_request: bool,
) -> Result<SessionBundle, Response> {
    let bundle = session_bundle_from_headers(state, headers)
        .await
        .map_err(|_| {
            if is_hx_request {
                htmx_redirect_response("/login")
            } else {
                Redirect::temporary("/login").into_response()
            }
        })?;
    if !is_admin_email(&bundle.user.email, &state.config.admin_emails) {
        return Err(web_admin_status_response(
            is_hx_request,
            "admin-forbidden",
            true,
            StatusCode::FORBIDDEN,
        ));
    }
    Ok(bundle)
}

fn parse_web_lightning_ops_args(
    args_json: Option<String>,
) -> Result<serde_json::Map<String, serde_json::Value>, serde_json::Value> {
    let raw = args_json
        .as_deref()
        .map(str::trim)
        .filter(|value| !value.is_empty())
        .unwrap_or("{}");
    let value = serde_json::from_str::<serde_json::Value>(raw).map_err(|_| {
        serde_json::json!({
            "ok": false,
            "error": {
                "code": "invalid_args_json",
                "message": "args_json must be a valid JSON object",
            }
        })
    })?;
    let object = value.as_object().cloned().ok_or_else(|| {
        serde_json::json!({
            "ok": false,
            "error": {
                "code": "invalid_args_json",
                "message": "args_json must decode to a JSON object",
            }
        })
    })?;
    Ok(object)
}

async fn web_admin_route_split_evaluate(
    State(state): State<AppState>,
    headers: HeaderMap,
    Form(payload): Form<WebRouteSplitEvaluateForm>,
) -> Response {
    let htmx = classify_htmx_request(&headers);
    if let Err(response) = web_admin_bundle(&state, &headers, htmx.is_hx_request).await {
        return response;
    }

    let path = payload.path.trim().to_string();
    if path.is_empty() {
        return web_admin_result_fragment_response(
            htmx.is_hx_request,
            "admin-action-failed",
            true,
            StatusCode::UNPROCESSABLE_ENTITY,
            serde_json::json!({
                "ok": false,
                "error": {
                    "code": "invalid_path",
                    "message": "Path is required.",
                }
            }),
        );
    }

    let cohort_key = payload
        .cohort_key
        .filter(|value| !value.trim().is_empty())
        .unwrap_or_else(|| resolve_route_cohort_key(&headers));
    let decision = state.route_split.evaluate(&path, &cohort_key).await;
    web_admin_result_fragment_response(
        htmx.is_hx_request,
        "admin-action-completed",
        false,
        StatusCode::OK,
        serde_json::json!({
            "ok": true,
            "action": "route_split.evaluate",
            "decision": decision,
        }),
    )
}

async fn web_admin_route_split_override(
    State(state): State<AppState>,
    headers: HeaderMap,
    Form(payload): Form<WebRouteSplitOverrideForm>,
) -> Response {
    let htmx = classify_htmx_request(&headers);
    let bundle = match web_admin_bundle(&state, &headers, htmx.is_hx_request).await {
        Ok(bundle) => bundle,
        Err(response) => return response,
    };
    let request_id = request_id(&headers);

    let normalized_target = payload.target.trim().to_ascii_lowercase();
    let normalized_domain = payload
        .domain
        .as_deref()
        .map(str::trim)
        .filter(|value| !value.is_empty())
        .map(|value| value.to_lowercase());
    let mut override_kind = "route_target";
    let mut htmx_mode: Option<&'static str> = None;

    let apply = match normalized_target.as_str() {
        "legacy" => {
            if let Some(domain) = normalized_domain.as_deref() {
                state
                    .route_split
                    .set_domain_override_target(domain, Some(RouteTarget::Legacy))
                    .await
            } else {
                state
                    .route_split
                    .set_override_target(Some(RouteTarget::Legacy))
                    .await;
                Ok(())
            }
        }
        "rust" | "rust_shell" => {
            if let Some(domain) = normalized_domain.as_deref() {
                state
                    .route_split
                    .set_domain_override_target(domain, Some(RouteTarget::RustShell))
                    .await
            } else {
                state
                    .route_split
                    .set_override_target(Some(RouteTarget::RustShell))
                    .await;
                Ok(())
            }
        }
        "clear" | "default" => {
            if let Some(domain) = normalized_domain.as_deref() {
                state
                    .route_split
                    .set_domain_override_target(domain, None)
                    .await
            } else {
                state.route_split.set_override_target(None).await;
                Ok(())
            }
        }
        "htmx_fragment" | "htmx_on" => {
            let Some(domain) = normalized_domain.as_deref() else {
                return web_admin_result_fragment_response(
                    htmx.is_hx_request,
                    "admin-action-failed",
                    true,
                    StatusCode::UNPROCESSABLE_ENTITY,
                    serde_json::json!({
                        "ok": false,
                        "error": {
                            "code": "missing_domain",
                            "message": "Domain is required for HTMX overrides.",
                        }
                    }),
                );
            };
            override_kind = "htmx_mode";
            htmx_mode = Some("fragment");
            state
                .route_split
                .set_domain_htmx_mode(domain, Some(HtmxModeTarget::Fragment))
                .await
        }
        "htmx_full_page" | "htmx_off" => {
            let Some(domain) = normalized_domain.as_deref() else {
                return web_admin_result_fragment_response(
                    htmx.is_hx_request,
                    "admin-action-failed",
                    true,
                    StatusCode::UNPROCESSABLE_ENTITY,
                    serde_json::json!({
                        "ok": false,
                        "error": {
                            "code": "missing_domain",
                            "message": "Domain is required for HTMX overrides.",
                        }
                    }),
                );
            };
            override_kind = "htmx_mode";
            htmx_mode = Some("full_page");
            state
                .route_split
                .set_domain_htmx_mode(domain, Some(HtmxModeTarget::FullPage))
                .await
        }
        "htmx_rollback" => {
            let Some(domain) = normalized_domain.as_deref() else {
                return web_admin_result_fragment_response(
                    htmx.is_hx_request,
                    "admin-action-failed",
                    true,
                    StatusCode::UNPROCESSABLE_ENTITY,
                    serde_json::json!({
                        "ok": false,
                        "error": {
                            "code": "missing_domain",
                            "message": "Domain is required for HTMX overrides.",
                        }
                    }),
                );
            };
            let Some(rollback_mode) = state.route_split.htmx_rollback_mode_for_domain(Some(domain))
            else {
                return web_admin_result_fragment_response(
                    htmx.is_hx_request,
                    "admin-action-failed",
                    true,
                    StatusCode::UNPROCESSABLE_ENTITY,
                    serde_json::json!({
                        "ok": false,
                        "error": {
                            "code": "invalid_domain",
                            "message": "Unknown route domain.",
                        }
                    }),
                );
            };
            override_kind = "htmx_mode";
            htmx_mode = Some(match rollback_mode {
                HtmxModeTarget::Fragment => "fragment",
                HtmxModeTarget::FullPage => "full_page",
            });
            state
                .route_split
                .set_domain_htmx_mode(domain, Some(rollback_mode))
                .await
        }
        "htmx_clear" => {
            let Some(domain) = normalized_domain.as_deref() else {
                return web_admin_result_fragment_response(
                    htmx.is_hx_request,
                    "admin-action-failed",
                    true,
                    StatusCode::UNPROCESSABLE_ENTITY,
                    serde_json::json!({
                        "ok": false,
                        "error": {
                            "code": "missing_domain",
                            "message": "Domain is required for HTMX overrides.",
                        }
                    }),
                );
            };
            override_kind = "htmx_mode";
            htmx_mode = None;
            state.route_split.set_domain_htmx_mode(domain, None).await
        }
        "rollback" => {
            if let Some(domain) = normalized_domain.as_deref() {
                if let Some(rollback_target) =
                    state.route_split.rollback_target_for_domain(Some(domain))
                {
                    state
                        .route_split
                        .set_domain_override_target(domain, Some(rollback_target))
                        .await
                } else {
                    Err("Unknown route domain.".to_string())
                }
            } else {
                if let Some(global_target) = state.route_split.rollback_target_for_domain(None) {
                    state
                        .route_split
                        .set_override_target(Some(global_target))
                        .await;
                } else {
                    state
                        .route_split
                        .set_override_target(Some(RouteTarget::Legacy))
                        .await;
                }
                Ok(())
            }
        }
        _ => Err("Target must be one of: legacy, rust, rollback, clear, htmx_fragment, htmx_full_page, htmx_rollback, htmx_clear.".to_string()),
    };

    if let Err(message) = apply {
        return web_admin_result_fragment_response(
            htmx.is_hx_request,
            "admin-action-failed",
            true,
            StatusCode::UNPROCESSABLE_ENTITY,
            serde_json::json!({
                "ok": false,
                "error": {
                    "code": "invalid_target",
                    "message": message,
                }
            }),
        );
    }

    let status = state.route_split.status().await;
    let scope = normalized_domain
        .clone()
        .map(|domain| format!("domain:{domain}"))
        .unwrap_or_else(|| "global".to_string());
    let event_name = if override_kind == "htmx_mode" {
        "route.split.htmx.override.updated"
    } else {
        "route.split.override.updated"
    };
    state.observability.audit(
        AuditEvent::new(event_name, request_id.clone())
            .with_user_id(bundle.user.id)
            .with_session_id(bundle.session.session_id)
            .with_org_id(bundle.session.active_org_id)
            .with_device_id(bundle.session.device_id)
            .with_attribute("target", normalized_target)
            .with_attribute("scope", scope)
            .with_attribute("override_kind", override_kind)
            .with_attribute("htmx_mode", htmx_mode.unwrap_or("clear")),
    );
    state
        .observability
        .increment_counter(event_name, &request_id);

    web_admin_result_fragment_response(
        htmx.is_hx_request,
        "admin-action-completed",
        false,
        StatusCode::OK,
        serde_json::json!({
            "ok": true,
            "action": "route_split.override",
            "status": status,
        }),
    )
}

async fn web_admin_runtime_routing_evaluate(
    State(state): State<AppState>,
    headers: HeaderMap,
    Form(payload): Form<WebRuntimeRoutingEvaluateForm>,
) -> Response {
    let htmx = classify_htmx_request(&headers);
    let bundle = match web_admin_bundle(&state, &headers, htmx.is_hx_request).await {
        Ok(bundle) => bundle,
        Err(response) => return response,
    };
    let thread_id = payload.thread_id.trim().to_string();
    if thread_id.is_empty() {
        return web_admin_result_fragment_response(
            htmx.is_hx_request,
            "admin-action-failed",
            true,
            StatusCode::UNPROCESSABLE_ENTITY,
            serde_json::json!({
                "ok": false,
                "error": {
                    "code": "invalid_thread_id",
                    "message": "Thread id is required.",
                }
            }),
        );
    }

    let decision = state
        .runtime_routing
        .resolve(
            &state._domain_store,
            &state.codex_thread_store,
            RuntimeRoutingResolveInput {
                user_id: bundle.user.id.clone(),
                thread_id,
                autopilot_id: payload.autopilot_id,
            },
        )
        .await;
    web_admin_result_fragment_response(
        htmx.is_hx_request,
        "admin-action-completed",
        false,
        StatusCode::OK,
        serde_json::json!({
            "ok": true,
            "action": "runtime_routing.evaluate",
            "decision": decision,
        }),
    )
}

async fn web_admin_runtime_routing_override(
    State(state): State<AppState>,
    headers: HeaderMap,
    Form(payload): Form<WebRuntimeRoutingOverrideForm>,
) -> Response {
    let htmx = classify_htmx_request(&headers);
    let bundle = match web_admin_bundle(&state, &headers, htmx.is_hx_request).await {
        Ok(bundle) => bundle,
        Err(response) => return response,
    };
    let request_id = request_id(&headers);

    let scope_type = payload.scope_type.trim().to_ascii_lowercase();
    if !matches!(scope_type.as_str(), "user" | "autopilot") {
        return web_admin_result_fragment_response(
            htmx.is_hx_request,
            "admin-action-failed",
            true,
            StatusCode::UNPROCESSABLE_ENTITY,
            serde_json::json!({
                "ok": false,
                "error": {
                    "code": "invalid_scope_type",
                    "message": "Scope type must be one of: user, autopilot.",
                }
            }),
        );
    }

    let scope_id = payload.scope_id.trim().to_string();
    if scope_id.is_empty() || scope_id.chars().count() > 160 {
        return web_admin_result_fragment_response(
            htmx.is_hx_request,
            "admin-action-failed",
            true,
            StatusCode::UNPROCESSABLE_ENTITY,
            serde_json::json!({
                "ok": false,
                "error": {
                    "code": "invalid_scope_id",
                    "message": "Scope id is required and must be <= 160 characters.",
                }
            }),
        );
    }

    let Some(driver) = RuntimeDriver::parse(&payload.driver) else {
        return web_admin_result_fragment_response(
            htmx.is_hx_request,
            "admin-action-failed",
            true,
            StatusCode::UNPROCESSABLE_ENTITY,
            serde_json::json!({
                "ok": false,
                "error": {
                    "code": "invalid_driver",
                    "message": "Driver must be one of: legacy, elixir.",
                }
            }),
        );
    };

    let reason = payload
        .reason
        .as_deref()
        .map(str::trim)
        .filter(|value| !value.is_empty())
        .map(ToString::to_string);
    if reason
        .as_deref()
        .map(|value| value.chars().count() > 255)
        .unwrap_or(false)
    {
        return web_admin_result_fragment_response(
            htmx.is_hx_request,
            "admin-action-failed",
            true,
            StatusCode::UNPROCESSABLE_ENTITY,
            serde_json::json!({
                "ok": false,
                "error": {
                    "code": "invalid_reason",
                    "message": "Reason may not be greater than 255 characters.",
                }
            }),
        );
    }

    let override_record = match state
        ._domain_store
        .upsert_runtime_driver_override(UpsertRuntimeDriverOverrideInput {
            scope_type,
            scope_id,
            driver: driver.as_str().to_string(),
            is_active: payload.is_active.is_some(),
            reason,
            meta: None,
        })
        .await
    {
        Ok(record) => record,
        Err(error) => {
            return web_admin_result_fragment_response(
                htmx.is_hx_request,
                "admin-action-failed",
                true,
                StatusCode::UNPROCESSABLE_ENTITY,
                serde_json::json!({
                    "ok": false,
                    "error": {
                        "code": "runtime_override_failed",
                        "message": error.to_string(),
                    }
                }),
            );
        }
    };

    state.observability.audit(
        AuditEvent::new("runtime.routing.override.updated", request_id.clone())
            .with_user_id(bundle.user.id)
            .with_session_id(bundle.session.session_id)
            .with_org_id(bundle.session.active_org_id)
            .with_device_id(bundle.session.device_id)
            .with_attribute("scope_type", override_record.scope_type.clone())
            .with_attribute("scope_id", override_record.scope_id.clone())
            .with_attribute("driver", override_record.driver.clone())
            .with_attribute("is_active", override_record.is_active.to_string()),
    );
    state
        .observability
        .increment_counter("runtime.routing.override.updated", &request_id);

    let status = state.runtime_routing.status(&state._domain_store).await;
    web_admin_result_fragment_response(
        htmx.is_hx_request,
        "admin-action-completed",
        false,
        StatusCode::OK,
        serde_json::json!({
            "ok": true,
            "action": "runtime_routing.override",
            "override": override_record,
            "status": status,
        }),
    )
}

async fn web_admin_lightning_ops_query(
    State(state): State<AppState>,
    headers: HeaderMap,
    Form(payload): Form<WebLightningOpsForm>,
) -> Response {
    let htmx = classify_htmx_request(&headers);
    if let Err(response) = web_admin_bundle(&state, &headers, htmx.is_hx_request).await {
        return response;
    }
    let args = match parse_web_lightning_ops_args(payload.args_json) {
        Ok(args) => args,
        Err(error_payload) => {
            return web_admin_result_fragment_response(
                htmx.is_hx_request,
                "admin-action-failed",
                true,
                StatusCode::UNPROCESSABLE_ENTITY,
                error_payload,
            );
        }
    };
    let request_payload = serde_json::json!({
        "functionName": payload.function_name,
        "args": args,
    });

    match lightning_ops_control_plane_query(State(state), Json(request_payload)).await {
        Ok((status_code, Json(body))) => web_admin_result_fragment_response(
            htmx.is_hx_request,
            "admin-action-completed",
            false,
            status_code,
            body,
        ),
        Err((status_code, Json(body))) => web_admin_result_fragment_response(
            htmx.is_hx_request,
            "admin-action-failed",
            true,
            status_code,
            body,
        ),
    }
}

async fn web_admin_lightning_ops_mutation(
    State(state): State<AppState>,
    headers: HeaderMap,
    Form(payload): Form<WebLightningOpsForm>,
) -> Response {
    let htmx = classify_htmx_request(&headers);
    if let Err(response) = web_admin_bundle(&state, &headers, htmx.is_hx_request).await {
        return response;
    }
    let args = match parse_web_lightning_ops_args(payload.args_json) {
        Ok(args) => args,
        Err(error_payload) => {
            return web_admin_result_fragment_response(
                htmx.is_hx_request,
                "admin-action-failed",
                true,
                StatusCode::UNPROCESSABLE_ENTITY,
                error_payload,
            );
        }
    };
    let request_payload = serde_json::json!({
        "functionName": payload.function_name,
        "args": args,
    });

    match lightning_ops_control_plane_mutation(State(state), Json(request_payload)).await {
        Ok((status_code, Json(body))) => web_admin_result_fragment_response(
            htmx.is_hx_request,
            "admin-action-completed",
            false,
            status_code,
            body,
        ),
        Err((status_code, Json(body))) => web_admin_result_fragment_response(
            htmx.is_hx_request,
            "admin-action-failed",
            true,
            status_code,
            body,
        ),
    }
}

async fn list_autopilots(
    State(state): State<AppState>,
    headers: HeaderMap,
    Query(query): Query<AutopilotListQuery>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;

    let limit = query.limit.unwrap_or(100).clamp(1, 200);
    let autopilots = state
        ._domain_store
        .list_autopilots_for_owner(&bundle.user.id, limit)
        .await
        .map_err(map_domain_store_error)?;
    let payload = autopilots
        .iter()
        .map(autopilot_aggregate_payload)
        .collect::<Vec<_>>();

    state.observability.audit(
        AuditEvent::new("autopilot.list_viewed", request_id.clone())
            .with_user_id(bundle.user.id)
            .with_session_id(bundle.session.session_id)
            .with_org_id(bundle.session.active_org_id)
            .with_device_id(bundle.session.device_id)
            .with_attribute("limit", limit.to_string())
            .with_attribute("count", payload.len().to_string()),
    );
    state
        .observability
        .increment_counter("autopilot.list_viewed", &request_id);

    Ok((StatusCode::OK, Json(serde_json::json!({ "data": payload }))))
}

async fn create_autopilot(
    State(state): State<AppState>,
    headers: HeaderMap,
    Json(payload): Json<CreateAutopilotRequestPayload>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;

    let handle_seed = normalize_autopilot_handle_seed(payload.handle)?;
    let display_name = normalize_optional_display_name(payload.display_name, "displayName")?
        .unwrap_or_else(|| "Autopilot".to_string());
    let avatar = normalize_optional_bounded_string(payload.avatar, "avatar", 255)?;
    let tagline = normalize_optional_bounded_string(payload.tagline, "tagline", 255)?;
    let status = normalize_autopilot_enum(
        payload.status,
        "status",
        &["active", "disabled", "archived"],
    )?;
    let visibility = normalize_autopilot_enum(
        payload.visibility,
        "visibility",
        &["private", "discoverable", "public"],
    )?;

    let autopilot = state
        ._domain_store
        .create_autopilot(CreateAutopilotInput {
            owner_user_id: bundle.user.id.clone(),
            owner_display_name: bundle.user.name.clone(),
            display_name,
            handle_seed,
            avatar,
            status,
            visibility,
            tagline,
        })
        .await
        .map_err(map_domain_store_error)?;

    state.observability.audit(
        AuditEvent::new("autopilot.created", request_id.clone())
            .with_user_id(bundle.user.id)
            .with_session_id(bundle.session.session_id)
            .with_org_id(bundle.session.active_org_id)
            .with_device_id(bundle.session.device_id)
            .with_attribute("autopilot_id", autopilot.autopilot.id.clone())
            .with_attribute("handle", autopilot.autopilot.handle.clone())
            .with_attribute("status", autopilot.autopilot.status.clone())
            .with_attribute("visibility", autopilot.autopilot.visibility.clone()),
    );
    state
        .observability
        .increment_counter("autopilot.created", &request_id);

    Ok((
        StatusCode::CREATED,
        Json(serde_json::json!({
            "data": autopilot_aggregate_payload(&autopilot),
        })),
    ))
}

async fn show_autopilot(
    State(state): State<AppState>,
    Path(autopilot): Path<String>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let reference = normalize_autopilot_reference(autopilot)?;

    let autopilot = state
        ._domain_store
        .resolve_owned_autopilot(&bundle.user.id, &reference)
        .await
        .map_err(map_domain_store_error)?;

    state.observability.audit(
        AuditEvent::new("autopilot.viewed", request_id.clone())
            .with_user_id(bundle.user.id)
            .with_session_id(bundle.session.session_id)
            .with_org_id(bundle.session.active_org_id)
            .with_device_id(bundle.session.device_id)
            .with_attribute("autopilot_id", autopilot.autopilot.id.clone())
            .with_attribute("handle", autopilot.autopilot.handle.clone()),
    );
    state
        .observability
        .increment_counter("autopilot.viewed", &request_id);

    Ok((
        StatusCode::OK,
        Json(serde_json::json!({
            "data": autopilot_aggregate_payload(&autopilot),
        })),
    ))
}

async fn update_autopilot(
    State(state): State<AppState>,
    Path(autopilot): Path<String>,
    headers: HeaderMap,
    Json(payload): Json<UpdateAutopilotRequestPayload>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let reference = normalize_autopilot_reference(autopilot)?;
    let field_count = autopilot_update_field_count(
        payload.display_name.is_some(),
        payload.status.is_some(),
        payload.visibility.is_some(),
        payload.avatar.is_some(),
        payload.tagline.is_some(),
        payload.profile.is_some(),
        payload.policy.is_some(),
    );

    let display_name = normalize_optional_display_name(payload.display_name, "displayName")?;
    let status = normalize_autopilot_enum(
        payload.status,
        "status",
        &["active", "disabled", "archived"],
    )?;
    let visibility = normalize_autopilot_enum(
        payload.visibility,
        "visibility",
        &["private", "discoverable", "public"],
    )?;
    let avatar = normalize_optional_bounded_string(payload.avatar, "avatar", 255)?;
    let tagline = normalize_optional_bounded_string(payload.tagline, "tagline", 255)?;
    let profile = payload
        .profile
        .map(normalize_autopilot_profile_update)
        .transpose()?;
    let policy = payload
        .policy
        .map(normalize_autopilot_policy_update)
        .transpose()?;

    let updated = state
        ._domain_store
        .update_owned_autopilot(
            &bundle.user.id,
            &reference,
            UpdateAutopilotInput {
                display_name,
                avatar,
                status,
                visibility,
                tagline,
                profile,
                policy,
            },
        )
        .await
        .map_err(map_domain_store_error)?;

    state.observability.audit(
        AuditEvent::new("autopilot.updated", request_id.clone())
            .with_user_id(bundle.user.id)
            .with_session_id(bundle.session.session_id)
            .with_org_id(bundle.session.active_org_id)
            .with_device_id(bundle.session.device_id)
            .with_attribute("autopilot_id", updated.autopilot.id.clone())
            .with_attribute("field_count", field_count.to_string())
            .with_attribute("status", updated.autopilot.status.clone())
            .with_attribute("visibility", updated.autopilot.visibility.clone()),
    );
    state
        .observability
        .increment_counter("autopilot.updated", &request_id);

    Ok((
        StatusCode::OK,
        Json(serde_json::json!({
            "data": autopilot_aggregate_payload(&updated),
        })),
    ))
}

async fn create_autopilot_thread(
    State(state): State<AppState>,
    Path(autopilot): Path<String>,
    headers: HeaderMap,
    Json(payload): Json<CreateAutopilotThreadRequestPayload>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let reference = normalize_autopilot_reference(autopilot)?;
    let title = normalize_optional_bounded_string(payload.title, "title", 200)?
        .unwrap_or_else(|| "New conversation".to_string());

    let autopilot = state
        ._domain_store
        .resolve_owned_autopilot(&bundle.user.id, &reference)
        .await
        .map_err(map_domain_store_error)?;
    let thread_id = format!("thread_{}", uuid::Uuid::new_v4().simple());
    let thread = state
        .codex_thread_store
        .create_autopilot_thread_for_user(
            &bundle.user.id,
            &bundle.session.active_org_id,
            &thread_id,
            &autopilot.autopilot.id,
            &title,
        )
        .await
        .map_err(map_thread_store_error)?;

    state.observability.audit(
        AuditEvent::new("autopilot.thread_created", request_id.clone())
            .with_user_id(bundle.user.id)
            .with_session_id(bundle.session.session_id)
            .with_org_id(bundle.session.active_org_id)
            .with_device_id(bundle.session.device_id)
            .with_attribute("autopilot_id", autopilot.autopilot.id.clone())
            .with_attribute("thread_id", thread.id.clone())
            .with_attribute("title_length", thread.title.chars().count().to_string()),
    );
    state
        .observability
        .increment_counter("autopilot.thread_created", &request_id);

    Ok((
        StatusCode::CREATED,
        Json(serde_json::json!({
            "data": autopilot_thread_payload(&thread),
        })),
    ))
}

async fn list_autopilot_threads(
    State(state): State<AppState>,
    Path(autopilot): Path<String>,
    headers: HeaderMap,
    Query(query): Query<AutopilotThreadListQuery>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let reference = normalize_autopilot_reference(autopilot)?;

    let autopilot = state
        ._domain_store
        .resolve_owned_autopilot(&bundle.user.id, &reference)
        .await
        .map_err(map_domain_store_error)?;

    let limit = query.limit.unwrap_or(50).clamp(1, 200);
    let mut threads = state
        .codex_thread_store
        .list_autopilot_threads_for_user(
            &bundle.user.id,
            Some(&bundle.session.active_org_id),
            &autopilot.autopilot.id,
        )
        .await
        .map_err(map_thread_store_error)?;
    threads.truncate(limit);

    state.observability.audit(
        AuditEvent::new("autopilot.threads_viewed", request_id.clone())
            .with_user_id(bundle.user.id)
            .with_session_id(bundle.session.session_id)
            .with_org_id(bundle.session.active_org_id)
            .with_device_id(bundle.session.device_id)
            .with_attribute("autopilot_id", autopilot.autopilot.id.clone())
            .with_attribute("limit", limit.to_string())
            .with_attribute("count", threads.len().to_string()),
    );
    state
        .observability
        .increment_counter("autopilot.threads_viewed", &request_id);

    Ok((
        StatusCode::OK,
        Json(serde_json::json!({
            "data": threads
                .iter()
                .map(autopilot_thread_payload)
                .collect::<Vec<_>>(),
        })),
    ))
}

async fn autopilot_stream(
    State(state): State<AppState>,
    Path(autopilot): Path<String>,
    headers: HeaderMap,
    Query(query): Query<AutopilotStreamQuery>,
    Json(payload): Json<serde_json::Value>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let reference = normalize_autopilot_reference(autopilot)?;
    let autopilot = state
        ._domain_store
        .resolve_owned_autopilot(&bundle.user.id, &reference)
        .await
        .map_err(map_domain_store_error)?;
    let autopilot_id = autopilot.autopilot.id.clone();
    let autopilot_config_version = autopilot.autopilot.config_version;
    let prompt_context = autopilot_prompt_context(&autopilot);
    let tool_policy_audit = autopilot_tool_resolution_audit(&autopilot, true);
    let runtime_binding_payload = autopilot_runtime_binding_payload(&autopilot);
    let runtime_binding_worker_id = autopilot_runtime_binding_worker_ref(&autopilot);

    let requested_thread_id = query
        .conversation_id
        .and_then(non_empty)
        .or_else(|| query.thread_id.and_then(non_empty))
        .or_else(|| autopilot_stream_thread_id_from_payload(&payload));

    let thread = match requested_thread_id {
        Some(thread_id) => {
            let normalized_thread_id = normalized_conversation_id(&thread_id)?;
            let _existing = state
                .codex_thread_store
                .get_thread_for_user(&bundle.user.id, &normalized_thread_id)
                .await
                .map_err(map_autopilot_stream_thread_error)?;
            state
                .codex_thread_store
                .create_autopilot_thread_for_user(
                    &bundle.user.id,
                    &bundle.session.active_org_id,
                    &normalized_thread_id,
                    &autopilot_id,
                    "Autopilot conversation",
                )
                .await
                .map_err(map_autopilot_stream_thread_error)?
        }
        None => {
            let thread_id = format!("thread_{}", uuid::Uuid::new_v4().simple());
            state
                .codex_thread_store
                .create_autopilot_thread_for_user(
                    &bundle.user.id,
                    &bundle.session.active_org_id,
                    &thread_id,
                    &autopilot_id,
                    "Autopilot conversation",
                )
                .await
                .map_err(map_thread_store_error)?
        }
    };

    let text = legacy_stream_user_text_from_payload(&payload).ok_or_else(|| {
        validation_error(
            "messages",
            "Autopilot stream payload must include user message text.",
        )
    })?;
    validate_codex_turn_text(&text)?;

    let worker_id = legacy_stream_worker_id_from_payload(&payload)
        .or(runtime_binding_worker_id)
        .unwrap_or_else(|| "desktopw:shared".to_string());
    let thread_id = thread.id.clone();
    let control_request_id = format!("autopilot_stream_{}", uuid::Uuid::new_v4().simple());
    let control_request = RuntimeCodexWorkerControlRequest {
        request_id: control_request_id.clone(),
        method: "turn/start".to_string(),
        params: serde_json::json!({
            "thread_id": thread_id.clone(),
            "text": text,
            "autopilot_id": autopilot_id.clone(),
            "autopilot_config_version": autopilot_config_version,
        }),
        request_version: Some("v1".to_string()),
        source: Some("autopilot_stream_alias".to_string()),
        session_id: Some(bundle.session.session_id.clone()),
        thread_id: Some(thread_id.clone()),
    };
    let control_response =
        execute_codex_control_request(&state, &bundle, "turn/start", &control_request).await?;

    let worker_events_topic = org_worker_events_topic(&bundle.session.active_org_id);
    state.observability.audit(
        AuditEvent::new("autopilot.stream.bootstrap.accepted", request_id.clone())
            .with_user_id(bundle.user.id.clone())
            .with_session_id(bundle.session.session_id.clone())
            .with_org_id(bundle.session.active_org_id.clone())
            .with_device_id(bundle.session.device_id.clone())
            .with_attribute("autopilot_id", autopilot_id.clone())
            .with_attribute("thread_id", thread_id.clone())
            .with_attribute("worker_id", worker_id.clone())
            .with_attribute("method", "turn/start".to_string())
            .with_attribute(
                "policy_applied",
                tool_policy_audit["policyApplied"]
                    .as_bool()
                    .unwrap_or(false)
                    .to_string(),
            )
            .with_attribute("transport", "khala_ws".to_string()),
    );
    state
        .observability
        .increment_counter("autopilot.stream.bootstrap.accepted", &request_id);

    Ok(ok_data(serde_json::json!({
        "accepted": true,
        "autopilotId": autopilot_id,
        "autopilotConfigVersion": autopilot_config_version,
        "threadId": thread_id.clone(),
        "conversationId": thread_id,
        "streamProtocol": "disabled",
        "promptContext": prompt_context,
        "toolPolicy": tool_policy_audit,
        "runtimeBinding": runtime_binding_payload,
        "delivery": {
            "transport": "khala_ws",
            "topic": worker_events_topic,
            "scope": "runtime.codex_worker_events",
            "syncTokenRoute": ROUTE_SYNC_TOKEN,
        },
        "control": {
            "method": "turn/start",
            "workerId": worker_id,
            "requestId": control_request_id,
        },
        "response": control_response,
    })))
}

async fn settings_profile_show(
    State(state): State<AppState>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let access_token = access_token_from_headers(&headers)
        .ok_or_else(|| unauthorized_error("Unauthenticated."))?;

    let bundle = state
        .auth
        .session_or_pat_from_access_token(&access_token)
        .await
        .map_err(map_auth_error)?;

    state.observability.audit(
        AuditEvent::new("profile.read", request_id.clone())
            .with_user_id(bundle.user.id.clone())
            .with_session_id(bundle.session.session_id.clone())
            .with_org_id(bundle.session.active_org_id.clone())
            .with_device_id(bundle.session.device_id.clone()),
    );
    state
        .observability
        .increment_counter("profile.read", &request_id);

    Ok((
        StatusCode::OK,
        Json(serde_json::json!({
            "data": {
                "id": bundle.user.id,
                "name": bundle.user.name,
                "email": bundle.user.email,
                "avatar": "",
                "createdAt": serde_json::Value::Null,
                "updatedAt": serde_json::Value::Null,
            }
        })),
    ))
}

async fn settings_profile_update(
    State(state): State<AppState>,
    headers: HeaderMap,
    Json(payload): Json<UpdateProfileRequestPayload>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let access_token = access_token_from_headers(&headers)
        .ok_or_else(|| unauthorized_error("Unauthenticated."))?;

    let bundle = state
        .auth
        .session_or_pat_from_access_token(&access_token)
        .await
        .map_err(map_auth_error)?;

    let normalized_name = payload.name.trim().to_string();
    if normalized_name.is_empty() {
        return Err(validation_error("name", "The name field is required."));
    }
    if normalized_name.chars().count() > 255 {
        return Err(validation_error(
            "name",
            "The name field may not be greater than 255 characters.",
        ));
    }

    let updated_user = state
        .auth
        .update_profile_name(&bundle.user.id, normalized_name)
        .await
        .map_err(map_auth_error)?;

    let updated_at = timestamp(Utc::now());
    state.observability.audit(
        AuditEvent::new("profile.updated", request_id.clone())
            .with_user_id(updated_user.id.clone())
            .with_session_id(bundle.session.session_id.clone())
            .with_org_id(bundle.session.active_org_id.clone())
            .with_device_id(bundle.session.device_id.clone())
            .with_attribute("field_updated", "name".to_string())
            .with_attribute("source", "api".to_string()),
    );
    state
        .observability
        .increment_counter("profile.updated", &request_id);

    Ok((
        StatusCode::OK,
        Json(serde_json::json!({
            "data": {
                "id": updated_user.id,
                "name": updated_user.name,
                "email": updated_user.email,
                "avatar": "",
                "updatedAt": updated_at,
            }
        })),
    ))
}

async fn settings_autopilot_update(
    State(state): State<AppState>,
    headers: HeaderMap,
    Json(payload): Json<UpdateSettingsAutopilotRequestPayload>,
) -> Result<Response, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;

    let display_name =
        normalize_optional_bounded_trimmed_string(payload.display_name, "displayName", 120)?;
    let tagline = normalize_optional_bounded_trimmed_string(payload.tagline, "tagline", 255)?;
    let owner_display_name = normalize_optional_bounded_trimmed_string(
        payload.owner_display_name,
        "ownerDisplayName",
        120,
    )?;
    let persona_summary = payload
        .persona_summary
        .map(|value| value.trim().to_string());
    let autopilot_voice =
        normalize_optional_bounded_trimmed_string(payload.autopilot_voice, "autopilotVoice", 64)?;
    let principles = split_principles_text(payload.principles_text);

    let autopilot = match state
        ._domain_store
        .list_autopilots_for_owner(&bundle.user.id, 1)
        .await
        .map_err(map_domain_store_error)?
        .into_iter()
        .next()
    {
        Some(existing) => existing,
        None => {
            let create_display_name = display_name.clone().unwrap_or_else(|| {
                let owner_name = bundle.user.name.trim();
                if owner_name.is_empty() {
                    "Autopilot".to_string()
                } else {
                    format!("{owner_name} Autopilot")
                }
            });

            state
                ._domain_store
                .create_autopilot(CreateAutopilotInput {
                    owner_user_id: bundle.user.id.clone(),
                    owner_display_name: bundle.user.name.clone(),
                    display_name: create_display_name,
                    handle_seed: None,
                    avatar: None,
                    status: Some("active".to_string()),
                    visibility: Some("private".to_string()),
                    tagline: None,
                })
                .await
                .map_err(map_domain_store_error)?
        }
    };

    let effective_display_name =
        display_name.unwrap_or_else(|| autopilot.autopilot.display_name.clone());
    let effective_tagline =
        tagline.unwrap_or_else(|| autopilot.autopilot.tagline.clone().unwrap_or_default());
    let effective_owner_display_name =
        owner_display_name.unwrap_or_else(|| bundle.user.name.clone());
    let effective_persona_summary = persona_summary.unwrap_or_default();
    let effective_autopilot_voice = autopilot_voice.unwrap_or_default();

    let updated = state
        ._domain_store
        .update_owned_autopilot(
            &bundle.user.id,
            &autopilot.autopilot.id,
            UpdateAutopilotInput {
                display_name: Some(effective_display_name),
                tagline: Some(effective_tagline),
                profile: Some(UpsertAutopilotProfileInput {
                    owner_display_name: Some(effective_owner_display_name),
                    persona_summary: Some(effective_persona_summary),
                    autopilot_voice: Some(effective_autopilot_voice),
                    principles: Some(serde_json::Value::Array(
                        principles
                            .into_iter()
                            .map(serde_json::Value::String)
                            .collect(),
                    )),
                    ..UpsertAutopilotProfileInput::default()
                }),
                ..UpdateAutopilotInput::default()
            },
        )
        .await
        .map_err(map_domain_store_error)?;

    state.observability.audit(
        AuditEvent::new("settings.autopilot.updated", request_id.clone())
            .with_user_id(bundle.user.id.clone())
            .with_session_id(bundle.session.session_id.clone())
            .with_org_id(bundle.session.active_org_id.clone())
            .with_device_id(bundle.session.device_id.clone())
            .with_attribute("autopilot_id", updated.autopilot.id.clone())
            .with_attribute("source", "settings_profile".to_string()),
    );
    state
        .observability
        .increment_counter("settings.autopilot.updated", &request_id);

    Ok((
        StatusCode::OK,
        Json(serde_json::json!({
            "data": {
                "status": "autopilot-updated",
                "autopilot": autopilot_aggregate_payload(&updated),
            }
        })),
    )
        .into_response())
}

async fn settings_integrations_resend_upsert(
    State(state): State<AppState>,
    headers: HeaderMap,
    Json(payload): Json<UpsertResendIntegrationRequestPayload>,
) -> Result<Response, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let api_key = payload.resend_api_key.and_then(non_empty).ok_or_else(|| {
        validation_error("resend_api_key", "The resend_api_key field is required.")
    })?;
    let api_key_len = api_key.chars().count();
    if api_key_len < 8 {
        return Err(validation_error(
            "resend_api_key",
            "The resend_api_key field must be at least 8 characters.",
        ));
    }
    if api_key_len > 4096 {
        return Err(validation_error(
            "resend_api_key",
            "The resend_api_key field may not be greater than 4096 characters.",
        ));
    }
    let sender_email = normalize_optional_email(payload.sender_email, "sender_email")?;
    let sender_name =
        normalize_optional_bounded_trimmed_string(payload.sender_name, "sender_name", 255)?;

    let result = state
        ._domain_store
        .upsert_resend_integration(UpsertResendIntegrationInput {
            user_id: bundle.user.id.clone(),
            api_key,
            sender_email,
            sender_name,
        })
        .await
        .map_err(map_domain_store_error)?;
    let status = match result.action.as_str() {
        "secret_created" => "resend-connected",
        "secret_rotated" => "resend-rotated",
        _ => "resend-updated",
    };

    state.observability.audit(
        AuditEvent::new("settings.integrations.resend.upserted", request_id.clone())
            .with_user_id(bundle.user.id)
            .with_session_id(bundle.session.session_id)
            .with_org_id(bundle.session.active_org_id)
            .with_device_id(bundle.session.device_id)
            .with_attribute("action", result.action.clone())
            .with_attribute("status", status.to_string()),
    );
    state
        .observability
        .increment_counter("settings.integrations.resend.upserted", &request_id);

    let integration = integration_payload(Some(&result.integration), "resend");
    Ok(settings_integration_response(
        &headers,
        status,
        Some(result.action),
        integration,
    ))
}

async fn settings_integrations_resend_disconnect(
    State(state): State<AppState>,
    headers: HeaderMap,
) -> Result<Response, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let revoked = state
        ._domain_store
        .revoke_integration(&bundle.user.id, "resend")
        .await
        .map_err(map_domain_store_error)?;

    state.observability.audit(
        AuditEvent::new(
            "settings.integrations.resend.disconnected",
            request_id.clone(),
        )
        .with_user_id(bundle.user.id)
        .with_session_id(bundle.session.session_id)
        .with_org_id(bundle.session.active_org_id)
        .with_device_id(bundle.session.device_id)
        .with_attribute("had_integration", revoked.is_some().to_string()),
    );
    state
        .observability
        .increment_counter("settings.integrations.resend.disconnected", &request_id);

    Ok(settings_integration_response(
        &headers,
        "resend-disconnected",
        Some("secret_revoked".to_string()),
        integration_payload(revoked.as_ref(), "resend"),
    ))
}

async fn settings_integrations_resend_test(
    State(state): State<AppState>,
    headers: HeaderMap,
) -> Result<Response, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let integration = state
        ._domain_store
        .find_active_integration_secret(&bundle.user.id, "resend")
        .await
        .map_err(map_domain_store_error)?
        .ok_or_else(|| {
            validation_error(
                "resend",
                "Connect an active Resend key before running a test.",
            )
        })?;

    state
        ._domain_store
        .audit_integration_test_request(&bundle.user.id, "resend")
        .await
        .map_err(map_domain_store_error)?;

    state.observability.audit(
        AuditEvent::new(
            "settings.integrations.resend.test_requested",
            request_id.clone(),
        )
        .with_user_id(bundle.user.id)
        .with_session_id(bundle.session.session_id)
        .with_org_id(bundle.session.active_org_id)
        .with_device_id(bundle.session.device_id)
        .with_attribute("integration_id", integration.id.to_string()),
    );
    state
        .observability
        .increment_counter("settings.integrations.resend.test_requested", &request_id);

    Ok(settings_integration_response(
        &headers,
        "resend-test-queued",
        Some("test_requested".to_string()),
        integration_payload(Some(&integration), "resend"),
    ))
}

async fn settings_integrations_google_redirect(
    State(state): State<AppState>,
    headers: HeaderMap,
) -> Result<Response, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;

    let client_id = state
        .config
        .google_oauth_client_id
        .clone()
        .filter(|value| !value.trim().is_empty());
    let redirect_uri = state
        .config
        .google_oauth_redirect_uri
        .clone()
        .filter(|value| !value.trim().is_empty());
    let scopes = state.config.google_oauth_scopes.trim().to_string();
    if client_id.is_none() || redirect_uri.is_none() || scopes.is_empty() {
        return Err(validation_error(
            "google",
            "Google OAuth is not configured on this environment.",
        ));
    }

    let oauth_state = format!("{}{}", Uuid::new_v4().simple(), Uuid::new_v4().simple());
    {
        let mut entries = state.google_oauth_states.entries.lock().await;
        entries.insert(bundle.user.id.clone(), oauth_state.clone());
    }

    let mut redirect = reqwest::Url::parse("https://accounts.google.com/o/oauth2/v2/auth")
        .expect("hardcoded Google OAuth authorize URL must be valid");
    redirect
        .query_pairs_mut()
        .append_pair("client_id", client_id.as_deref().unwrap_or_default())
        .append_pair("redirect_uri", redirect_uri.as_deref().unwrap_or_default())
        .append_pair("response_type", "code")
        .append_pair("access_type", "offline")
        .append_pair("prompt", "consent")
        .append_pair("scope", &scopes)
        .append_pair("state", &oauth_state);

    state.observability.audit(
        AuditEvent::new(
            "settings.integrations.google.redirected",
            request_id.clone(),
        )
        .with_user_id(bundle.user.id)
        .with_session_id(bundle.session.session_id)
        .with_org_id(bundle.session.active_org_id)
        .with_device_id(bundle.session.device_id),
    );
    state
        .observability
        .increment_counter("settings.integrations.google.redirected", &request_id);

    Ok(Redirect::to(redirect.as_ref()).into_response())
}

async fn settings_integrations_google_callback(
    State(state): State<AppState>,
    headers: HeaderMap,
    Query(query): Query<GoogleOauthCallbackQuery>,
) -> Result<Response, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;

    if let Some(error) = query.error.and_then(non_empty) {
        return Err(validation_error(
            "google",
            &format!("Google authorization failed: {error}"),
        ));
    }

    let incoming_state = query.state.and_then(non_empty).ok_or_else(|| {
        validation_error(
            "google",
            "OAuth state mismatch. Please retry connecting Google.",
        )
    })?;
    let expected_state = {
        let mut entries = state.google_oauth_states.entries.lock().await;
        entries.remove(&bundle.user.id)
    }
    .unwrap_or_default();
    if expected_state.is_empty() || expected_state != incoming_state {
        return Err(validation_error(
            "google",
            "OAuth state mismatch. Please retry connecting Google.",
        ));
    }

    let code = query.code.and_then(non_empty).ok_or_else(|| {
        validation_error(
            "google",
            "Google callback did not include an authorization code.",
        )
    })?;

    let client_id = state
        .config
        .google_oauth_client_id
        .clone()
        .filter(|value| !value.trim().is_empty());
    let client_secret = state
        .config
        .google_oauth_client_secret
        .clone()
        .filter(|value| !value.trim().is_empty());
    let redirect_uri = state
        .config
        .google_oauth_redirect_uri
        .clone()
        .filter(|value| !value.trim().is_empty());
    if client_id.is_none() || client_secret.is_none() || redirect_uri.is_none() {
        return Err(validation_error(
            "google",
            "Google OAuth is not configured on this environment.",
        ));
    }

    let response = reqwest::Client::new()
        .post(state.config.google_oauth_token_url.clone())
        .header("accept", "application/json")
        .form(&[
            ("code", code.as_str()),
            ("client_id", client_id.as_deref().unwrap_or_default()),
            (
                "client_secret",
                client_secret.as_deref().unwrap_or_default(),
            ),
            ("redirect_uri", redirect_uri.as_deref().unwrap_or_default()),
            ("grant_type", "authorization_code"),
        ])
        .timeout(std::time::Duration::from_secs(15))
        .send()
        .await
        .map_err(|_| {
            validation_error(
                "google",
                "Google token exchange failed. Please reconnect and try again.",
            )
        })?;
    if !response.status().is_success() {
        return Err(validation_error(
            "google",
            "Google token exchange failed. Please reconnect and try again.",
        ));
    }

    let token_payload = response.json::<serde_json::Value>().await.map_err(|_| {
        validation_error(
            "google",
            "Google token exchange returned an invalid payload.",
        )
    })?;
    if !token_payload.is_object() {
        return Err(validation_error(
            "google",
            "Google token exchange returned an invalid payload.",
        ));
    }

    let result = state
        ._domain_store
        .upsert_google_integration(UpsertGoogleIntegrationInput {
            user_id: bundle.user.id.clone(),
            refresh_token: normalized_json_string(token_payload.get("refresh_token")),
            access_token: normalized_json_string(token_payload.get("access_token")),
            scope: normalized_json_string(token_payload.get("scope")),
            token_type: normalized_json_string(token_payload.get("token_type")),
            expires_at: resolve_google_token_expiry(&token_payload),
        })
        .await
        .map_err(map_domain_store_error)?;
    let status = match result.action.as_str() {
        "secret_created" => "google-connected",
        "secret_rotated" => "google-rotated",
        _ => "google-updated",
    };

    state.observability.audit(
        AuditEvent::new(
            "settings.integrations.google.callback.completed",
            request_id.clone(),
        )
        .with_user_id(bundle.user.id)
        .with_session_id(bundle.session.session_id)
        .with_org_id(bundle.session.active_org_id)
        .with_device_id(bundle.session.device_id)
        .with_attribute("action", result.action.clone())
        .with_attribute("status", status.to_string()),
    );
    state.observability.increment_counter(
        "settings.integrations.google.callback.completed",
        &request_id,
    );

    Ok(Redirect::to(&format!("/settings/integrations?status={status}")).into_response())
}

async fn settings_integrations_google_disconnect(
    State(state): State<AppState>,
    headers: HeaderMap,
) -> Result<Response, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let revoked = state
        ._domain_store
        .revoke_integration(&bundle.user.id, "google")
        .await
        .map_err(map_domain_store_error)?;

    state.observability.audit(
        AuditEvent::new(
            "settings.integrations.google.disconnected",
            request_id.clone(),
        )
        .with_user_id(bundle.user.id)
        .with_session_id(bundle.session.session_id)
        .with_org_id(bundle.session.active_org_id)
        .with_device_id(bundle.session.device_id)
        .with_attribute("had_integration", revoked.is_some().to_string()),
    );
    state
        .observability
        .increment_counter("settings.integrations.google.disconnected", &request_id);

    Ok(settings_integration_response(
        &headers,
        "google-disconnected",
        Some("secret_revoked".to_string()),
        integration_payload(revoked.as_ref(), "google"),
    ))
}

async fn inbox_threads_index(
    State(state): State<AppState>,
    headers: HeaderMap,
    Query(query): Query<InboxThreadsQuery>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let limit = parse_inbox_limit(query.limit.as_deref())?;
    let snapshot = inbox_snapshot_for_user(&state, &bundle.user.id, limit, &request_id).await?;

    state.observability.audit(
        AuditEvent::new("inbox.threads.listed", request_id.clone())
            .with_user_id(bundle.user.id.clone())
            .with_session_id(bundle.session.session_id.clone())
            .with_org_id(bundle.session.active_org_id.clone())
            .with_device_id(bundle.session.device_id.clone())
            .with_attribute("thread_count", snapshot.threads.len().to_string()),
    );
    state
        .observability
        .increment_counter("inbox.threads.listed", &request_id);

    Ok(ok_data(InboxSnapshotEnvelope {
        request_id,
        source: "threads".to_string(),
        snapshot,
    }))
}

async fn inbox_refresh(
    State(state): State<AppState>,
    headers: HeaderMap,
    Json(payload): Json<InboxRefreshRequestPayload>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let limit = payload.limit.unwrap_or(20).clamp(1, 100) as usize;
    let snapshot = inbox_snapshot_for_user(&state, &bundle.user.id, limit, &request_id).await?;

    state
        ._domain_store
        .record_inbox_audit(RecordInboxAuditInput {
            user_id: bundle.user.id.clone(),
            thread_id: "system".to_string(),
            action: "refresh".to_string(),
            detail: format!("gmail inbox refreshed ({} threads)", snapshot.threads.len()),
        })
        .await
        .map_err(map_domain_store_error)?;

    state.observability.audit(
        AuditEvent::new("inbox.refreshed", request_id.clone())
            .with_user_id(bundle.user.id.clone())
            .with_session_id(bundle.session.session_id.clone())
            .with_org_id(bundle.session.active_org_id.clone())
            .with_device_id(bundle.session.device_id.clone())
            .with_attribute("thread_count", snapshot.threads.len().to_string()),
    );
    state
        .observability
        .increment_counter("inbox.refreshed", &request_id);

    Ok(ok_data(InboxSnapshotEnvelope {
        request_id,
        source: "refresh".to_string(),
        snapshot,
    }))
}

async fn inbox_thread_detail(
    State(state): State<AppState>,
    headers: HeaderMap,
    Path(thread_id): Path<String>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let thread_id = normalize_optional_bounded_string(Some(thread_id), "thread_id", 255)?
        .ok_or_else(|| validation_error("thread_id", "The thread_id field is required."))?;

    let detail =
        inbox_thread_detail_for_user(&state, &bundle.user.id, &thread_id, &request_id).await?;

    state
        ._domain_store
        .record_inbox_audit(RecordInboxAuditInput {
            user_id: bundle.user.id.clone(),
            thread_id: thread_id.clone(),
            action: "select_thread".to_string(),
            detail: "thread detail loaded".to_string(),
        })
        .await
        .map_err(map_domain_store_error)?;

    state.observability.audit(
        AuditEvent::new("inbox.thread.viewed", request_id.clone())
            .with_user_id(bundle.user.id.clone())
            .with_session_id(bundle.session.session_id.clone())
            .with_org_id(bundle.session.active_org_id.clone())
            .with_device_id(bundle.session.device_id.clone())
            .with_attribute("thread_id", thread_id.clone()),
    );
    state
        .observability
        .increment_counter("inbox.thread.viewed", &request_id);

    Ok(ok_data(detail))
}

async fn inbox_thread_approve(
    State(state): State<AppState>,
    headers: HeaderMap,
    Path(thread_id): Path<String>,
    Json(payload): Json<InboxDraftActionRequestPayload>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let thread_id = normalize_optional_bounded_string(Some(thread_id), "thread_id", 255)?
        .ok_or_else(|| validation_error("thread_id", "The thread_id field is required."))?;

    let existing = state
        ._domain_store
        .inbox_thread_state(&bundle.user.id, &thread_id)
        .await
        .map_err(map_domain_store_error)?;
    let draft_preview = existing.as_ref().and_then(|row| row.draft_preview.clone());

    state
        ._domain_store
        .upsert_inbox_thread_state(UpsertInboxThreadStateInput {
            user_id: bundle.user.id.clone(),
            thread_id: thread_id.clone(),
            pending_approval: false,
            decision: Some("approved".to_string()),
            draft_preview,
            source: Some("inbox_api.approve".to_string()),
        })
        .await
        .map_err(map_domain_store_error)?;
    state
        ._domain_store
        .record_inbox_audit(RecordInboxAuditInput {
            user_id: bundle.user.id.clone(),
            thread_id: thread_id.clone(),
            action: "approve_draft".to_string(),
            detail: payload
                .detail
                .and_then(non_empty)
                .unwrap_or_else(|| "draft approved".to_string()),
        })
        .await
        .map_err(map_domain_store_error)?;

    let snapshot = inbox_snapshot_for_user(&state, &bundle.user.id, 20, &request_id).await?;

    state.observability.audit(
        AuditEvent::new("inbox.draft.approved", request_id.clone())
            .with_user_id(bundle.user.id.clone())
            .with_session_id(bundle.session.session_id.clone())
            .with_org_id(bundle.session.active_org_id.clone())
            .with_device_id(bundle.session.device_id.clone())
            .with_attribute("thread_id", thread_id),
    );
    state
        .observability
        .increment_counter("inbox.draft.approved", &request_id);

    Ok(ok_data(InboxSnapshotEnvelope {
        request_id,
        source: "approve_draft".to_string(),
        snapshot,
    }))
}

async fn inbox_thread_reject(
    State(state): State<AppState>,
    headers: HeaderMap,
    Path(thread_id): Path<String>,
    Json(payload): Json<InboxDraftActionRequestPayload>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let thread_id = normalize_optional_bounded_string(Some(thread_id), "thread_id", 255)?
        .ok_or_else(|| validation_error("thread_id", "The thread_id field is required."))?;

    let existing = state
        ._domain_store
        .inbox_thread_state(&bundle.user.id, &thread_id)
        .await
        .map_err(map_domain_store_error)?;
    let draft_preview = existing.as_ref().and_then(|row| row.draft_preview.clone());

    state
        ._domain_store
        .upsert_inbox_thread_state(UpsertInboxThreadStateInput {
            user_id: bundle.user.id.clone(),
            thread_id: thread_id.clone(),
            pending_approval: true,
            decision: Some("rejected".to_string()),
            draft_preview,
            source: Some("inbox_api.reject".to_string()),
        })
        .await
        .map_err(map_domain_store_error)?;
    state
        ._domain_store
        .record_inbox_audit(RecordInboxAuditInput {
            user_id: bundle.user.id.clone(),
            thread_id: thread_id.clone(),
            action: "reject_draft".to_string(),
            detail: payload
                .detail
                .and_then(non_empty)
                .unwrap_or_else(|| "draft rejected for manual revision".to_string()),
        })
        .await
        .map_err(map_domain_store_error)?;

    let snapshot = inbox_snapshot_for_user(&state, &bundle.user.id, 20, &request_id).await?;

    state.observability.audit(
        AuditEvent::new("inbox.draft.rejected", request_id.clone())
            .with_user_id(bundle.user.id.clone())
            .with_session_id(bundle.session.session_id.clone())
            .with_org_id(bundle.session.active_org_id.clone())
            .with_device_id(bundle.session.device_id.clone())
            .with_attribute("thread_id", thread_id),
    );
    state
        .observability
        .increment_counter("inbox.draft.rejected", &request_id);

    Ok(ok_data(InboxSnapshotEnvelope {
        request_id,
        source: "reject_draft".to_string(),
        snapshot,
    }))
}

async fn inbox_thread_reply_send(
    State(state): State<AppState>,
    headers: HeaderMap,
    Path(thread_id): Path<String>,
    Json(payload): Json<InboxSendReplyRequestPayload>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let thread_id = normalize_optional_bounded_string(Some(thread_id), "thread_id", 255)?
        .ok_or_else(|| validation_error("thread_id", "The thread_id field is required."))?;

    let detail =
        inbox_thread_detail_for_user(&state, &bundle.user.id, &thread_id, &request_id).await?;
    let latest_message = detail.messages.last().cloned().ok_or_else(|| {
        validation_error(
            "thread_id",
            "Inbox thread has no messages and cannot be replied to.",
        )
    })?;

    let to_header = latest_message
        .from
        .as_deref()
        .and_then(|value| non_empty(value.to_string()))
        .ok_or_else(|| validation_error("thread_id", "Could not resolve recipient from thread."))?;
    let to_address = normalize_reply_recipient(to_header.as_str())
        .ok_or_else(|| validation_error("thread_id", "Could not resolve recipient from thread."))?;

    let draft_body = payload
        .body
        .and_then(non_empty)
        .or_else(|| {
            if detail.thread.draft_preview.trim().is_empty() {
                None
            } else {
                Some(detail.thread.draft_preview.clone())
            }
        })
        .ok_or_else(|| validation_error("body", "Reply body is required to send this thread."))?;

    let subject = normalize_reply_subject(
        latest_message
            .subject
            .as_deref()
            .unwrap_or(detail.thread.subject.as_str()),
    );
    let in_reply_to = if latest_message.id.trim().is_empty() {
        None
    } else {
        Some(format!("<{}>", latest_message.id))
    };

    let mut raw_lines = vec![
        format!("To: {to_address}"),
        format!("Subject: {subject}"),
        "MIME-Version: 1.0".to_string(),
        "Content-Type: text/plain; charset=UTF-8".to_string(),
    ];
    if let Some(message_id) = in_reply_to.as_ref() {
        raw_lines.push(format!("In-Reply-To: {message_id}"));
        raw_lines.push(format!("References: {message_id}"));
    }
    raw_lines.push(String::new());
    raw_lines.push(draft_body.clone());
    let raw = URL_SAFE_NO_PAD.encode(raw_lines.join("\r\n"));

    let send_payload = serde_json::json!({
        "threadId": thread_id,
        "raw": raw,
    });
    let send_url = format!(
        "{}/gmail/v1/users/me/messages/send",
        google_gmail_api_base_url(state.config.as_ref())
    );
    let response = gmail_json_request(
        &state,
        &bundle.user.id,
        reqwest::Method::POST,
        send_url.as_str(),
        Some(send_payload),
        &request_id,
    )
    .await?;
    let message_id = normalized_json_string(response.get("id"))
        .unwrap_or_else(|| format!("msg_{}", Uuid::new_v4().simple()));

    state
        ._domain_store
        .upsert_inbox_thread_state(UpsertInboxThreadStateInput {
            user_id: bundle.user.id.clone(),
            thread_id: thread_id.clone(),
            pending_approval: false,
            decision: Some("sent".to_string()),
            draft_preview: Some(draft_body),
            source: Some("inbox_api.send".to_string()),
        })
        .await
        .map_err(map_domain_store_error)?;
    state
        ._domain_store
        .record_inbox_audit(RecordInboxAuditInput {
            user_id: bundle.user.id.clone(),
            thread_id: thread_id.clone(),
            action: "send_reply".to_string(),
            detail: format!("reply sent to {to_address} ({message_id})"),
        })
        .await
        .map_err(map_domain_store_error)?;

    state.observability.audit(
        AuditEvent::new("inbox.reply.sent", request_id.clone())
            .with_user_id(bundle.user.id.clone())
            .with_session_id(bundle.session.session_id.clone())
            .with_org_id(bundle.session.active_org_id.clone())
            .with_device_id(bundle.session.device_id.clone())
            .with_attribute("thread_id", thread_id.clone())
            .with_attribute("message_id", message_id.clone()),
    );
    state
        .observability
        .increment_counter("inbox.reply.sent", &request_id);

    Ok(ok_data(InboxReplySendResponse {
        request_id,
        thread_id,
        message_id,
        status: "sent".to_string(),
    }))
}

async fn inbox_snapshot_for_user(
    state: &AppState,
    user_id: &str,
    limit: usize,
    request_id: &str,
) -> Result<InboxSnapshot, (StatusCode, Json<ApiErrorResponse>)> {
    let thread_rows = gmail_thread_summaries_for_user(state, user_id, limit, request_id).await?;
    let audit_rows = state
        ._domain_store
        .list_inbox_audits_for_user(user_id, None, 200)
        .await
        .map_err(map_domain_store_error)?;
    let audit_log = audit_rows
        .into_iter()
        .map(|entry| InboxAuditEntry {
            thread_id: entry.thread_id,
            action: entry.action,
            detail: entry.detail,
            created_at: timestamp(entry.created_at),
        })
        .collect::<Vec<_>>();

    Ok(InboxSnapshot {
        selected_thread_id: thread_rows.first().map(|row| row.id.clone()),
        threads: thread_rows,
        audit_log,
    })
}

async fn inbox_thread_detail_for_user(
    state: &AppState,
    user_id: &str,
    thread_id: &str,
    request_id: &str,
) -> Result<InboxThreadDetailResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let gmail_thread = gmail_fetch_thread_for_user(state, user_id, thread_id, request_id).await?;
    let persisted = state
        ._domain_store
        .inbox_thread_state(user_id, thread_id)
        .await
        .map_err(map_domain_store_error)?;
    let summary = inbox_summary_from_gmail_thread(thread_id, &gmail_thread, persisted.as_ref());
    let audit_rows = state
        ._domain_store
        .list_inbox_audits_for_user(user_id, Some(thread_id), 100)
        .await
        .map_err(map_domain_store_error)?;
    let audit_log = audit_rows
        .into_iter()
        .map(|entry| InboxAuditEntry {
            thread_id: entry.thread_id,
            action: entry.action,
            detail: entry.detail,
            created_at: timestamp(entry.created_at),
        })
        .collect::<Vec<_>>();
    let messages = gmail_thread
        .messages
        .iter()
        .map(inbox_message_from_gmail)
        .collect::<Vec<_>>();

    Ok(InboxThreadDetailResponse {
        request_id: request_id.to_string(),
        thread_id: thread_id.to_string(),
        thread: summary,
        messages,
        audit_log,
    })
}

async fn gmail_thread_summaries_for_user(
    state: &AppState,
    user_id: &str,
    limit: usize,
    request_id: &str,
) -> Result<Vec<InboxThreadSummary>, (StatusCode, Json<ApiErrorResponse>)> {
    let base_url = google_gmail_api_base_url(state.config.as_ref());
    let list_url = format!(
        "{base_url}/gmail/v1/users/me/threads?maxResults={}",
        limit.clamp(1, 100)
    );
    let response = gmail_json_request(
        state,
        user_id,
        reqwest::Method::GET,
        list_url.as_str(),
        None,
        request_id,
    )
    .await?;
    let list = serde_json::from_value::<GmailThreadListResponse>(response).map_err(|_| {
        error_response_with_status(
            StatusCode::SERVICE_UNAVAILABLE,
            ApiErrorCode::ServiceUnavailable,
            "Google mailbox list payload was invalid.",
        )
    })?;

    let state_rows = state
        ._domain_store
        .list_inbox_thread_states_for_user(user_id)
        .await
        .map_err(map_domain_store_error)?;
    let state_by_thread_id = state_rows
        .into_iter()
        .map(|row| (row.thread_id.clone(), row))
        .collect::<HashMap<_, _>>();

    let mut rows = Vec::with_capacity(list.threads.len());
    for thread in list.threads {
        let detail = gmail_fetch_thread_for_user(state, user_id, &thread.id, request_id).await?;
        let summary = inbox_summary_from_gmail_thread(
            &thread.id,
            &detail,
            state_by_thread_id.get(&thread.id),
        );
        rows.push(summary);
    }

    rows.sort_by(|left, right| right.updated_at.cmp(&left.updated_at));
    Ok(rows)
}

async fn gmail_fetch_thread_for_user(
    state: &AppState,
    user_id: &str,
    thread_id: &str,
    request_id: &str,
) -> Result<GmailThreadResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let url = format!(
        "{}/gmail/v1/users/me/threads/{thread_id}?format=full",
        google_gmail_api_base_url(state.config.as_ref())
    );
    let response = gmail_json_request(
        state,
        user_id,
        reqwest::Method::GET,
        url.as_str(),
        None,
        request_id,
    )
    .await?;

    serde_json::from_value::<GmailThreadResponse>(response).map_err(|_| {
        error_response_with_status(
            StatusCode::SERVICE_UNAVAILABLE,
            ApiErrorCode::ServiceUnavailable,
            "Google mailbox thread payload was invalid.",
        )
    })
}

fn inbox_summary_from_gmail_thread(
    thread_id: &str,
    thread: &GmailThreadResponse,
    persisted_state: Option<&crate::domain_store::InboxThreadStateRecord>,
) -> InboxThreadSummary {
    let latest = thread.messages.last();
    let subject = latest
        .and_then(gmail_message_subject)
        .or_else(|| gmail_thread_subject(thread))
        .unwrap_or_else(|| "No subject".to_string());
    let from_address = latest
        .and_then(gmail_message_from)
        .unwrap_or_else(|| "unknown@unknown".to_string());
    let snippet = latest
        .and_then(|message| message.snippet.clone())
        .or_else(|| thread.snippet.clone())
        .unwrap_or_default();
    let body = latest
        .map(gmail_message_body)
        .filter(|value| !value.trim().is_empty())
        .unwrap_or_else(|| snippet.clone());

    let decision = classify_thread(subject.as_str(), body.as_str(), snippet.as_str());
    let style_signature = infer_style_signature_from_bodies([body.as_str()]);
    let generated_draft = compose_local_draft(
        decision.category,
        subject.as_str(),
        body.as_str(),
        None,
        None,
        None,
        style_signature.as_str(),
    );

    let pending_approval = persisted_state
        .map(|row| row.pending_approval)
        .unwrap_or(matches!(
            decision.policy,
            PolicyDecision::DraftOnly | PolicyDecision::SendWithApproval
        ));
    let draft_preview = persisted_state
        .and_then(|row| row.draft_preview.clone())
        .filter(|value| !value.trim().is_empty())
        .unwrap_or(generated_draft);
    let updated_at = latest
        .and_then(|message| gmail_internal_date_to_timestamp(message.internal_date.as_deref()))
        .unwrap_or_else(|| timestamp(Utc::now()));

    InboxThreadSummary {
        id: thread_id.to_string(),
        subject,
        from_address,
        snippet,
        category: decision.category.as_str().to_string(),
        risk: risk_to_str(decision.risk).to_string(),
        policy: decision.policy.as_str().to_string(),
        draft_preview,
        pending_approval,
        updated_at,
    }
}

fn inbox_message_from_gmail(message: &GmailMessage) -> InboxThreadMessage {
    InboxThreadMessage {
        id: message.id.clone(),
        from: gmail_message_from(message),
        to: gmail_message_to(message),
        subject: gmail_message_subject(message),
        snippet: message.snippet.clone().unwrap_or_default(),
        body: gmail_message_body(message),
        created_at: gmail_internal_date_to_timestamp(message.internal_date.as_deref()),
    }
}

fn gmail_message_subject(message: &GmailMessage) -> Option<String> {
    gmail_message_header_value(message, "subject")
}

fn gmail_message_from(message: &GmailMessage) -> Option<String> {
    gmail_message_header_value(message, "from")
}

fn gmail_message_to(message: &GmailMessage) -> Option<String> {
    gmail_message_header_value(message, "to")
}

fn gmail_thread_subject(thread: &GmailThreadResponse) -> Option<String> {
    thread.messages.iter().rev().find_map(gmail_message_subject)
}

fn gmail_message_header_value(message: &GmailMessage, name: &str) -> Option<String> {
    let payload = message.payload.as_ref()?;
    payload
        .headers
        .iter()
        .find(|header| header.name.eq_ignore_ascii_case(name))
        .map(|header| header.value.trim().to_string())
        .filter(|value| !value.is_empty())
}

fn gmail_message_body(message: &GmailMessage) -> String {
    message
        .payload
        .as_ref()
        .and_then(gmail_payload_body)
        .unwrap_or_else(|| message.snippet.clone().unwrap_or_default())
}

fn gmail_payload_body(payload: &GmailMessagePayload) -> Option<String> {
    if let Some(data) = payload
        .body
        .as_ref()
        .and_then(|body| body.data.as_deref())
        .and_then(gmail_base64_decode)
    {
        let text = data.trim().to_string();
        if !text.is_empty() {
            return Some(text);
        }
    }

    for part in &payload.parts {
        if let Some(text) = gmail_payload_body(part) {
            let trimmed = text.trim().to_string();
            if !trimmed.is_empty() {
                return Some(trimmed);
            }
        }
    }

    None
}

fn gmail_base64_decode(input: &str) -> Option<String> {
    URL_SAFE_NO_PAD
        .decode(input.as_bytes())
        .or_else(|_| STANDARD.decode(input.as_bytes()))
        .ok()
        .and_then(|bytes| String::from_utf8(bytes).ok())
}

fn gmail_internal_date_to_timestamp(value: Option<&str>) -> Option<String> {
    let millis = value?.parse::<i64>().ok()?;
    let dt = chrono::DateTime::<Utc>::from_timestamp_millis(millis)?;
    Some(timestamp(dt))
}

fn google_gmail_api_base_url(config: &Config) -> &str {
    config.google_gmail_api_base_url.as_str()
}

fn normalize_reply_recipient(raw: &str) -> Option<String> {
    let trimmed = raw.trim();
    if trimmed.is_empty() {
        return None;
    }
    if trimmed.contains('<') && trimmed.contains('>') {
        let start = trimmed.find('<')?;
        let end = trimmed.rfind('>')?;
        if end > start + 1 {
            let email = trimmed[start + 1..end].trim().to_string();
            return (!email.is_empty()).then_some(email);
        }
    }
    Some(trimmed.to_string())
}

fn normalize_reply_subject(raw: &str) -> String {
    let subject = raw.trim();
    if subject.is_empty() {
        return "Re: (no subject)".to_string();
    }
    if subject.to_ascii_lowercase().starts_with("re:") {
        subject.to_string()
    } else {
        format!("Re: {subject}")
    }
}

fn parse_inbox_limit(raw: Option<&str>) -> Result<usize, (StatusCode, Json<ApiErrorResponse>)> {
    let Some(raw) = raw else {
        return Ok(20);
    };
    let parsed = raw
        .trim()
        .parse::<usize>()
        .map_err(|_| validation_error("limit", "The limit field must be an integer."))?;
    if !(1..=100).contains(&parsed) {
        return Err(validation_error(
            "limit",
            "The limit field must be between 1 and 100.",
        ));
    }
    Ok(parsed)
}

async fn gmail_json_request(
    state: &AppState,
    user_id: &str,
    method: reqwest::Method,
    url: &str,
    body: Option<serde_json::Value>,
    request_id: &str,
) -> Result<serde_json::Value, (StatusCode, Json<ApiErrorResponse>)> {
    let client = reqwest::Client::new();
    let mut access_token = google_access_token_for_user(state, user_id, false).await?;
    let mut refreshed_after_401 = false;
    let max_attempts = 3usize;

    for attempt in 1..=max_attempts {
        let mut request = client
            .request(method.clone(), url)
            .header("accept", "application/json")
            .bearer_auth(access_token.as_str())
            .timeout(std::time::Duration::from_secs(15));
        if let Some(body) = body.as_ref() {
            request = request.json(body);
        }

        let response = match request.send().await {
            Ok(value) => value,
            Err(_) => {
                if attempt < max_attempts {
                    tokio::time::sleep(std::time::Duration::from_millis(200 * attempt as u64))
                        .await;
                    continue;
                }
                state
                    .observability
                    .increment_counter("inbox.gmail.request.failed", request_id);
                return Err(error_response_with_status(
                    StatusCode::SERVICE_UNAVAILABLE,
                    ApiErrorCode::ServiceUnavailable,
                    "Google mailbox request failed.",
                ));
            }
        };

        let status = response.status();
        let bytes = response.bytes().await.map_err(|_| {
            error_response_with_status(
                StatusCode::SERVICE_UNAVAILABLE,
                ApiErrorCode::ServiceUnavailable,
                "Google mailbox response could not be read.",
            )
        })?;

        if status == StatusCode::UNAUTHORIZED && !refreshed_after_401 {
            access_token = google_access_token_for_user(state, user_id, true).await?;
            refreshed_after_401 = true;
            continue;
        }

        if !status.is_success() {
            if attempt < max_attempts
                && (status.is_server_error() || status == StatusCode::TOO_MANY_REQUESTS)
            {
                tokio::time::sleep(std::time::Duration::from_millis(200 * attempt as u64)).await;
                continue;
            }
            state
                .observability
                .increment_counter("inbox.gmail.request.failed", request_id);
            return Err(map_gmail_error_status(status));
        }

        let value = serde_json::from_slice::<serde_json::Value>(&bytes).map_err(|_| {
            error_response_with_status(
                StatusCode::SERVICE_UNAVAILABLE,
                ApiErrorCode::ServiceUnavailable,
                "Google mailbox response payload was invalid.",
            )
        })?;
        return Ok(value);
    }

    Err(error_response_with_status(
        StatusCode::SERVICE_UNAVAILABLE,
        ApiErrorCode::ServiceUnavailable,
        "Google mailbox request failed after retries.",
    ))
}

async fn google_access_token_for_user(
    state: &AppState,
    user_id: &str,
    force_refresh: bool,
) -> Result<String, (StatusCode, Json<ApiErrorResponse>)> {
    let integration = state
        ._domain_store
        .find_active_integration_secret(user_id, "google")
        .await
        .map_err(map_domain_store_error)?
        .ok_or_else(|| {
            validation_error(
                "google",
                "Connect an active Google integration before using inbox.",
            )
        })?;
    let secret_raw = integration
        .encrypted_secret
        .as_deref()
        .and_then(|value| non_empty(value.to_string()))
        .ok_or_else(|| {
            validation_error(
                "google",
                "Google integration secret is missing. Reconnect Google.",
            )
        })?;
    let secret = serde_json::from_str::<GoogleIntegrationSecretPayload>(secret_raw.as_str())
        .map_err(|_| {
            error_response_with_status(
                StatusCode::SERVICE_UNAVAILABLE,
                ApiErrorCode::ServiceUnavailable,
                "Google integration secret payload is invalid.",
            )
        })?;

    let is_fresh = secret
        .expires_at
        .as_deref()
        .and_then(|value| parse_rfc3339_utc(value).ok())
        .map(|expiry| expiry > Utc::now() + Duration::seconds(30))
        .unwrap_or(false);
    if !force_refresh {
        if let Some(token) = secret
            .access_token
            .as_deref()
            .and_then(|value| non_empty(value.to_string()))
        {
            if is_fresh {
                return Ok(token);
            }
        }
    }

    let refresh_token = secret
        .refresh_token
        .as_deref()
        .and_then(|value| non_empty(value.to_string()))
        .ok_or_else(|| {
            validation_error(
                "google",
                "Google refresh token is missing. Reconnect Google integration.",
            )
        })?;
    let client_id = state
        .config
        .google_oauth_client_id
        .clone()
        .and_then(non_empty)
        .ok_or_else(|| {
            error_response_with_status(
                StatusCode::SERVICE_UNAVAILABLE,
                ApiErrorCode::ServiceUnavailable,
                "Google OAuth client id is not configured.",
            )
        })?;
    let client_secret = state
        .config
        .google_oauth_client_secret
        .clone()
        .and_then(non_empty)
        .ok_or_else(|| {
            error_response_with_status(
                StatusCode::SERVICE_UNAVAILABLE,
                ApiErrorCode::ServiceUnavailable,
                "Google OAuth client secret is not configured.",
            )
        })?;

    let refresh_response = reqwest::Client::new()
        .post(state.config.google_oauth_token_url.clone())
        .header("accept", "application/json")
        .form(&[
            ("grant_type", "refresh_token"),
            ("refresh_token", refresh_token.as_str()),
            ("client_id", client_id.as_str()),
            ("client_secret", client_secret.as_str()),
        ])
        .timeout(std::time::Duration::from_secs(15))
        .send()
        .await
        .map_err(|_| {
            error_response_with_status(
                StatusCode::SERVICE_UNAVAILABLE,
                ApiErrorCode::ServiceUnavailable,
                "Google token refresh request failed.",
            )
        })?;
    if !refresh_response.status().is_success() {
        return Err(error_response_with_status(
            StatusCode::SERVICE_UNAVAILABLE,
            ApiErrorCode::ServiceUnavailable,
            "Google token refresh failed. Reconnect Google integration.",
        ));
    }
    let token_payload = refresh_response
        .json::<serde_json::Value>()
        .await
        .map_err(|_| {
            error_response_with_status(
                StatusCode::SERVICE_UNAVAILABLE,
                ApiErrorCode::ServiceUnavailable,
                "Google token refresh payload was invalid.",
            )
        })?;
    let access_token = normalized_json_string(token_payload.get("access_token"))
        .and_then(non_empty)
        .ok_or_else(|| {
            error_response_with_status(
                StatusCode::SERVICE_UNAVAILABLE,
                ApiErrorCode::ServiceUnavailable,
                "Google token refresh payload did not include an access token.",
            )
        })?;

    state
        ._domain_store
        .upsert_google_integration(UpsertGoogleIntegrationInput {
            user_id: user_id.to_string(),
            refresh_token: Some(refresh_token),
            access_token: Some(access_token.clone()),
            scope: normalized_json_string(token_payload.get("scope")).or(secret.scope),
            token_type: normalized_json_string(token_payload.get("token_type"))
                .or(secret.token_type),
            expires_at: resolve_google_token_expiry(&token_payload),
        })
        .await
        .map_err(map_domain_store_error)?;

    Ok(access_token)
}

fn map_gmail_error_status(status: StatusCode) -> (StatusCode, Json<ApiErrorResponse>) {
    if status == StatusCode::NOT_FOUND {
        return not_found_error("Inbox thread not found.");
    }
    if status == StatusCode::TOO_MANY_REQUESTS {
        return error_response_with_status(
            StatusCode::TOO_MANY_REQUESTS,
            ApiErrorCode::RateLimited,
            "Google mailbox rate limit exceeded. Retry shortly.",
        );
    }
    if status == StatusCode::UNAUTHORIZED || status == StatusCode::FORBIDDEN {
        return forbidden_error("Google mailbox access was denied. Reconnect Google integration.");
    }
    if status.is_client_error() {
        return validation_error("gmail", "Google mailbox request was rejected.");
    }

    error_response_with_status(
        StatusCode::SERVICE_UNAVAILABLE,
        ApiErrorCode::ServiceUnavailable,
        "Google mailbox request failed.",
    )
}

fn settings_integration_response(
    _headers: &HeaderMap,
    status: &str,
    action: Option<String>,
    integration: serde_json::Value,
) -> Response {
    (
        StatusCode::OK,
        Json(serde_json::json!({
            "data": {
                "status": status,
                "action": action,
                "integration": integration,
            }
        })),
    )
        .into_response()
}

fn integration_payload(
    integration: Option<&UserIntegrationRecord>,
    provider: &str,
) -> serde_json::Value {
    let Some(integration) = integration else {
        return serde_json::json!({
            "provider": provider,
            "status": "inactive",
            "connected": false,
            "secretLast4": serde_json::Value::Null,
            "connectedAt": serde_json::Value::Null,
            "disconnectedAt": serde_json::Value::Null,
            "metadata": serde_json::json!({}),
        });
    };

    let has_secret = integration
        .encrypted_secret
        .as_deref()
        .map(str::trim)
        .filter(|value| !value.is_empty())
        .is_some();
    let connected = integration.status == "active" && has_secret;

    serde_json::json!({
        "provider": integration.provider,
        "status": integration.status,
        "connected": connected,
        "secretLast4": integration.secret_last4,
        "connectedAt": integration.connected_at.map(timestamp),
        "disconnectedAt": integration.disconnected_at.map(timestamp),
        "metadata": integration.metadata.clone().unwrap_or_else(|| serde_json::json!({})),
    })
}

fn normalize_optional_email(
    value: Option<String>,
    field: &'static str,
) -> Result<Option<String>, (StatusCode, Json<ApiErrorResponse>)> {
    let Some(value) = value.and_then(non_empty) else {
        return Ok(None);
    };
    if value.chars().count() > 255 || !value.contains('@') {
        return Err(validation_error(
            field,
            &format!("The {field} field must be a valid email address."),
        ));
    }
    Ok(Some(value.to_lowercase()))
}

fn resolve_google_token_expiry(payload: &serde_json::Value) -> Option<chrono::DateTime<Utc>> {
    if let Some(seconds) = payload
        .get("expires_in")
        .and_then(|value| value.as_i64())
        .filter(|value| *value > 0)
    {
        return Some(Utc::now() + Duration::seconds(seconds));
    }

    if let Some(seconds) = payload
        .get("expires_in")
        .and_then(|value| value.as_u64())
        .filter(|value| *value > 0)
    {
        return Some(Utc::now() + Duration::seconds(seconds as i64));
    }

    payload
        .get("expires_at")
        .and_then(serde_json::Value::as_str)
        .and_then(|value| parse_rfc3339_utc(value).ok())
}

async fn settings_profile_delete(
    State(state): State<AppState>,
    headers: HeaderMap,
    Json(payload): Json<DeleteProfileRequestPayload>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let access_token = access_token_from_headers(&headers)
        .ok_or_else(|| unauthorized_error("Unauthenticated."))?;

    let bundle = state
        .auth
        .session_or_pat_from_access_token(&access_token)
        .await
        .map_err(map_auth_error)?;

    let normalized_email = payload.email.trim().to_lowercase();
    if normalized_email.is_empty() {
        return Err(validation_error("email", "The email field is required."));
    }
    if !normalized_email.contains('@') || normalized_email.chars().count() > 255 {
        return Err(validation_error(
            "email",
            "The email field must be a valid email address.",
        ));
    }

    let user_email = bundle.user.email.trim().to_lowercase();
    if normalized_email != user_email {
        return Err(validation_error(
            "email",
            "Email confirmation does not match the authenticated user.",
        ));
    }

    let deleted_user = state
        .auth
        .delete_profile(&bundle.user.id)
        .await
        .map_err(map_auth_error)?;

    state.observability.audit(
        AuditEvent::new("profile.deleted", request_id.clone())
            .with_user_id(deleted_user.id)
            .with_session_id(bundle.session.session_id)
            .with_org_id(bundle.session.active_org_id)
            .with_device_id(bundle.session.device_id)
            .with_attribute("source", "api".to_string()),
    );
    state
        .observability
        .increment_counter("profile.deleted", &request_id);

    Ok((
        StatusCode::OK,
        Json(serde_json::json!({
            "data": {
                "deleted": true,
            }
        })),
    ))
}

async fn list_personal_access_tokens(
    State(state): State<AppState>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let access_token = access_token_from_headers(&headers)
        .ok_or_else(|| unauthorized_error("Unauthenticated."))?;

    let bundle = state
        .auth
        .session_or_pat_from_access_token(&access_token)
        .await
        .map_err(map_auth_error)?;

    let current_token_id = state
        .auth
        .current_personal_access_token_id(&bundle.user.id, &access_token)
        .await;

    let tokens = state
        .auth
        .list_personal_access_tokens(&bundle.user.id)
        .await
        .map_err(map_auth_error)?
        .into_iter()
        .filter(|token| token.revoked_at.is_none())
        .map(|token| {
            serde_json::json!({
                "id": token.token_id,
                "name": token.name,
                "abilities": token.scopes,
                "lastUsedAt": token.last_used_at.map(timestamp),
                "expiresAt": token.expires_at.map(timestamp),
                "createdAt": timestamp(token.created_at),
                "isCurrent": current_token_id
                    .as_ref()
                    .map(|current| current == &token.token_id)
                    .unwrap_or(false),
            })
        })
        .collect::<Vec<_>>();

    Ok((StatusCode::OK, Json(serde_json::json!({ "data": tokens }))))
}

async fn create_personal_access_token(
    State(state): State<AppState>,
    headers: HeaderMap,
    Json(payload): Json<CreateTokenRequestPayload>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let access_token = access_token_from_headers(&headers)
        .ok_or_else(|| unauthorized_error("Unauthenticated."))?;

    let bundle = state
        .auth
        .session_or_pat_from_access_token(&access_token)
        .await
        .map_err(map_auth_error)?;

    let name = payload.name.trim().to_string();
    if name.is_empty() {
        return Err(validation_error("name", "Token name is required."));
    }
    if name.chars().count() > 100 {
        return Err(validation_error(
            "name",
            "Token name may not be greater than 100 characters.",
        ));
    }

    let abilities = match payload.abilities {
        Some(values) if !values.is_empty() => {
            let mut normalized = Vec::new();
            for value in values {
                let trimmed = value.trim();
                if trimmed.chars().count() > 100 {
                    return Err(validation_error(
                        "abilities",
                        "Token abilities may not be greater than 100 characters.",
                    ));
                }

                if !trimmed.is_empty() {
                    normalized.push(trimmed.to_string());
                }
            }

            if normalized.is_empty() {
                vec!["*".to_string()]
            } else {
                normalized
            }
        }
        _ => vec!["*".to_string()],
    };

    let now = Utc::now();
    let expires_at = payload
        .expires_at
        .as_deref()
        .map(str::trim)
        .filter(|value| !value.is_empty())
        .map(parse_rfc3339_utc)
        .transpose()
        .map_err(|_| validation_error("expires_at", "The expires_at is not a valid date."))?;
    let ttl_seconds =
        expires_at.map(|value| value.signed_duration_since(now).num_seconds().max(0) as u64);

    let issued = state
        .auth
        .issue_personal_access_token(
            &bundle.user.id,
            name.clone(),
            abilities.clone(),
            ttl_seconds,
        )
        .await
        .map_err(map_auth_error)?;

    let response = serde_json::json!({
        "data": {
            "token": issued.plain_text_token,
            "tokenableId": bundle.user.id,
            "name": name,
            "abilities": abilities,
            "expiresAt": issued.token.expires_at.map(timestamp),
        }
    });

    Ok((StatusCode::CREATED, Json(response)))
}

async fn delete_current_personal_access_token(
    State(state): State<AppState>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let access_token = access_token_from_headers(&headers)
        .ok_or_else(|| unauthorized_error("Unauthenticated."))?;

    let bundle = state
        .auth
        .session_or_pat_from_access_token(&access_token)
        .await
        .map_err(map_auth_error)?;

    let token_id = state
        .auth
        .current_personal_access_token_id(&bundle.user.id, &access_token)
        .await;

    let deleted = match token_id {
        Some(token_id) => state
            .auth
            .revoke_personal_access_token(&bundle.user.id, &token_id)
            .await
            .map_err(map_auth_error)?,
        None => false,
    };

    Ok((
        StatusCode::OK,
        Json(serde_json::json!({ "data": { "deleted": deleted } })),
    ))
}

async fn delete_personal_access_token(
    State(state): State<AppState>,
    Path(token_id): Path<String>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let access_token = access_token_from_headers(&headers)
        .ok_or_else(|| unauthorized_error("Unauthenticated."))?;

    let bundle = state
        .auth
        .session_or_pat_from_access_token(&access_token)
        .await
        .map_err(map_auth_error)?;

    let normalized_token_id = token_id.trim().to_string();
    if normalized_token_id.is_empty() {
        return Err(not_found_error("Not found."));
    }

    let deleted = state
        .auth
        .revoke_personal_access_token(&bundle.user.id, &normalized_token_id)
        .await
        .map_err(map_auth_error)?;
    if !deleted {
        return Err(not_found_error("Not found."));
    }

    Ok((
        StatusCode::OK,
        Json(serde_json::json!({ "data": { "deleted": true } })),
    ))
}

async fn delete_all_personal_access_tokens(
    State(state): State<AppState>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let access_token = access_token_from_headers(&headers)
        .ok_or_else(|| unauthorized_error("Unauthenticated."))?;

    let bundle = state
        .auth
        .session_or_pat_from_access_token(&access_token)
        .await
        .map_err(map_auth_error)?;

    let deleted_count = state
        .auth
        .revoke_all_personal_access_tokens(&bundle.user.id)
        .await
        .map_err(map_auth_error)?;

    Ok((
        StatusCode::OK,
        Json(serde_json::json!({ "data": { "deletedCount": deleted_count } })),
    ))
}

async fn khala_token(
    State(state): State<AppState>,
    headers: HeaderMap,
    Json(payload): Json<KhalaTokenRequestPayload>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let access_token = access_token_from_headers(&headers)
        .ok_or_else(|| unauthorized_error("Unauthenticated."))?;

    let session = state
        .auth
        .session_or_pat_from_access_token(&access_token)
        .await
        .map_err(map_auth_error)?;

    let mut scope = Vec::new();
    for entry in payload.scope {
        let value = entry.trim();
        if value.chars().count() > 120 {
            return Err(validation_error(
                "scope",
                "Scope entries may not be greater than 120 characters.",
            ));
        }

        if !value.is_empty() {
            scope.push(value.to_string());
        }
    }

    let workspace_id = payload
        .workspace_id
        .as_deref()
        .map(str::trim)
        .filter(|value| !value.is_empty())
        .map(ToString::to_string);
    if workspace_id
        .as_ref()
        .map(|value| value.chars().count() > 120)
        .unwrap_or(false)
    {
        return Err(validation_error(
            "workspace_id",
            "Workspace id may not be greater than 120 characters.",
        ));
    }

    let role = payload
        .role
        .as_deref()
        .map(str::trim)
        .filter(|value| !value.is_empty())
        .map(ToString::to_string);
    if role
        .as_deref()
        .map(|value| !matches!(value, "member" | "admin" | "owner"))
        .unwrap_or(false)
    {
        return Err(validation_error(
            "role",
            "Role must be one of member, admin, owner.",
        ));
    }

    let issued = state
        .khala_token_issuer
        .issue(KhalaTokenIssueRequest {
            user_id: session.user.id.clone(),
            scope,
            workspace_id,
            role,
        })
        .map_err(map_khala_error)?;

    Ok(ok_data(issued))
}

async fn org_memberships(
    State(state): State<AppState>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let access_token = access_token_from_headers(&headers)
        .ok_or_else(|| unauthorized_error("Unauthenticated."))?;

    let bundle = state
        .auth
        .session_or_pat_from_access_token(&access_token)
        .await
        .map_err(map_auth_error)?;

    let response = serde_json::json!({
        "data": {
            "activeOrgId": bundle.session.active_org_id,
            "memberships": bundle.memberships,
        }
    });

    Ok((StatusCode::OK, Json(response)))
}

async fn set_active_org(
    State(state): State<AppState>,
    headers: HeaderMap,
    Json(payload): Json<SetActiveOrgRequest>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let access_token = access_token_from_headers(&headers)
        .ok_or_else(|| unauthorized_error("Unauthenticated."))?;

    let normalized_org_id = payload.org_id.trim().to_string();
    if normalized_org_id.is_empty() {
        return Err(validation_error("org_id", "Organization id is required."));
    }

    let bundle = state
        .auth
        .set_active_org_by_access_token(&access_token, &normalized_org_id)
        .await
        .map_err(map_auth_error)?;

    state.observability.audit(
        AuditEvent::new("auth.active_org.updated", request_id.clone())
            .with_user_id(bundle.user.id.clone())
            .with_session_id(bundle.session.session_id.clone())
            .with_org_id(bundle.session.active_org_id.clone())
            .with_device_id(bundle.session.device_id.clone()),
    );
    state
        .observability
        .increment_counter("auth.active_org.updated", &request_id);

    let response = serde_json::json!({
        "ok": true,
        "activeOrgId": bundle.session.active_org_id,
        "memberships": bundle.memberships,
    });

    Ok((StatusCode::OK, Json(response)))
}

async fn policy_authorize(
    State(state): State<AppState>,
    headers: HeaderMap,
    Json(payload): Json<PolicyAuthorizeRequest>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let access_token = access_token_from_headers(&headers)
        .ok_or_else(|| unauthorized_error("Unauthenticated."))?;

    let decision = state
        .auth
        .evaluate_policy_by_access_token(
            &access_token,
            PolicyCheckRequest {
                org_id: payload.org_id,
                required_scopes: payload.required_scopes,
                requested_topics: payload.requested_topics,
            },
        )
        .await
        .map_err(map_auth_error)?;

    Ok(ok_data(decision))
}

#[derive(Debug, Clone, Serialize)]
struct ResendWebhookNormalizedPayload {
    event_id: String,
    provider: String,
    event_type: String,
    delivery_state: String,
    message_id: Option<String>,
    integration_id: Option<String>,
    user_id: Option<String>,
    recipient: Option<String>,
    occurred_at: String,
    reason: Option<String>,
    payload: serde_json::Value,
}

#[derive(Debug, Default)]
struct RuntimeDeliveryForwardResult {
    ok: bool,
    attempts_made: u32,
    status: Option<u16>,
    body: Option<serde_json::Value>,
    error: Option<String>,
}

async fn webhooks_resend_store(
    State(state): State<AppState>,
    headers: HeaderMap,
    body: Bytes,
) -> Response {
    let raw_body = String::from_utf8_lossy(&body).to_string();
    let raw_payload = serde_json::from_slice::<serde_json::Value>(&body)
        .ok()
        .filter(serde_json::Value::is_object)
        .unwrap_or_else(|| serde_json::json!({}));

    let svix_id = header_string(&headers, RESEND_SVIX_ID_HEADER).unwrap_or_default();
    let svix_timestamp = header_string(&headers, RESEND_SVIX_TIMESTAMP_HEADER).unwrap_or_default();
    let svix_signature = header_string(&headers, RESEND_SVIX_SIGNATURE_HEADER).unwrap_or_default();

    let idempotency_key =
        resend_webhook_idempotency_key(RESEND_WEBHOOK_PROVIDER, &svix_id, &raw_body);
    let external_event_id = non_empty(svix_id.clone());
    let signature_valid = verify_resend_webhook_signature(
        &state.config,
        &raw_body,
        &svix_id,
        &svix_timestamp,
        &svix_signature,
    );

    if !signature_valid {
        let invalid_event = match state
            ._domain_store
            .upsert_invalid_webhook_event(RecordWebhookEventInput {
                provider: RESEND_WEBHOOK_PROVIDER.to_string(),
                idempotency_key: idempotency_key.clone(),
                external_event_id: external_event_id.clone(),
                event_type: None,
                delivery_state: None,
                message_id: None,
                integration_id: None,
                user_id: None,
                recipient: None,
                signature_valid: false,
                status: Some("invalid_signature".to_string()),
                normalized_payload: None,
                raw_payload: Some(raw_payload.clone()),
            })
            .await
        {
            Ok(row) => row,
            Err(error) => return map_domain_store_error(error).into_response(),
        };

        return (
            StatusCode::UNAUTHORIZED,
            Json(serde_json::json!({
                "error": {
                    "code": "invalid_signature",
                    "message": "invalid webhook signature",
                },
                "audit": {
                    "event_id": invalid_event.id,
                },
            })),
        )
            .into_response();
    }

    let normalized = normalize_resend_webhook_payload(&raw_payload, external_event_id.as_deref());
    let normalized_value = normalized
        .as_ref()
        .and_then(|payload| serde_json::to_value(payload).ok());
    let normalized_hash = normalized_value
        .as_ref()
        .map(resend_webhook_normalized_hash);
    let status = if normalized.is_some() {
        "received".to_string()
    } else {
        "ignored".to_string()
    };
    let event_type = raw_payload
        .get("type")
        .and_then(serde_json::Value::as_str)
        .and_then(|value| non_empty(value.to_string()));

    let existing = match state
        ._domain_store
        .webhook_event_by_idempotency_key(&idempotency_key)
        .await
    {
        Ok(row) => row,
        Err(error) => return map_domain_store_error(error).into_response(),
    };

    if let Some(existing) = existing {
        if !existing.signature_valid {
            let verified = match state
                ._domain_store
                .mark_webhook_event_verified(MarkWebhookEventVerifiedInput {
                    webhook_event_id: existing.id,
                    status: status.clone(),
                    event_type: event_type.clone(),
                    delivery_state: normalized
                        .as_ref()
                        .map(|value| value.delivery_state.clone()),
                    message_id: normalized
                        .as_ref()
                        .and_then(|value| value.message_id.clone()),
                    integration_id: normalized
                        .as_ref()
                        .and_then(|value| value.integration_id.clone()),
                    user_id: normalized.as_ref().and_then(|value| value.user_id.clone()),
                    recipient: normalized
                        .as_ref()
                        .and_then(|value| value.recipient.clone()),
                    normalized_hash: normalized_hash.clone(),
                    normalized_payload: normalized_value.clone(),
                    raw_payload: Some(raw_payload.clone()),
                })
                .await
            {
                Ok(Some(row)) => row,
                Ok(None) => {
                    return not_found_error("Webhook event not found after verification update.")
                        .into_response();
                }
                Err(error) => return map_domain_store_error(error).into_response(),
            };

            if should_dispatch_resend_webhook(&verified.status, normalized.as_ref()) {
                spawn_resend_webhook_forward_task(state.clone(), verified.id);
            }

            return (
                StatusCode::ACCEPTED,
                Json(serde_json::json!({
                    "data": {
                        "event_id": verified.id,
                        "status": verified.status,
                        "idempotent_replay": false,
                    }
                })),
            )
                .into_response();
        }

        if existing
            .normalized_hash
            .as_deref()
            .zip(normalized_hash.as_deref())
            .map(|(saved, incoming)| saved != incoming)
            .unwrap_or(false)
        {
            return (
                StatusCode::CONFLICT,
                Json(serde_json::json!({
                    "error": {
                        "code": "idempotency_conflict",
                        "message": "webhook idempotency key conflicts with different normalized payload",
                    }
                })),
            )
                .into_response();
        }

        if should_dispatch_resend_webhook(&existing.status, normalized.as_ref()) {
            spawn_resend_webhook_forward_task(state.clone(), existing.id);
        }

        return (
            StatusCode::OK,
            Json(serde_json::json!({
                "data": {
                    "event_id": existing.id,
                    "status": existing.status,
                    "idempotent_replay": true,
                }
            })),
        )
            .into_response();
    }

    let inserted = match state
        ._domain_store
        .record_webhook_event(RecordWebhookEventInput {
            provider: RESEND_WEBHOOK_PROVIDER.to_string(),
            idempotency_key,
            external_event_id,
            event_type,
            delivery_state: normalized
                .as_ref()
                .map(|value| value.delivery_state.clone()),
            message_id: normalized
                .as_ref()
                .and_then(|value| value.message_id.clone()),
            integration_id: normalized
                .as_ref()
                .and_then(|value| value.integration_id.clone()),
            user_id: normalized.as_ref().and_then(|value| value.user_id.clone()),
            recipient: normalized
                .as_ref()
                .and_then(|value| value.recipient.clone()),
            signature_valid: true,
            status: Some(status.clone()),
            normalized_payload: normalized_value,
            raw_payload: Some(raw_payload),
        })
        .await
    {
        Ok(result) => result,
        Err(error) => return map_domain_store_error(error).into_response(),
    };

    if should_dispatch_resend_webhook(&status, normalized.as_ref()) {
        spawn_resend_webhook_forward_task(state.clone(), inserted.event.id);
    }

    (
        StatusCode::ACCEPTED,
        Json(serde_json::json!({
            "data": {
                "event_id": inserted.event.id,
                "status": status,
                "idempotent_replay": false,
            }
        })),
    )
        .into_response()
}

fn should_dispatch_resend_webhook(
    status: &str,
    normalized: Option<&ResendWebhookNormalizedPayload>,
) -> bool {
    normalized.is_some() && matches!(status, "received" | "failed")
}

fn resend_webhook_idempotency_key(provider: &str, svix_id: &str, raw_body: &str) -> String {
    let external_event_id = svix_id.trim();
    if !external_event_id.is_empty() {
        return format!("{provider}:{external_event_id}");
    }
    format!("{provider}:body:{}", sha256_hex(raw_body.as_bytes()))
}

fn resend_webhook_normalized_hash(payload: &serde_json::Value) -> String {
    sha256_hex(payload.to_string().as_bytes())
}

fn verify_resend_webhook_signature(
    config: &Config,
    payload: &str,
    svix_id: &str,
    svix_timestamp: &str,
    svix_signature: &str,
) -> bool {
    let Some(secret) = config
        .resend_webhook_secret
        .as_deref()
        .and_then(|value| non_empty(value.to_string()))
    else {
        return false;
    };

    let svix_id = svix_id.trim();
    let svix_timestamp = svix_timestamp.trim();
    let svix_signature = svix_signature.trim();
    if svix_id.is_empty() || svix_timestamp.is_empty() || svix_signature.is_empty() {
        return false;
    }

    if !svix_timestamp.chars().all(|value| value.is_ascii_digit()) {
        return false;
    }

    let Ok(timestamp) = svix_timestamp.parse::<i64>() else {
        return false;
    };
    let tolerance = config.resend_webhook_tolerance_seconds.max(1) as i64;
    let now = Utc::now().timestamp();
    if (now - timestamp).abs() > tolerance {
        return false;
    }

    let secret_bytes = resolve_resend_webhook_secret_bytes(&secret);
    let signed_content = format!("{svix_id}.{svix_timestamp}.{payload}");
    let Ok(mut mac) = HmacSha256::new_from_slice(secret_bytes.as_slice()) else {
        return false;
    };
    mac.update(signed_content.as_bytes());
    let expected = STANDARD.encode(mac.finalize().into_bytes());

    extract_resend_svix_signatures(svix_signature)
        .into_iter()
        .any(|candidate| !candidate.is_empty() && candidate == expected)
}

fn resolve_resend_webhook_secret_bytes(secret: &str) -> Vec<u8> {
    if let Some(encoded) = secret.strip_prefix("whsec_") {
        if let Ok(decoded) = STANDARD.decode(encoded) {
            if !decoded.is_empty() {
                return decoded;
            }
        }
        return encoded.as_bytes().to_vec();
    }
    secret.as_bytes().to_vec()
}

fn extract_resend_svix_signatures(header: &str) -> Vec<String> {
    let mut signatures = Vec::new();
    for token in header.split_whitespace() {
        let trimmed = token.trim();
        if trimmed.is_empty() {
            continue;
        }

        let (version, value) = if let Some((version, value)) = trimmed.split_once(',') {
            (version, value)
        } else if let Some((version, value)) = trimmed.split_once('=') {
            (version, value)
        } else {
            continue;
        };

        if version.trim() != "v1" {
            continue;
        }
        signatures.push(value.trim().to_string());
    }
    signatures
}

fn normalize_resend_webhook_payload(
    raw_payload: &serde_json::Value,
    external_event_id: Option<&str>,
) -> Option<ResendWebhookNormalizedPayload> {
    let event_type = raw_payload
        .get("type")
        .and_then(serde_json::Value::as_str)
        .and_then(|value| non_empty(value.to_string()))?;

    let delivery_state = match event_type.as_str() {
        "email.delivered" => "delivered",
        "email.bounced" => "bounced",
        "email.complained" => "complained",
        "email.suppressed" | "email.unsubscribed" => "unsubscribed",
        _ => return None,
    }
    .to_string();

    let data = raw_payload
        .get("data")
        .and_then(serde_json::Value::as_object)
        .cloned()
        .unwrap_or_default();
    let tags = normalize_resend_webhook_tags(data.get("tags"));

    let recipient = data
        .get("to")
        .and_then(serde_json::Value::as_array)
        .and_then(|values| values.first())
        .and_then(serde_json::Value::as_str)
        .and_then(|value| non_empty(value.to_string()))
        .or_else(|| {
            data.get("email")
                .and_then(serde_json::Value::as_str)
                .and_then(|value| non_empty(value.to_string()))
        });

    let occurred_at = raw_payload
        .get("created_at")
        .and_then(serde_json::Value::as_str)
        .and_then(|value| non_empty(value.to_string()))
        .or_else(|| {
            data.get("created_at")
                .and_then(serde_json::Value::as_str)
                .and_then(|value| non_empty(value.to_string()))
        })
        .unwrap_or_else(|| timestamp(Utc::now()));

    let reason = data
        .get("reason")
        .and_then(serde_json::Value::as_str)
        .and_then(|value| non_empty(value.to_string()))
        .or_else(|| {
            data.get("bounce")
                .and_then(serde_json::Value::as_object)
                .and_then(|bounce| bounce.get("reason"))
                .and_then(serde_json::Value::as_str)
                .and_then(|value| non_empty(value.to_string()))
        })
        .or_else(|| {
            data.get("suppression")
                .and_then(serde_json::Value::as_object)
                .and_then(|suppression| suppression.get("reason"))
                .and_then(serde_json::Value::as_str)
                .and_then(|value| non_empty(value.to_string()))
        });

    let message_id = data
        .get("email_id")
        .and_then(serde_json::Value::as_str)
        .and_then(|value| non_empty(value.to_string()))
        .or_else(|| {
            data.get("id")
                .and_then(serde_json::Value::as_str)
                .and_then(|value| non_empty(value.to_string()))
        });

    let user_id = tags
        .get("user_id")
        .and_then(|value| non_empty(value.to_string()));
    let integration_id = tags
        .get("integration_id")
        .and_then(|value| non_empty(value.to_string()));

    let event_id = external_event_id
        .and_then(|value| non_empty(value.to_string()))
        .unwrap_or_else(|| format!("resend_{}", sha256_hex(raw_payload.to_string().as_bytes())));

    Some(ResendWebhookNormalizedPayload {
        event_id,
        provider: RESEND_WEBHOOK_PROVIDER.to_string(),
        event_type: event_type.clone(),
        delivery_state,
        message_id,
        integration_id,
        user_id,
        recipient,
        occurred_at,
        reason,
        payload: serde_json::json!({
            "raw_type": event_type,
            "tags": tags,
            "raw": raw_payload,
        }),
    })
}

fn normalize_resend_webhook_tags(
    tags_value: Option<&serde_json::Value>,
) -> BTreeMap<String, String> {
    let mut tags = BTreeMap::new();
    let Some(values) = tags_value.and_then(serde_json::Value::as_array) else {
        return tags;
    };

    for entry in values {
        if let Some(entry_obj) = entry.as_object() {
            let name = entry_obj
                .get("name")
                .and_then(serde_json::Value::as_str)
                .and_then(|value| non_empty(value.to_string()));
            let value = entry_obj.get("value").and_then(|value| match value {
                serde_json::Value::String(value) => non_empty(value.to_string()),
                serde_json::Value::Number(value) => non_empty(value.to_string()),
                serde_json::Value::Bool(value) => Some(value.to_string()),
                _ => None,
            });
            if let (Some(name), Some(value)) = (name, value) {
                tags.insert(name, value);
            }
            continue;
        }

        if let Some(entry_text) = entry.as_str() {
            if let Some((key, value)) = entry_text.split_once(':') {
                if let (Some(key), Some(value)) = (
                    non_empty(key.trim().to_string()),
                    non_empty(value.trim().to_string()),
                ) {
                    tags.insert(key, value);
                }
            }
        }
    }

    tags
}

fn spawn_resend_webhook_forward_task(state: AppState, webhook_event_id: u64) {
    tokio::spawn(async move {
        if let Err(error) = forward_resend_webhook_to_runtime(state, webhook_event_id).await {
            tracing::warn!(webhook_event_id, error = %error, "resend webhook runtime forward failed");
        }
    });
}

async fn forward_resend_webhook_to_runtime(
    state: AppState,
    webhook_event_id: u64,
) -> Result<(), String> {
    let Some(event) = state
        ._domain_store
        .webhook_event_by_id(webhook_event_id)
        .await
        .map_err(|error| format!("failed to read webhook event: {error}"))?
    else {
        return Ok(());
    };

    if !event.signature_valid {
        return Ok(());
    }

    let Some(payload) = event.normalized_payload.clone() else {
        return Ok(());
    };
    if !payload.is_object() {
        state
            ._domain_store
            .mark_webhook_event_forward_failed(
                webhook_event_id,
                Some(0),
                None,
                None,
                Some("runtime_payload_decode_failed".to_string()),
            )
            .await
            .map_err(|error| {
                format!("failed to mark webhook event payload decode failure: {error}")
            })?;
        return Err("runtime payload decode failed".to_string());
    }

    state
        ._domain_store
        .mark_webhook_event_forwarding(webhook_event_id)
        .await
        .map_err(|error| format!("failed to mark webhook event forwarding: {error}"))?;

    let result = runtime_forward_delivery_payload(&state, webhook_event_id, &payload).await;
    if !result.ok {
        state
            ._domain_store
            .mark_webhook_event_forward_failed(
                webhook_event_id,
                Some(result.attempts_made),
                result.status,
                result.body.clone(),
                result
                    .error
                    .clone()
                    .or_else(|| Some("runtime_forward_failed".to_string())),
            )
            .await
            .map_err(|error| format!("failed to mark webhook event forward failure: {error}"))?;
        return Err(result
            .error
            .unwrap_or_else(|| "runtime delivery forwarding failed".to_string()));
    }

    state
        ._domain_store
        .mark_webhook_event_forwarded(
            webhook_event_id,
            Some(result.attempts_made),
            result.status,
            result.body.clone(),
        )
        .await
        .map_err(|error| format!("failed to mark webhook event forwarded: {error}"))?;

    if let Some(user_id) = webhook_projection_user_id(payload.get("user_id")) {
        let provider = payload
            .get("provider")
            .and_then(serde_json::Value::as_str)
            .and_then(|value| non_empty(value.to_string()))
            .unwrap_or_else(|| RESEND_WEBHOOK_PROVIDER.to_string());
        let integration_id = payload
            .get("integration_id")
            .and_then(serde_json::Value::as_str)
            .and_then(|value| non_empty(value.to_string()));
        let occurred_at = payload
            .get("occurred_at")
            .and_then(serde_json::Value::as_str)
            .and_then(|value| parse_rfc3339_utc(value).ok())
            .or_else(|| Some(Utc::now()));
        let projection = state
            ._domain_store
            .upsert_delivery_projection(crate::domain_store::UpsertDeliveryProjectionInput {
                user_id: user_id.clone(),
                provider: provider.clone(),
                integration_id: integration_id.clone(),
                last_state: payload
                    .get("delivery_state")
                    .and_then(serde_json::Value::as_str)
                    .and_then(|value| non_empty(value.to_string())),
                last_event_at: occurred_at,
                last_message_id: payload
                    .get("message_id")
                    .and_then(serde_json::Value::as_str)
                    .and_then(|value| non_empty(value.to_string())),
                last_recipient: payload
                    .get("recipient")
                    .and_then(serde_json::Value::as_str)
                    .and_then(|value| non_empty(value.to_string())),
                runtime_event_id: payload
                    .get("event_id")
                    .and_then(serde_json::Value::as_str)
                    .and_then(|value| non_empty(value.to_string())),
                source: Some("runtime_forwarder".to_string()),
                last_webhook_event_id: Some(webhook_event_id),
            })
            .await
            .map_err(|error| format!("failed to upsert delivery projection: {error}"))?;

        state
            ._domain_store
            .audit_delivery_projection_updated(&user_id, &provider, &projection)
            .await
            .map_err(|error| format!("failed to audit delivery projection update: {error}"))?;
    }

    Ok(())
}

fn webhook_projection_user_id(value: Option<&serde_json::Value>) -> Option<String> {
    let value = value?;
    match value {
        serde_json::Value::String(value) => non_empty(value.to_string()),
        serde_json::Value::Number(value) => value.as_u64().and_then(|value| {
            if value > 0 {
                Some(value.to_string())
            } else {
                None
            }
        }),
        _ => None,
    }
}

async fn runtime_forward_delivery_payload(
    state: &AppState,
    webhook_event_id: u64,
    payload: &serde_json::Value,
) -> RuntimeDeliveryForwardResult {
    let Some(base_url) = state
        .config
        .runtime_elixir_base_url
        .as_deref()
        .and_then(|value| non_empty(value.to_string()))
    else {
        return RuntimeDeliveryForwardResult {
            ok: false,
            attempts_made: 0,
            status: None,
            body: None,
            error: Some("runtime_forward_misconfigured".to_string()),
        };
    };
    let Some(signing_key) = state
        .config
        .runtime_signing_key
        .as_deref()
        .and_then(|value| non_empty(value.to_string()))
    else {
        return RuntimeDeliveryForwardResult {
            ok: false,
            attempts_made: 0,
            status: None,
            body: None,
            error: Some("runtime_forward_misconfigured".to_string()),
        };
    };

    let ingest_path = normalize_route_path(&state.config.runtime_comms_delivery_ingest_path);
    let url = format!("{}{}", base_url.trim_end_matches('/'), ingest_path);
    let attempts = state
        .config
        .runtime_comms_delivery_max_retries
        .saturating_add(1)
        .max(1);
    let backoff_ms = state.config.runtime_comms_delivery_retry_backoff_ms;
    let timeout_ms = state.config.runtime_comms_delivery_timeout_ms.max(500);
    let timeout = std::time::Duration::from_millis(timeout_ms);
    let payload_bytes = serde_json::to_vec(payload).unwrap_or_else(|_| b"{}".to_vec());
    let payload_hash = sha256_hex(&payload_bytes);

    let mut last_status = None;
    let mut last_body = None;
    let mut last_error: Option<String> = None;
    let mut attempts_made = 0u32;

    for attempt in 1..=attempts {
        attempts_made = attempt as u32;
        let signature = match runtime_forward_signature_token(
            signing_key.as_str(),
            state.config.runtime_signature_ttl_seconds.max(1),
        ) {
            Ok(value) => value,
            Err(error) => {
                return RuntimeDeliveryForwardResult {
                    ok: false,
                    attempts_made,
                    status: None,
                    body: None,
                    error: Some(format!("runtime_signature_failed:{error}")),
                };
            }
        };

        let response = reqwest::Client::new()
            .post(url.as_str())
            .header("x-oa-runtime-signature", signature)
            .header("x-oa-runtime-body-sha256", payload_hash.as_str())
            .header(
                "x-oa-runtime-key-id",
                state.config.runtime_signing_key_id.as_str(),
            )
            .header("x-request-id", format!("req_{}", Uuid::new_v4().simple()))
            .header("content-type", "application/json")
            .timeout(timeout)
            .json(payload)
            .send()
            .await;

        match response {
            Ok(response) => {
                let status = response.status();
                let status_code = status.as_u16();
                let body = match response.bytes().await {
                    Ok(bytes) => serde_json::from_slice::<serde_json::Value>(&bytes)
                        .ok()
                        .or_else(|| {
                            non_empty(String::from_utf8_lossy(&bytes).to_string())
                                .map(serde_json::Value::String)
                        }),
                    Err(_) => None,
                };

                last_status = Some(status_code);
                last_body = body.clone();
                if status.is_success() {
                    return RuntimeDeliveryForwardResult {
                        ok: true,
                        attempts_made,
                        status: Some(status_code),
                        body,
                        error: None,
                    };
                }

                last_error = Some(format!("runtime_http_{status_code}"));
            }
            Err(error) => {
                last_error = Some(error.to_string());
            }
        }

        if attempt < attempts {
            if let Err(error) = state
                ._domain_store
                .mark_webhook_event_retrying(
                    webhook_event_id,
                    attempts_made,
                    last_status,
                    last_body.clone(),
                    last_error.clone(),
                )
                .await
            {
                tracing::warn!(
                    webhook_event_id,
                    attempt = attempts_made,
                    error = %error,
                    "failed to persist webhook retry transition"
                );
            }

            if backoff_ms > 0 {
                tokio::time::sleep(std::time::Duration::from_millis(backoff_ms)).await;
            }
        }
    }

    RuntimeDeliveryForwardResult {
        ok: false,
        attempts_made,
        status: last_status,
        body: last_body,
        error: last_error.or_else(|| Some("runtime_forward_failed".to_string())),
    }
}

fn runtime_forward_signature_token(
    secret: &str,
    ttl_seconds: u64,
) -> Result<String, anyhow::Error> {
    let now = Utc::now().timestamp().max(0) as u64;
    let payload = serde_json::json!({
        "iat": now,
        "exp": now + ttl_seconds.max(1),
        "nonce": format!("nonce-{}", Uuid::new_v4().simple()),
    });
    let payload_bytes = serde_json::to_vec(&payload)?;
    let payload_segment = URL_SAFE_NO_PAD.encode(payload_bytes);

    let mut mac = HmacSha256::new_from_slice(secret.as_bytes())?;
    mac.update(payload_segment.as_bytes());
    let signature = mac.finalize().into_bytes();
    let signature_segment = URL_SAFE_NO_PAD.encode(signature);

    Ok(format!("v1.{payload_segment}.{signature_segment}"))
}

async fn shouts_index(
    State(state): State<AppState>,
    Query(query): Query<ShoutsIndexQuery>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let zone = normalize_shout_zone(query.zone.as_deref(), "zone")?;
    let limit = parse_shout_limit(query.limit.as_deref(), "limit", 50, 200)?;
    let before_id = parse_shout_optional_u64(query.before_id.as_deref(), "before_id")?;
    let since = query
        .since
        .as_deref()
        .map(str::trim)
        .filter(|value| !value.is_empty())
        .map(|value| {
            parse_rfc3339_utc(value)
                .map_err(|_| validation_error("since", "The since field must be a valid date."))
        })
        .transpose()?;

    let rows = state
        ._domain_store
        .list_shouts(zone.as_deref(), limit, before_id, since)
        .await
        .map_err(map_domain_store_error)?;

    let mut author_cache: HashMap<String, serde_json::Value> = HashMap::new();
    let mut data = Vec::with_capacity(rows.len());
    for shout in &rows {
        data.push(shout_payload(&state, shout, &mut author_cache).await);
    }

    let next_cursor = if rows.len() == limit {
        rows.last().map(|row| row.id.to_string())
    } else {
        None
    };

    Ok((
        StatusCode::OK,
        Json(serde_json::json!({
            "data": data,
            "meta": {
                "nextCursor": next_cursor,
            }
        })),
    ))
}

const COMPUTE_DEFAULT_CAPABILITY: &str = "oa.sandbox_run.v1";
const COMPUTE_DASHBOARD_TIMEOUT_MS: u64 = 1_500;

async fn feed_page(
    State(state): State<AppState>,
    headers: HeaderMap,
    uri: axum::http::Uri,
    Query(query): Query<FeedPageQuery>,
) -> Result<Response, (StatusCode, Json<ApiErrorResponse>)> {
    let zone = normalize_shout_zone(query.zone.as_deref(), "zone").and_then(|zone| match zone {
        Some(value) if value == "all" => Ok(None),
        _ => Ok(zone),
    })?;
    let limit = parse_shout_limit(query.limit.as_deref(), "limit", 50, 200)?;
    let before_id = parse_shout_optional_u64(query.before_id.as_deref(), "before_id")?;
    let since = parse_feed_since(query.since.as_deref())?;

    let rows = state
        ._domain_store
        .list_shouts(zone.as_deref(), limit, before_id, since)
        .await
        .map_err(map_domain_store_error)?;
    let zones = state
        ._domain_store
        .top_shout_zones(20)
        .await
        .map_err(map_domain_store_error)?;

    let status = query_param_value(uri.query(), "status");
    let next_cursor = if rows.len() == limit {
        rows.last().map(|row| row.id.to_string())
    } else {
        None
    };
    let since_query = query
        .since
        .as_deref()
        .map(str::trim)
        .filter(|value| !value.is_empty())
        .map(ToString::to_string);
    let items = feed_items_for_web(&state, &rows).await;
    let zone_views = feed_zones_for_web(&zones, zone.as_deref());
    let session = session_bundle_from_headers(&state, &headers)
        .await
        .ok()
        .map(|bundle| SessionView {
            display_name: bundle.user.name.clone(),
            email: bundle.user.email.clone(),
        });

    let page = WebPage {
        title: format!("Feed ({limit})"),
        path: "/feed".to_string(),
        session,
        body: WebBody::Feed {
            status,
            items,
            zones: zone_views,
            next_cursor,
            current_zone: zone,
            page_limit: limit as u64,
            since: since_query,
        },
    };

    Ok(web_response_for_page(&state, &headers, &uri, page).await)
}

async fn feed_main_fragment(
    State(state): State<AppState>,
    headers: HeaderMap,
    uri: axum::http::Uri,
    Query(query): Query<FeedPageQuery>,
) -> Result<Response, (StatusCode, Json<ApiErrorResponse>)> {
    let htmx = classify_htmx_request(&headers);
    let htmx_mode = state.route_split.htmx_mode_for_path("/feed").await;
    if !htmx.is_hx_request || htmx_mode.mode == HtmxModeTarget::FullPage {
        let suffix = uri
            .query()
            .map(|query| format!("?{query}"))
            .unwrap_or_default();
        return Ok(Redirect::temporary(&format!("/feed{suffix}")).into_response());
    }

    let zone = normalize_shout_zone(query.zone.as_deref(), "zone").and_then(|zone| match zone {
        Some(value) if value == "all" => Ok(None),
        _ => Ok(zone),
    })?;
    let limit = parse_shout_limit(query.limit.as_deref(), "limit", 50, 200)?;
    let before_id = parse_shout_optional_u64(query.before_id.as_deref(), "before_id")?;
    let since = parse_feed_since(query.since.as_deref())?;
    let rows = state
        ._domain_store
        .list_shouts(zone.as_deref(), limit, before_id, since)
        .await
        .map_err(map_domain_store_error)?;
    let zones = state
        ._domain_store
        .top_shout_zones(20)
        .await
        .map_err(map_domain_store_error)?;
    let status = query_param_value(uri.query(), "status");
    let next_cursor = if rows.len() == limit {
        rows.last().map(|row| row.id.to_string())
    } else {
        None
    };
    let since_query = query
        .since
        .as_deref()
        .map(str::trim)
        .filter(|value| !value.is_empty())
        .map(ToString::to_string);
    let items = feed_items_for_web(&state, &rows).await;
    let zone_views = feed_zones_for_web(&zones, zone.as_deref());
    let session = session_bundle_from_headers(&state, &headers)
        .await
        .ok()
        .map(|bundle| SessionView {
            display_name: bundle.user.name.clone(),
            email: bundle.user.email.clone(),
        });

    Ok(feed_main_select_fragment_response(
        session.as_ref(),
        status.as_deref(),
        &items,
        &zone_views,
        next_cursor.as_deref(),
        zone.as_deref(),
        limit as u64,
        since_query.as_deref(),
    ))
}

async fn feed_items_fragment(
    State(state): State<AppState>,
    headers: HeaderMap,
    uri: axum::http::Uri,
    Query(query): Query<FeedPageQuery>,
) -> Result<Response, (StatusCode, Json<ApiErrorResponse>)> {
    let htmx = classify_htmx_request(&headers);
    let htmx_mode = state.route_split.htmx_mode_for_path("/feed").await;
    if !htmx.is_hx_request || htmx_mode.mode == HtmxModeTarget::FullPage {
        let suffix = uri
            .query()
            .map(|query| format!("?{query}"))
            .unwrap_or_default();
        return Ok(Redirect::temporary(&format!("/feed{suffix}")).into_response());
    }

    let zone = normalize_shout_zone(query.zone.as_deref(), "zone").and_then(|zone| match zone {
        Some(value) if value == "all" => Ok(None),
        _ => Ok(zone),
    })?;
    let limit = parse_shout_limit(query.limit.as_deref(), "limit", 50, 200)?;
    let before_id = parse_shout_optional_u64(query.before_id.as_deref(), "before_id")?;
    let since = parse_feed_since(query.since.as_deref())?;
    let rows = state
        ._domain_store
        .list_shouts(zone.as_deref(), limit, before_id, since)
        .await
        .map_err(map_domain_store_error)?;
    let next_cursor = if rows.len() == limit {
        rows.last().map(|row| row.id.to_string())
    } else {
        None
    };
    let since_query = query
        .since
        .as_deref()
        .map(str::trim)
        .filter(|value| !value.is_empty())
        .map(ToString::to_string);
    let items = feed_items_for_web(&state, &rows).await;

    Ok(feed_items_append_fragment_response(
        &items,
        next_cursor.as_deref(),
        zone.as_deref(),
        limit as u64,
        since_query.as_deref(),
    ))
}

async fn shouts_zones(
    State(state): State<AppState>,
    Query(query): Query<ShoutsZonesQuery>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let limit = parse_shout_limit(query.limit.as_deref(), "limit", 20, 100)?;
    let zones = state
        ._domain_store
        .top_shout_zones(limit)
        .await
        .map_err(map_domain_store_error)?;

    Ok((
        StatusCode::OK,
        Json(serde_json::json!({
            "data": zones,
        })),
    ))
}

async fn shouts_store(
    State(state): State<AppState>,
    headers: HeaderMap,
    Json(payload): Json<ShoutStoreRequestPayload>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;

    let body_raw = payload
        .body
        .or(payload.text)
        .and_then(non_empty)
        .ok_or_else(|| validation_error("body", "The body field is required."))?;
    if body_raw.chars().count() > 2000 {
        return Err(validation_error(
            "body",
            "The body field may not be greater than 2000 characters.",
        ));
    }
    let zone = normalize_shout_zone(payload.zone.as_deref(), "zone")?;

    let shout = state
        ._domain_store
        .create_shout(CreateShoutInput {
            user_id: bundle.user.id.clone(),
            zone,
            body: body_raw,
        })
        .await
        .map_err(map_domain_store_error)?;

    let mut author_cache = HashMap::new();
    let data = shout_payload(&state, &shout, &mut author_cache).await;

    state.observability.audit(
        AuditEvent::new("shouts.created", request_id.clone())
            .with_user_id(bundle.user.id)
            .with_session_id(bundle.session.session_id)
            .with_org_id(bundle.session.active_org_id)
            .with_device_id(bundle.session.device_id)
            .with_attribute("shout_id", shout.id.to_string())
            .with_attribute(
                "zone",
                shout.zone.clone().unwrap_or_else(|| "none".to_string()),
            )
            .with_attribute("body_length", shout.body.chars().count().to_string()),
    );
    state
        .observability
        .increment_counter("shouts.created", &request_id);

    Ok((
        StatusCode::CREATED,
        Json(serde_json::json!({
            "data": data,
        })),
    ))
}

async fn whispers_index(
    State(state): State<AppState>,
    headers: HeaderMap,
    Query(query): Query<WhispersIndexQuery>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let with = normalize_whisper_lookup(query.with.as_deref(), "with")?;
    let with_user = if let Some(lookup) = with.as_deref() {
        Some(
            state
                .auth
                .user_by_id_or_handle(lookup)
                .await
                .ok_or_else(|| not_found_error("Not found."))?,
        )
    } else {
        None
    };
    let limit = parse_shout_limit(query.limit.as_deref(), "limit", 50, 200)?;
    let before_id = parse_shout_optional_u64(query.before_id.as_deref(), "before_id")?;

    let rows = state
        ._domain_store
        .list_whispers_for(
            &bundle.user.id,
            with_user.as_ref().map(|user| user.id.as_str()),
            limit,
            before_id,
        )
        .await
        .map_err(map_domain_store_error)?;

    let mut user_cache: HashMap<String, serde_json::Value> = HashMap::new();
    let mut data = Vec::with_capacity(rows.len());
    for whisper in &rows {
        data.push(whisper_payload(&state, whisper, &mut user_cache).await);
    }

    let next_cursor = if rows.len() == limit {
        rows.last().map(|row| row.id.to_string())
    } else {
        None
    };

    let mut audit = AuditEvent::new("whispers.list_viewed", request_id.clone())
        .with_user_id(bundle.user.id)
        .with_session_id(bundle.session.session_id)
        .with_org_id(bundle.session.active_org_id)
        .with_device_id(bundle.session.device_id)
        .with_attribute("limit", limit.to_string())
        .with_attribute("returned_count", rows.len().to_string());
    if let Some(with_user) = with_user.as_ref() {
        audit = audit
            .with_attribute("with_user_id", with_user.id.clone())
            .with_attribute("with_user_handle", user_handle_from_email(&with_user.email));
    }
    state.observability.audit(audit);
    state
        .observability
        .increment_counter("whispers.list_viewed", &request_id);

    Ok((
        StatusCode::OK,
        Json(serde_json::json!({
            "data": data,
            "meta": {
                "nextCursor": next_cursor,
                "with": with_user
                    .as_ref()
                    .map(|user| user_handle_from_email(&user.email)),
            }
        })),
    ))
}

async fn whispers_store(
    State(state): State<AppState>,
    headers: HeaderMap,
    Json(payload): Json<WhisperStoreRequestPayload>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let recipient = resolve_whisper_recipient(&state, &payload).await?;
    let body = payload
        .body
        .and_then(non_empty)
        .ok_or_else(|| validation_error("body", "The body field is required."))?;
    if body.chars().count() > 5000 {
        return Err(validation_error(
            "body",
            "The body field may not be greater than 5000 characters.",
        ));
    }
    if recipient.id == bundle.user.id {
        return Err(validation_error("recipientId", "Cannot whisper yourself."));
    }

    let whisper = state
        ._domain_store
        .send_whisper(SendWhisperInput {
            sender_id: bundle.user.id.clone(),
            recipient_id: recipient.id.clone(),
            body,
        })
        .await
        .map_err(map_domain_store_error)?;

    let mut user_cache = HashMap::new();
    let data = whisper_payload(&state, &whisper, &mut user_cache).await;

    state.observability.audit(
        AuditEvent::new("whispers.sent", request_id.clone())
            .with_user_id(bundle.user.id)
            .with_session_id(bundle.session.session_id)
            .with_org_id(bundle.session.active_org_id)
            .with_device_id(bundle.session.device_id)
            .with_attribute("whisper_id", whisper.id.to_string())
            .with_attribute("recipient_id", whisper.recipient_id.clone())
            .with_attribute("recipient_handle", user_handle_from_email(&recipient.email))
            .with_attribute("body_length", whisper.body.chars().count().to_string()),
    );
    state
        .observability
        .increment_counter("whispers.sent", &request_id);

    Ok((
        StatusCode::CREATED,
        Json(serde_json::json!({
            "data": data,
        })),
    ))
}

async fn whispers_read(
    State(state): State<AppState>,
    Path(id): Path<String>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let whisper_id = id
        .trim()
        .parse::<u64>()
        .map_err(|_| not_found_error("Not found."))?;

    let whisper = state
        ._domain_store
        .whisper_by_id(whisper_id)
        .await
        .map_err(map_domain_store_error)?
        .ok_or_else(|| not_found_error("Not found."))?;
    if whisper.recipient_id != bundle.user.id {
        return Err(forbidden_error("Forbidden."));
    }

    let updated = state
        ._domain_store
        .mark_whisper_read(whisper_id, &bundle.user.id)
        .await
        .map_err(map_domain_store_error)?;

    let mut user_cache = HashMap::new();
    let data = whisper_payload(&state, &updated, &mut user_cache).await;

    state.observability.audit(
        AuditEvent::new("whispers.marked_read", request_id.clone())
            .with_user_id(bundle.user.id)
            .with_session_id(bundle.session.session_id)
            .with_org_id(bundle.session.active_org_id)
            .with_device_id(bundle.session.device_id)
            .with_attribute("whisper_id", updated.id.to_string())
            .with_attribute("sender_id", updated.sender_id.clone())
            .with_attribute("recipient_id", updated.recipient_id.clone()),
    );
    state
        .observability
        .increment_counter("whispers.marked_read", &request_id);

    Ok((StatusCode::OK, Json(serde_json::json!({ "data": data }))))
}

fn normalize_whisper_lookup(
    raw: Option<&str>,
    field: &'static str,
) -> Result<Option<String>, (StatusCode, Json<ApiErrorResponse>)> {
    let Some(raw) = raw.map(str::trim) else {
        return Ok(None);
    };
    if raw.is_empty() {
        return Ok(None);
    }

    normalize_whisper_identifier(raw, field, true).map(Some)
}

fn normalize_whisper_identifier(
    raw: &str,
    field: &'static str,
    lowercase: bool,
) -> Result<String, (StatusCode, Json<ApiErrorResponse>)> {
    let trimmed = raw.trim();
    if trimmed.is_empty() {
        return Err(validation_error(
            field,
            &format!("The {field} field is required."),
        ));
    }
    if trimmed.chars().count() > 64 {
        return Err(validation_error(
            field,
            &format!("The {field} field may not be greater than 64 characters."),
        ));
    }

    let normalized = if lowercase {
        trimmed.to_ascii_lowercase()
    } else {
        trimmed.to_string()
    };
    let valid = normalized
        .chars()
        .all(|character| character.is_ascii_alphanumeric() || matches!(character, ':' | '_' | '-'));
    if !valid {
        return Err(validation_error(
            field,
            &format!("The {field} field format is invalid."),
        ));
    }
    Ok(normalized)
}

async fn resolve_whisper_recipient(
    state: &AppState,
    payload: &WhisperStoreRequestPayload,
) -> Result<AuthUser, (StatusCode, Json<ApiErrorResponse>)> {
    let recipient_id = payload.recipient_id.clone().and_then(non_empty);
    let recipient_handle = payload.recipient_handle.clone().and_then(non_empty);

    if recipient_id.is_some() && recipient_handle.is_some() {
        return Err(validation_error(
            "recipientId",
            "The recipientId field prohibits recipientHandle.",
        ));
    }

    let lookup = if let Some(recipient_id) = recipient_id {
        normalize_whisper_identifier(&recipient_id, "recipientId", false)?
    } else if let Some(recipient_handle) = recipient_handle {
        normalize_whisper_identifier(&recipient_handle, "recipientHandle", true)?
    } else {
        return Err(validation_error(
            "recipientId",
            "The recipientId field is required when recipientHandle is not present.",
        ));
    };

    state
        .auth
        .user_by_id_or_handle(&lookup)
        .await
        .ok_or_else(|| not_found_error("Not found."))
}

fn parse_shout_limit(
    raw: Option<&str>,
    field: &'static str,
    default: usize,
    max: usize,
) -> Result<usize, (StatusCode, Json<ApiErrorResponse>)> {
    let Some(raw) = raw.map(str::trim).filter(|value| !value.is_empty()) else {
        return Ok(default);
    };
    let parsed = raw
        .parse::<usize>()
        .map_err(|_| validation_error(field, &format!("The {field} field must be an integer.")))?;
    if parsed < 1 {
        return Err(validation_error(
            field,
            &format!("The {field} field must be at least 1."),
        ));
    }
    Ok(parsed.min(max))
}

fn parse_feed_since(
    raw: Option<&str>,
) -> Result<Option<chrono::DateTime<Utc>>, (StatusCode, Json<ApiErrorResponse>)> {
    let Some(raw) = raw.map(str::trim).filter(|value| !value.is_empty()) else {
        return Ok(None);
    };
    if let Ok(parsed) = parse_rfc3339_utc(raw) {
        return Ok(Some(parsed));
    }
    if let Ok(parsed_date) = NaiveDate::parse_from_str(raw, "%Y-%m-%d") {
        if let Some(parsed_datetime) = parsed_date.and_hms_opt(0, 0, 0) {
            return Ok(Some(parsed_datetime.and_utc()));
        }
    }

    Err(validation_error(
        "since",
        "The since field must be a valid date.",
    ))
}

fn parse_shout_optional_u64(
    raw: Option<&str>,
    field: &'static str,
) -> Result<Option<u64>, (StatusCode, Json<ApiErrorResponse>)> {
    let Some(raw) = raw.map(str::trim).filter(|value| !value.is_empty()) else {
        return Ok(None);
    };
    let parsed = raw
        .parse::<u64>()
        .map_err(|_| validation_error(field, &format!("The {field} field must be an integer.")))?;
    if parsed < 1 {
        return Err(validation_error(
            field,
            &format!("The {field} field must be at least 1."),
        ));
    }
    Ok(Some(parsed))
}

fn normalize_shout_zone(
    raw: Option<&str>,
    field: &'static str,
) -> Result<Option<String>, (StatusCode, Json<ApiErrorResponse>)> {
    let Some(raw) = raw.map(str::trim) else {
        return Ok(None);
    };
    if raw.is_empty() {
        return Ok(None);
    }
    if raw.chars().count() > 64 {
        return Err(validation_error(
            field,
            &format!("The {field} field may not be greater than 64 characters."),
        ));
    }

    let normalized = raw.to_ascii_lowercase();
    let valid = normalized
        .chars()
        .all(|character| character.is_ascii_alphanumeric() || matches!(character, ':' | '_' | '-'));
    if !valid {
        return Err(validation_error(
            field,
            &format!("The {field} field format is invalid."),
        ));
    }

    Ok(Some(normalized))
}

async fn shout_payload(
    state: &AppState,
    shout: &ShoutRecord,
    author_cache: &mut HashMap<String, serde_json::Value>,
) -> serde_json::Value {
    let author = if let Some(cached) = author_cache.get(&shout.user_id).cloned() {
        cached
    } else {
        let resolved = if let Some(user) = state.auth.user_by_id(&shout.user_id).await {
            serde_json::json!({
                "id": user.id,
                "name": user.name,
                "handle": user_handle_from_email(&user.email),
                "avatar": serde_json::Value::Null,
            })
        } else {
            serde_json::json!({
                "id": shout.user_id.clone(),
                "name": "Unknown",
                "handle": "user",
                "avatar": serde_json::Value::Null,
            })
        };
        author_cache.insert(shout.user_id.clone(), resolved.clone());
        resolved
    };

    serde_json::json!({
        "id": shout.id,
        "zone": shout.zone.clone(),
        "body": shout.body.clone(),
        "visibility": shout.visibility.clone(),
        "author": author,
        "createdAt": timestamp(shout.created_at),
        "updatedAt": timestamp(shout.updated_at),
    })
}

async fn feed_items_for_web(state: &AppState, rows: &[ShoutRecord]) -> Vec<FeedItemView> {
    let mut author_handle_cache: HashMap<String, String> = HashMap::new();
    let mut items = Vec::with_capacity(rows.len());

    for row in rows {
        let author_handle = if let Some(cached) = author_handle_cache.get(&row.user_id) {
            cached.clone()
        } else {
            let resolved = if let Some(user) = state.auth.user_by_id(&row.user_id).await {
                user_handle_from_email(&user.email)
            } else {
                "user".to_string()
            };
            author_handle_cache.insert(row.user_id.clone(), resolved.clone());
            resolved
        };

        let zone = row
            .zone
            .as_deref()
            .map(str::trim)
            .filter(|value| !value.is_empty())
            .unwrap_or("global")
            .to_string();

        items.push(FeedItemView {
            id: row.id.to_string(),
            zone,
            author_handle,
            body: row.body.clone(),
            created_at: timestamp(row.created_at),
        });
    }

    items
}

fn feed_zones_for_web(zones: &[ZoneCount], active_zone: Option<&str>) -> Vec<FeedZoneView> {
    zones
        .iter()
        .map(|zone| FeedZoneView {
            zone: zone.zone.clone(),
            count_24h: zone.count24h,
            is_active: active_zone
                .map(|active| active.eq_ignore_ascii_case(&zone.zone))
                .unwrap_or(false),
        })
        .collect()
}

async fn whisper_user_payload(
    state: &AppState,
    user_id: &str,
    user_cache: &mut HashMap<String, serde_json::Value>,
) -> serde_json::Value {
    if let Some(cached) = user_cache.get(user_id).cloned() {
        return cached;
    }

    let resolved = if let Some(user) = state.auth.user_by_id(user_id).await {
        serde_json::json!({
            "id": user.id,
            "name": user.name,
            "handle": user_handle_from_email(&user.email),
            "avatar": serde_json::Value::Null,
        })
    } else {
        serde_json::json!({
            "id": user_id,
            "name": "Unknown",
            "handle": "user",
            "avatar": serde_json::Value::Null,
        })
    };
    user_cache.insert(user_id.to_string(), resolved.clone());
    resolved
}

async fn whisper_payload(
    state: &AppState,
    whisper: &WhisperRecord,
    user_cache: &mut HashMap<String, serde_json::Value>,
) -> serde_json::Value {
    let sender = whisper_user_payload(state, &whisper.sender_id, user_cache).await;
    let recipient = whisper_user_payload(state, &whisper.recipient_id, user_cache).await;

    serde_json::json!({
        "id": whisper.id,
        "body": whisper.body.clone(),
        "sender": sender,
        "recipient": recipient,
        "readAt": whisper.read_at.map(timestamp),
        "createdAt": timestamp(whisper.created_at),
        "updatedAt": timestamp(whisper.updated_at),
    })
}

async fn runtime_internal_secret_fetch(
    State(state): State<AppState>,
    headers: HeaderMap,
    Json(payload): Json<serde_json::Value>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let (lookup_user_id, scope_user_id) = parse_runtime_internal_user_id(payload.get("user_id"))?;
    let provider = normalize_optional_bounded_string(
        normalized_json_string(payload.get("provider")),
        "provider",
        32,
    )?
    .ok_or_else(|| validation_error("provider", "The provider field is required."))?
    .to_lowercase();
    if !matches!(provider.as_str(), "resend" | "google") {
        return Err(validation_error(
            "provider",
            "The selected provider is invalid.",
        ));
    }
    let integration_id = normalize_optional_bounded_string(
        normalized_json_string(payload.get("integration_id")),
        "integration_id",
        160,
    )?
    .ok_or_else(|| validation_error("integration_id", "The integration_id field is required."))?;
    let run_id = normalize_optional_bounded_string(
        normalized_json_string(payload.get("run_id")),
        "run_id",
        160,
    )?
    .ok_or_else(|| validation_error("run_id", "The run_id field is required."))?;
    let tool_call_id = normalize_optional_bounded_string(
        normalized_json_string(payload.get("tool_call_id")),
        "tool_call_id",
        160,
    )?
    .ok_or_else(|| validation_error("tool_call_id", "The tool_call_id field is required."))?;
    let org_id = normalize_optional_bounded_string(
        normalized_json_string(payload.get("org_id")),
        "org_id",
        160,
    )?;

    let integration = state
        ._domain_store
        .find_active_integration_secret(&lookup_user_id, &provider)
        .await
        .map_err(map_domain_store_error)?;
    let Some(integration) = integration else {
        let mut audit = AuditEvent::new(
            "runtime.internal.secret.fetch.not_found",
            request_id.clone(),
        )
        .with_attribute("user_id", lookup_user_id)
        .with_attribute("provider", provider.clone())
        .with_attribute("integration_id", integration_id.clone())
        .with_attribute("run_id", run_id.clone())
        .with_attribute("tool_call_id", tool_call_id.clone());
        if let Some(org_id) = org_id.clone() {
            audit = audit.with_attribute("org_id", org_id);
        }
        state.observability.audit(audit);
        state
            .observability
            .increment_counter("runtime.internal.secret.fetch.not_found", &request_id);
        return Err(runtime_internal_error(
            StatusCode::NOT_FOUND,
            "secret_not_found",
            "active provider secret not found",
        ));
    };

    let secret = integration
        .encrypted_secret
        .as_deref()
        .map(str::trim)
        .filter(|value| !value.is_empty())
        .map(ToString::to_string)
        .ok_or_else(|| {
            runtime_internal_error(
                StatusCode::NOT_FOUND,
                "secret_not_found",
                "active provider secret not found",
            )
        })?;

    let mut audit = AuditEvent::new("runtime.internal.secret.fetch.accepted", request_id.clone())
        .with_attribute("user_id", integration.user_id.clone())
        .with_attribute("provider", integration.provider.clone())
        .with_attribute("integration_id", integration_id.clone())
        .with_attribute("run_id", run_id.clone())
        .with_attribute("tool_call_id", tool_call_id.clone());
    if let Some(org_id) = org_id.clone() {
        audit = audit.with_attribute("org_id", org_id);
    }
    state.observability.audit(audit);
    state
        .observability
        .increment_counter("runtime.internal.secret.fetch.accepted", &request_id);

    Ok(ok_data(serde_json::json!({
        "provider": integration.provider,
        "secret": secret,
        "cache_ttl_ms": state.config.runtime_internal_secret_cache_ttl_ms,
        "scope": {
            "user_id": scope_user_id,
            "provider": provider,
            "integration_id": integration_id,
            "run_id": run_id,
            "tool_call_id": tool_call_id,
            "org_id": org_id,
        },
        "fetched_at": timestamp(Utc::now()),
    })))
}

async fn agent_payments_wallet(
    State(state): State<AppState>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let wallet = state
        ._domain_store
        .find_user_spark_wallet(&bundle.user.id)
        .await
        .map_err(map_domain_store_error)?;

    let Some(wallet) = wallet else {
        state.observability.audit(
            AuditEvent::new("agent_payments.wallet_missing", request_id.clone())
                .with_user_id(bundle.user.id)
                .with_session_id(bundle.session.session_id)
                .with_org_id(bundle.session.active_org_id)
                .with_device_id(bundle.session.device_id),
        );
        state
            .observability
            .increment_counter("agent_payments.wallet_missing", &request_id);
        return Err(not_found_error("wallet_not_found"));
    };

    state.observability.audit(
        AuditEvent::new("agent_payments.wallet_viewed", request_id.clone())
            .with_user_id(bundle.user.id)
            .with_session_id(bundle.session.session_id)
            .with_org_id(bundle.session.active_org_id)
            .with_device_id(bundle.session.device_id)
            .with_attribute("wallet_id", wallet.wallet_id.clone())
            .with_attribute("status", wallet.status.clone()),
    );
    state
        .observability
        .increment_counter("agent_payments.wallet_viewed", &request_id);

    Ok(ok_data(serde_json::json!({
        "wallet": agent_payments_wallet_payload(&wallet)
    })))
}

async fn agent_payments_upsert_wallet(
    State(state): State<AppState>,
    headers: HeaderMap,
    Json(payload): Json<AgentPaymentsWalletUpsertRequestPayload>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let mnemonic = payload.mnemonic.and_then(non_empty);
    if let Some(candidate) = mnemonic.as_deref() {
        if candidate.chars().count() < 20 {
            return Err(validation_error(
                "mnemonic",
                "The mnemonic field must be at least 20 characters.",
            ));
        }
    }

    let action = if mnemonic.is_some() {
        "imported"
    } else {
        "ensured"
    };
    let wallet = upsert_agent_wallet_for_user(&state, &bundle.user.id, mnemonic).await?;

    state.observability.audit(
        AuditEvent::new("agent_payments.wallet_upserted", request_id.clone())
            .with_user_id(bundle.user.id)
            .with_session_id(bundle.session.session_id)
            .with_org_id(bundle.session.active_org_id)
            .with_device_id(bundle.session.device_id)
            .with_attribute("action", action.to_string())
            .with_attribute("wallet_id", wallet.wallet_id.clone())
            .with_attribute("status", wallet.status.clone()),
    );
    state
        .observability
        .increment_counter("agent_payments.wallet_upserted", &request_id);

    Ok(ok_data(serde_json::json!({
        "wallet": agent_payments_wallet_payload(&wallet),
        "action": action,
    })))
}

async fn agent_payments_balance(
    State(state): State<AppState>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let existing = state
        ._domain_store
        .find_user_spark_wallet(&bundle.user.id)
        .await
        .map_err(map_domain_store_error)?;
    let Some(existing) = existing else {
        state.observability.audit(
            AuditEvent::new("agent_payments.balance_wallet_missing", request_id.clone())
                .with_user_id(bundle.user.id)
                .with_session_id(bundle.session.session_id)
                .with_org_id(bundle.session.active_org_id)
                .with_device_id(bundle.session.device_id),
        );
        state
            .observability
            .increment_counter("agent_payments.balance_wallet_missing", &request_id);
        return Err(not_found_error("wallet_not_found"));
    };

    let wallet = sync_agent_wallet(&state, existing).await?;
    state.observability.audit(
        AuditEvent::new("agent_payments.balance_viewed", request_id.clone())
            .with_user_id(bundle.user.id)
            .with_session_id(bundle.session.session_id)
            .with_org_id(bundle.session.active_org_id)
            .with_device_id(bundle.session.device_id)
            .with_attribute("wallet_id", wallet.wallet_id.clone())
            .with_attribute(
                "balance_sats",
                wallet.last_balance_sats.unwrap_or_default().to_string(),
            ),
    );
    state
        .observability
        .increment_counter("agent_payments.balance_viewed", &request_id);

    Ok(ok_data(serde_json::json!({
        "walletId": wallet.wallet_id,
        "balanceSats": wallet.last_balance_sats,
        "sparkAddress": wallet.spark_address,
        "lightningAddress": wallet.lightning_address,
        "lastSyncedAt": wallet.last_synced_at.map(timestamp),
    })))
}

async fn agent_payments_create_invoice(
    State(state): State<AppState>,
    headers: HeaderMap,
    Json(payload): Json<AgentPaymentsCreateInvoiceRequestPayload>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;

    if payload.amount_sats < 1 {
        return Err(validation_error(
            "amountSats",
            "The amountSats field must be at least 1.",
        ));
    }
    let description = normalize_optional_bounded_string(payload.description, "description", 200)?;
    let _wallet = ensure_agent_wallet_for_user(&state, &bundle.user.id).await?;

    let payment_request = format!("lnbc{}n1{}", payload.amount_sats, Uuid::new_v4().simple());
    let expires_at = timestamp(Utc::now() + chrono::Duration::minutes(15));
    let raw = serde_json::json!({
        "paymentRequest": payment_request,
        "amountSats": payload.amount_sats,
        "description": description.clone(),
        "expiresAt": expires_at.clone(),
    });

    state.observability.audit(
        AuditEvent::new("agent_payments.invoice_created", request_id.clone())
            .with_user_id(bundle.user.id)
            .with_session_id(bundle.session.session_id)
            .with_org_id(bundle.session.active_org_id)
            .with_device_id(bundle.session.device_id)
            .with_attribute("amount_sats", payload.amount_sats.to_string()),
    );
    state
        .observability
        .increment_counter("agent_payments.invoice_created", &request_id);

    Ok(ok_data(serde_json::json!({
        "invoice": {
            "paymentRequest": payment_request,
            "amountSats": payload.amount_sats,
            "description": description,
            "expiresAt": expires_at,
            "raw": raw,
        }
    })))
}

async fn agent_payments_pay_invoice(
    State(state): State<AppState>,
    headers: HeaderMap,
    Json(payload): Json<AgentPaymentsPayInvoiceRequestPayload>,
) -> Result<Response, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let invoice = non_empty(payload.invoice).ok_or_else(|| {
        validation_error(
            "invoice",
            "The invoice field is required and must be a string.",
        )
    })?;
    if invoice.chars().count() < 20 {
        return Err(validation_error(
            "invoice",
            "The invoice field must be at least 20 characters.",
        ));
    }

    if let Some(value) = payload.max_amount_sats {
        if value < 1 {
            return Err(validation_error(
                "maxAmountSats",
                "The maxAmountSats field must be at least 1.",
            ));
        }
    }
    if let Some(value) = payload.max_amount_msats {
        if value < 1000 {
            return Err(validation_error(
                "maxAmountMsats",
                "The maxAmountMsats field must be at least 1000.",
            ));
        }
    }
    if let Some(host) = payload.host.as_deref() {
        if host.trim().chars().count() > 255 {
            return Err(validation_error(
                "host",
                "Value may not be greater than 255 characters.",
            ));
        }
    }

    let timeout_ms = payload.timeout_ms.unwrap_or(12_000);
    if !(1_000..=120_000).contains(&timeout_ms) {
        return Err(validation_error(
            "timeoutMs",
            "The timeoutMs field must be between 1000 and 120000.",
        ));
    }

    let quoted_amount_msats = Bolt11::amount_msats(&invoice);
    let max_amount_msats = payload
        .max_amount_msats
        .or_else(|| {
            payload
                .max_amount_sats
                .map(|value| value.saturating_mul(1000))
        })
        .or(quoted_amount_msats);

    let Some(max_amount_msats) = max_amount_msats.filter(|value| *value > 0) else {
        state.observability.audit(
            AuditEvent::new("agent_payments.invoice_pay_rejected", request_id.clone())
                .with_user_id(bundle.user.id)
                .with_session_id(bundle.session.session_id)
                .with_org_id(bundle.session.active_org_id)
                .with_device_id(bundle.session.device_id)
                .with_attribute("reason", "max_amount_missing".to_string()),
        );
        state
            .observability
            .increment_counter("agent_payments.invoice_pay_rejected", &request_id);
        return Ok(
            (
                StatusCode::UNPROCESSABLE_ENTITY,
                Json(serde_json::json!({
                    "error": {
                        "code": "max_amount_missing",
                        "message": "Unable to resolve max payment amount; provide maxAmountSats or maxAmountMsats.",
                    }
                })),
            )
                .into_response(),
        );
    };

    let wallet = ensure_agent_wallet_for_user(&state, &bundle.user.id).await?;
    let payer_kind = l402_invoice_payer_kind();
    let payment = match agent_payments_pay_invoice_with_adapter(
        &state,
        payer_kind.as_str(),
        &bundle.user.id,
        &wallet,
        &invoice,
        max_amount_msats,
        timeout_ms,
        payload.host.clone(),
    )
    .await
    {
        Ok(result) => result,
        Err(error) => {
            state.observability.audit(
                AuditEvent::new("agent_payments.invoice_pay_failed", request_id.clone())
                    .with_user_id(bundle.user.id)
                    .with_session_id(bundle.session.session_id)
                    .with_org_id(bundle.session.active_org_id)
                    .with_device_id(bundle.session.device_id)
                    .with_attribute(
                        "quoted_amount_msats",
                        quoted_amount_msats.unwrap_or_default().to_string(),
                    )
                    .with_attribute("max_amount_msats", max_amount_msats.to_string())
                    .with_attribute("payment_backend", payer_kind)
                    .with_attribute("error_code", error.code.clone())
                    .with_attribute("error_message", error.message.clone()),
            );
            state
                .observability
                .increment_counter("agent_payments.invoice_pay_failed", &request_id);
            return Ok((
                error.status,
                Json(serde_json::json!({
                    "error": {
                        "code": error.code,
                        "message": error.message,
                    }
                })),
            )
                .into_response());
        }
    };

    state.observability.audit(
        AuditEvent::new("agent_payments.invoice_paid", request_id.clone())
            .with_user_id(bundle.user.id)
            .with_session_id(bundle.session.session_id)
            .with_org_id(bundle.session.active_org_id)
            .with_device_id(bundle.session.device_id)
            .with_attribute("payment_id", payment.payment_id.clone().unwrap_or_default())
            .with_attribute("status", payment.status.clone())
            .with_attribute("payment_backend", payer_kind)
            .with_attribute("max_amount_msats", max_amount_msats.to_string()),
    );
    state
        .observability
        .increment_counter("agent_payments.invoice_paid", &request_id);

    Ok(ok_data(serde_json::json!({
        "payment": {
            "paymentId": payment.payment_id,
            "preimage": payment.preimage.clone(),
            "proofReference": format!("preimage:{}", payment.preimage.chars().take(16).collect::<String>()),
            "quotedAmountMsats": quoted_amount_msats,
            "maxAmountMsats": max_amount_msats,
            "status": payment.status,
            "raw": payment.raw,
        }
    }))
    .into_response())
}

async fn agent_payments_pay_invoice_with_adapter(
    state: &AppState,
    payer_kind: &str,
    user_id: &str,
    wallet: &UserSparkWalletRecord,
    invoice: &str,
    max_amount_msats: u64,
    timeout_ms: u64,
    host: Option<String>,
) -> Result<AgentInvoicePaymentResult, AgentInvoicePaymentError> {
    agent_payments_invoice_cap_guard(invoice, max_amount_msats)?;

    match payer_kind {
        "fake" => {
            agent_payments_pay_invoice_fake(invoice, max_amount_msats, timeout_ms, host).await
        }
        "spark_wallet" => {
            agent_payments_pay_invoice_spark(
                state,
                user_id,
                wallet,
                invoice,
                max_amount_msats,
                timeout_ms,
                host,
            )
            .await
        }
        "lnd_rest" => agent_payments_pay_invoice_lnd(invoice, max_amount_msats, timeout_ms).await,
        _ => Err(agent_payments_error(
            StatusCode::INTERNAL_SERVER_ERROR,
            "invoice_payer_invalid",
            format!("Unknown L402 invoice payer: {payer_kind}"),
        )),
    }
}

fn agent_payments_invoice_cap_guard(
    invoice: &str,
    max_amount_msats: u64,
) -> Result<(), AgentInvoicePaymentError> {
    let Some(quoted_amount_msats) = Bolt11::amount_msats(invoice) else {
        return Ok(());
    };
    if quoted_amount_msats > max_amount_msats {
        return Err(agent_payments_error(
            StatusCode::UNPROCESSABLE_ENTITY,
            "quoted_amount_exceeds_cap",
            "Quoted invoice amount exceeds maxAmountMsats.",
        ));
    }
    Ok(())
}

fn l402_invoice_payer_kind() -> String {
    env_non_empty_any(&["L402_INVOICE_PAYER", "OA_L402_INVOICE_PAYER"])
        .unwrap_or_else(|| {
            if cfg!(test) {
                "fake".to_string()
            } else {
                "spark_wallet".to_string()
            }
        })
        .to_ascii_lowercase()
}

async fn agent_payments_pay_invoice_fake(
    invoice: &str,
    max_amount_msats: u64,
    timeout_ms: u64,
    host: Option<String>,
) -> Result<AgentInvoicePaymentResult, AgentInvoicePaymentError> {
    let preimage = sha256_hex(format!("preimage:{invoice}").as_bytes());
    let payment_hash = sha256_hex(format!("payment:{invoice}").as_bytes());
    let payment_id = format!("fake:{}", &payment_hash[..16]);

    Ok(AgentInvoicePaymentResult {
        payment_id: Some(payment_id.clone()),
        preimage: preimage.clone(),
        status: "completed".to_string(),
        raw: serde_json::json!({
            "paymentId": payment_id,
            "preimage": preimage,
            "status": "completed",
            "maxAmountMsats": max_amount_msats,
            "timeoutMs": timeout_ms,
            "host": host.and_then(non_empty).map(|value| value.to_lowercase()),
        }),
    })
}

async fn agent_payments_pay_invoice_spark(
    _state: &AppState,
    _user_id: &str,
    wallet: &UserSparkWalletRecord,
    invoice: &str,
    max_amount_msats: u64,
    timeout_ms: u64,
    host: Option<String>,
) -> Result<AgentInvoicePaymentResult, AgentInvoicePaymentError> {
    let Some(base_url) = env_non_empty_any(&[
        "SPARK_EXECUTOR_BASE_URL",
        "OA_LIGHTNING_WALLET_EXECUTOR_BASE_URL",
    ]) else {
        return Err(agent_payments_error(
            StatusCode::BAD_GATEWAY,
            "spark_executor_not_configured",
            "Spark wallet executor is not configured in this environment. Set SPARK_EXECUTOR_BASE_URL and SPARK_EXECUTOR_AUTH_TOKEN.",
        ));
    };

    let executor_timeout_ms = env_u64("SPARK_EXECUTOR_TIMEOUT_MS", 20_000);
    let timeout_seconds = executor_timeout_ms.div_ceil(1000).max(1);
    let client = reqwest::Client::builder()
        .timeout(std::time::Duration::from_secs(timeout_seconds))
        .build()
        .map_err(|error| {
            agent_payments_error(
                StatusCode::BAD_GATEWAY,
                "spark_executor_error",
                format!("Failed to build Spark executor client: {error}"),
            )
        })?;

    let mut request = client
        .post(format!(
            "{}/wallets/pay-bolt11",
            base_url.trim_end_matches('/')
        ))
        .header(reqwest::header::ACCEPT, "application/json")
        .header(reqwest::header::CONTENT_TYPE, "application/json");

    if let Some(auth_token) = env_non_empty_any(&[
        "SPARK_EXECUTOR_AUTH_TOKEN",
        "OA_LIGHTNING_WALLET_EXECUTOR_AUTH_TOKEN",
    ]) {
        request = request.bearer_auth(auth_token);
    }

    let normalized_host = host.and_then(non_empty).map(|value| value.to_lowercase());
    let mut payload = serde_json::json!({
        "walletId": wallet.wallet_id,
        "mnemonic": wallet.mnemonic,
        "invoice": invoice,
        "maxAmountMsats": max_amount_msats,
        "timeoutMs": timeout_ms.max(1_000),
    });
    if let Some(value) = normalized_host {
        payload["host"] = serde_json::json!(value);
    }

    let response = request.json(&payload).send().await.map_err(|error| {
        agent_payments_error(
            StatusCode::BAD_GATEWAY,
            "spark_executor_error",
            format!("Spark executor request failed: {error}"),
        )
    })?;
    let status = response.status();
    let body_text = response.text().await.map_err(|error| {
        agent_payments_error(
            StatusCode::BAD_GATEWAY,
            "spark_executor_error",
            format!("Spark executor response read failed: {error}"),
        )
    })?;
    let body = serde_json::from_str::<serde_json::Value>(&body_text).map_err(|error| {
        agent_payments_error(
            StatusCode::BAD_GATEWAY,
            "spark_executor_error",
            format!("Spark executor returned non-JSON response: {error}"),
        )
    })?;

    let payload_failed = body
        .get("ok")
        .and_then(serde_json::Value::as_bool)
        .map(|ok| !ok)
        .unwrap_or(false);
    if !status.is_success() || payload_failed {
        let error = body.get("error").and_then(serde_json::Value::as_object);
        let code = error
            .and_then(|value| value.get("code"))
            .and_then(serde_json::Value::as_str)
            .map(str::trim)
            .filter(|value| !value.is_empty())
            .unwrap_or("spark_executor_error");
        let message = error
            .and_then(|value| value.get("message"))
            .and_then(serde_json::Value::as_str)
            .map(str::trim)
            .filter(|value| !value.is_empty())
            .map(str::to_string)
            .unwrap_or_else(|| {
                format!(
                    "Spark executor request failed with HTTP {}",
                    status.as_u16()
                )
            });
        return Err(agent_payments_error(StatusCode::BAD_GATEWAY, code, message));
    }

    let Some(result) = json_result_object(&body) else {
        return Err(agent_payments_error(
            StatusCode::BAD_GATEWAY,
            "spark_executor_error",
            "Spark executor response did not include an object result.",
        ));
    };

    let Some(preimage) = json_first_string(
        result,
        &[
            "preimage",
            "paymentPreimage",
            "payment.preimage",
            "payment.paymentPreimage",
        ],
    ) else {
        return Err(agent_payments_error(
            StatusCode::BAD_GATEWAY,
            "spark_executor_error",
            "Spark wallet payer did not return a payment preimage.",
        ));
    };
    let preimage = normalize_preimage_hex(&preimage)?;
    let payment_id = json_first_string(
        result,
        &[
            "paymentId",
            "paymentHash",
            "payment.paymentId",
            "payment.paymentHash",
        ],
    );
    let status = json_first_string(result, &["status", "payment.status"])
        .unwrap_or_else(|| "completed".to_string());

    Ok(AgentInvoicePaymentResult {
        payment_id,
        preimage,
        status,
        raw: result.clone(),
    })
}

async fn agent_payments_pay_invoice_lnd(
    invoice: &str,
    _max_amount_msats: u64,
    timeout_ms: u64,
) -> Result<AgentInvoicePaymentResult, AgentInvoicePaymentError> {
    let Some(base_url) = env_non_empty("LND_REST_BASE_URL") else {
        return Err(agent_payments_error(
            StatusCode::BAD_GATEWAY,
            "lnd_rest_not_configured",
            "LND REST payer not configured. Set LND_REST_BASE_URL and LND_REST_MACAROON_HEX.",
        ));
    };
    let Some(macaroon_hex) = env_non_empty("LND_REST_MACAROON_HEX") else {
        return Err(agent_payments_error(
            StatusCode::BAD_GATEWAY,
            "lnd_rest_not_configured",
            "LND REST payer not configured. Set LND_REST_BASE_URL and LND_REST_MACAROON_HEX.",
        ));
    };

    let timeout_seconds = timeout_ms.div_ceil(1000).max(1);
    let mut client_builder =
        reqwest::Client::builder().timeout(std::time::Duration::from_secs(timeout_seconds));

    if let Some(cert_base64) = env_non_empty("LND_REST_TLS_CERT_BASE64") {
        let decoded = STANDARD.decode(cert_base64).map_err(|error| {
            agent_payments_error(
                StatusCode::BAD_GATEWAY,
                "lnd_rest_invalid_tls_cert",
                format!("Invalid base64 in LND_REST_TLS_CERT_BASE64: {error}"),
            )
        })?;
        let certificate = reqwest::Certificate::from_pem(&decoded)
            .or_else(|_| reqwest::Certificate::from_der(&decoded))
            .map_err(|error| {
                agent_payments_error(
                    StatusCode::BAD_GATEWAY,
                    "lnd_rest_invalid_tls_cert",
                    format!("Invalid certificate in LND_REST_TLS_CERT_BASE64: {error}"),
                )
            })?;
        client_builder = client_builder.add_root_certificate(certificate);
    } else if !env_bool("LND_REST_TLS_VERIFY", true) {
        client_builder = client_builder.danger_accept_invalid_certs(true);
    }

    let client = client_builder.build().map_err(|error| {
        agent_payments_error(
            StatusCode::BAD_GATEWAY,
            "lnd_rest_error",
            format!("Failed to build LND REST client: {error}"),
        )
    })?;

    let response = client
        .post(format!(
            "{}/v1/channels/transactions",
            base_url.trim_end_matches('/')
        ))
        .header("Grpc-Metadata-macaroon", macaroon_hex)
        .json(&serde_json::json!({
            "payment_request": invoice,
        }))
        .send()
        .await
        .map_err(|error| {
            agent_payments_error(
                StatusCode::BAD_GATEWAY,
                "lnd_rest_error",
                format!("LND REST pay request failed: {error}"),
            )
        })?;

    let status = response.status();
    let body_text = response.text().await.map_err(|error| {
        agent_payments_error(
            StatusCode::BAD_GATEWAY,
            "lnd_rest_error",
            format!("LND REST pay response read failed: {error}"),
        )
    })?;
    if !status.is_success() {
        return Err(agent_payments_error(
            StatusCode::BAD_GATEWAY,
            "lnd_rest_error",
            format!(
                "LND REST pay failed: HTTP {} {}",
                status.as_u16(),
                body_text
            ),
        ));
    }

    let body = serde_json::from_str::<serde_json::Value>(&body_text).map_err(|error| {
        agent_payments_error(
            StatusCode::BAD_GATEWAY,
            "lnd_rest_error",
            format!("LND REST pay failed: invalid JSON response ({error})"),
        )
    })?;
    let Some(object) = body.as_object() else {
        return Err(agent_payments_error(
            StatusCode::BAD_GATEWAY,
            "lnd_rest_error",
            "LND REST pay failed: invalid JSON response",
        ));
    };

    if let Some(payment_error) = object
        .get("payment_error")
        .and_then(serde_json::Value::as_str)
        .map(str::trim)
        .filter(|value| !value.is_empty())
    {
        return Err(agent_payments_error(
            StatusCode::BAD_GATEWAY,
            "lnd_rest_error",
            format!("LND REST pay failed: {payment_error}"),
        ));
    }

    let Some(preimage_raw) = object
        .get("payment_preimage")
        .and_then(serde_json::Value::as_str)
        .map(str::trim)
        .filter(|value| !value.is_empty())
    else {
        return Err(agent_payments_error(
            StatusCode::BAD_GATEWAY,
            "lnd_rest_error",
            "LND REST pay failed: missing payment_preimage",
        ));
    };
    let preimage = normalize_preimage_hex(preimage_raw).map_err(|_| {
        agent_payments_error(
            StatusCode::BAD_GATEWAY,
            "lnd_rest_error",
            "LND REST pay failed: payment_preimage is neither hex nor base64",
        )
    })?;

    Ok(AgentInvoicePaymentResult {
        payment_id: object
            .get("payment_hash")
            .and_then(serde_json::Value::as_str)
            .map(str::trim)
            .filter(|value| !value.is_empty())
            .map(str::to_string),
        preimage,
        status: "completed".to_string(),
        raw: body,
    })
}

fn agent_payments_error(
    status: StatusCode,
    code: &str,
    message: impl Into<String>,
) -> AgentInvoicePaymentError {
    AgentInvoicePaymentError {
        status,
        code: code.to_string(),
        message: message.into(),
    }
}

fn json_result_object(payload: &serde_json::Value) -> Option<&serde_json::Value> {
    let result = payload
        .get("result")
        .or_else(|| payload.get("status"))
        .or_else(|| payload.get("data"))
        .unwrap_or(payload);
    result.as_object().map(|_| result)
}

fn json_first_string(payload: &serde_json::Value, paths: &[&str]) -> Option<String> {
    for path in paths {
        let mut current = payload;
        let mut found = true;
        for segment in path.split('.') {
            let Some(next) = current.get(segment) else {
                found = false;
                break;
            };
            current = next;
        }
        if !found {
            continue;
        }
        if let Some(value) = current
            .as_str()
            .map(str::trim)
            .filter(|value| !value.is_empty())
        {
            return Some(value.to_string());
        }
    }
    None
}

fn normalize_preimage_hex(preimage: &str) -> Result<String, AgentInvoicePaymentError> {
    let value = preimage.trim();
    if value.len() == 64 && value.chars().all(|ch| ch.is_ascii_hexdigit()) {
        return Ok(value.to_ascii_lowercase());
    }
    let decoded = STANDARD.decode(value).map_err(|_| {
        agent_payments_error(
            StatusCode::BAD_GATEWAY,
            "invoice_payer_error",
            "payment preimage is neither hex nor base64",
        )
    })?;
    Ok(bytes_to_hex(&decoded))
}

fn bytes_to_hex(bytes: &[u8]) -> String {
    use std::fmt::Write as _;

    let mut output = String::with_capacity(bytes.len().saturating_mul(2));
    for byte in bytes {
        let _ = write!(&mut output, "{byte:02x}");
    }
    output
}

fn env_non_empty_any(keys: &[&str]) -> Option<String> {
    keys.iter().find_map(|key| env_non_empty(key))
}

fn env_non_empty(key: &str) -> Option<String> {
    std::env::var(key)
        .ok()
        .map(|value| value.trim().to_string())
        .filter(|value| !value.is_empty())
}

fn env_u64(key: &str, default: u64) -> u64 {
    std::env::var(key)
        .ok()
        .map(|value| value.trim().to_string())
        .filter(|value| !value.is_empty())
        .and_then(|value| value.parse::<u64>().ok())
        .unwrap_or(default)
}

fn env_bool(key: &str, default: bool) -> bool {
    std::env::var(key)
        .ok()
        .map(|value| value.trim().to_ascii_lowercase())
        .map(|value| match value.as_str() {
            "1" | "true" | "yes" => true,
            "0" | "false" | "no" => false,
            _ => default,
        })
        .unwrap_or(default)
}

fn l402_allowlist_hosts_from_env() -> Vec<String> {
    env_non_empty("L402_ALLOWLIST_HOSTS")
        .map(|value| {
            value
                .split(',')
                .map(str::trim)
                .filter(|value| !value.is_empty())
                .map(|value| value.to_ascii_lowercase())
                .collect::<Vec<_>>()
        })
        .unwrap_or_else(|| vec!["sats4ai.com".to_string(), "l402.openagents.com".to_string()])
}

async fn agent_payments_send_spark(
    State(state): State<AppState>,
    headers: HeaderMap,
    Json(payload): Json<AgentPaymentsSendSparkRequestPayload>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let spark_address = non_empty(payload.spark_address).ok_or_else(|| {
        validation_error(
            "sparkAddress",
            "The sparkAddress field is required and must be a string.",
        )
    })?;
    if spark_address.chars().count() < 3 || spark_address.chars().count() > 255 {
        return Err(validation_error(
            "sparkAddress",
            "The sparkAddress field must be between 3 and 255 characters.",
        ));
    }
    if payload.amount_sats < 1 {
        return Err(validation_error(
            "amountSats",
            "The amountSats field must be at least 1.",
        ));
    }

    let timeout_ms = payload.timeout_ms.unwrap_or(12_000);
    if !(1_000..=120_000).contains(&timeout_ms) {
        return Err(validation_error(
            "timeoutMs",
            "The timeoutMs field must be between 1000 and 120000.",
        ));
    }

    let _wallet = ensure_agent_wallet_for_user(&state, &bundle.user.id).await?;
    let payment_id = format!("spark_{}", Uuid::new_v4().simple());
    let status = "completed";
    let raw = serde_json::json!({
        "sparkAddress": spark_address,
        "amountSats": payload.amount_sats,
        "timeoutMs": timeout_ms,
        "status": status,
        "paymentId": payment_id,
    });

    state.observability.audit(
        AuditEvent::new("agent_payments.spark_sent", request_id.clone())
            .with_user_id(bundle.user.id)
            .with_session_id(bundle.session.session_id)
            .with_org_id(bundle.session.active_org_id)
            .with_device_id(bundle.session.device_id)
            .with_attribute("spark_address", spark_address.clone())
            .with_attribute("amount_sats", payload.amount_sats.to_string())
            .with_attribute("payment_id", payment_id.clone()),
    );
    state
        .observability
        .increment_counter("agent_payments.spark_sent", &request_id);

    Ok(ok_data(serde_json::json!({
        "transfer": {
            "sparkAddress": spark_address,
            "amountSats": payload.amount_sats,
            "status": status,
            "paymentId": payment_id,
            "raw": raw,
        }
    })))
}

async fn upsert_agent_wallet_for_user(
    state: &AppState,
    user_id: &str,
    mnemonic_override: Option<String>,
) -> Result<UserSparkWalletRecord, (StatusCode, Json<ApiErrorResponse>)> {
    let existing = state
        ._domain_store
        .find_user_spark_wallet(user_id)
        .await
        .map_err(map_domain_store_error)?;
    let now = Utc::now();

    let wallet_id = existing
        .as_ref()
        .map(|wallet| wallet.wallet_id.clone())
        .unwrap_or_else(|| format!("wallet_{}", Uuid::new_v4().simple()));
    let mnemonic = mnemonic_override
        .or_else(|| existing.as_ref().map(|wallet| wallet.mnemonic.clone()))
        .unwrap_or_else(|| format!("openagents seed phrase {}", Uuid::new_v4().simple()));
    let spark_address = existing
        .as_ref()
        .and_then(|wallet| wallet.spark_address.clone())
        .or_else(|| Some(format!("{user_id}@spark.openagents.local")));
    let lightning_address = existing
        .as_ref()
        .and_then(|wallet| wallet.lightning_address.clone())
        .or_else(|| Some(format!("{user_id}@openagents.local")));
    let identity_pubkey = existing
        .as_ref()
        .and_then(|wallet| wallet.identity_pubkey.clone())
        .or_else(|| Some(format!("pubkey_{}", Uuid::new_v4().simple())));

    state
        ._domain_store
        .upsert_user_spark_wallet(UpsertUserSparkWalletInput {
            user_id: user_id.to_string(),
            wallet_id,
            mnemonic,
            spark_address,
            lightning_address,
            identity_pubkey,
            last_balance_sats: existing
                .as_ref()
                .and_then(|wallet| wallet.last_balance_sats),
            status: existing.as_ref().map(|wallet| wallet.status.clone()),
            provider: existing.as_ref().map(|wallet| wallet.provider.clone()),
            last_error: existing
                .as_ref()
                .and_then(|wallet| wallet.last_error.clone()),
            meta: existing.as_ref().and_then(|wallet| wallet.meta.clone()),
            last_synced_at: Some(now),
        })
        .await
        .map_err(map_domain_store_error)
}

async fn ensure_agent_wallet_for_user(
    state: &AppState,
    user_id: &str,
) -> Result<UserSparkWalletRecord, (StatusCode, Json<ApiErrorResponse>)> {
    upsert_agent_wallet_for_user(state, user_id, None).await
}

async fn sync_agent_wallet(
    state: &AppState,
    wallet: UserSparkWalletRecord,
) -> Result<UserSparkWalletRecord, (StatusCode, Json<ApiErrorResponse>)> {
    state
        ._domain_store
        .upsert_user_spark_wallet(UpsertUserSparkWalletInput {
            user_id: wallet.user_id,
            wallet_id: wallet.wallet_id,
            mnemonic: wallet.mnemonic,
            spark_address: wallet.spark_address,
            lightning_address: wallet.lightning_address,
            identity_pubkey: wallet.identity_pubkey,
            last_balance_sats: wallet.last_balance_sats,
            status: Some(wallet.status),
            provider: Some(wallet.provider),
            last_error: wallet.last_error,
            meta: wallet.meta,
            last_synced_at: Some(Utc::now()),
        })
        .await
        .map_err(map_domain_store_error)
}

fn agent_payments_wallet_payload(wallet: &UserSparkWalletRecord) -> serde_json::Value {
    serde_json::json!({
        "id": wallet.wallet_id,
        "walletId": wallet.wallet_id,
        "sparkAddress": wallet.spark_address,
        "lightningAddress": wallet.lightning_address,
        "identityPubkey": wallet.identity_pubkey,
        "balanceSats": wallet.last_balance_sats,
        "status": wallet.status,
        "provider": wallet.provider,
        "lastError": wallet.last_error,
        "lastSyncedAt": wallet.last_synced_at.map(timestamp),
        "createdAt": timestamp(wallet.created_at),
        "updatedAt": timestamp(wallet.updated_at),
    })
}

#[derive(Debug, Clone)]
struct L402AutopilotFilterValue {
    id: String,
    handle: String,
}

#[derive(Debug, Clone)]
struct L402ReceiptView {
    event_id: u64,
    thread_id: String,
    thread_title: String,
    run_id: String,
    run_status: Option<String>,
    run_started_at: Option<String>,
    run_completed_at: Option<String>,
    created_at: String,
    status: String,
    host: String,
    scope: Option<String>,
    paid: bool,
    cache_hit: bool,
    cache_status: Option<String>,
    amount_msats: Option<i64>,
    quoted_amount_msats: Option<i64>,
    max_spend_msats: Option<i64>,
    proof_reference: Option<String>,
    deny_code: Option<String>,
    task_id: Option<String>,
    approval_required: bool,
    response_status_code: Option<i64>,
    response_body_sha256: Option<String>,
    tool_call_id: Option<String>,
    raw_payload: serde_json::Value,
}

struct LightningOpsInvoiceLifecycleInput {
    invoice_id: String,
    paywall_id: String,
    owner_id: String,
    amount_msats: i64,
    status: String,
    payment_hash: Option<String>,
    payment_request: Option<String>,
    payment_proof_ref: Option<String>,
    request_id: Option<String>,
    settled_at_ms: Option<i64>,
}

async fn resolve_l402_autopilot_filter(
    state: &AppState,
    owner_user_id: &str,
    candidate: Option<String>,
) -> Result<Option<L402AutopilotFilterValue>, (StatusCode, Json<ApiErrorResponse>)> {
    let Some(reference) = candidate.and_then(non_empty) else {
        return Ok(None);
    };

    match state
        ._domain_store
        .resolve_autopilot_filter_for_owner(owner_user_id, &reference)
        .await
    {
        Ok(autopilot) => Ok(Some(L402AutopilotFilterValue {
            id: autopilot.id,
            handle: autopilot.handle,
        })),
        Err(DomainStoreError::NotFound) => Err(not_found_error("autopilot_not_found")),
        Err(DomainStoreError::Forbidden) => Err(forbidden_error("autopilot_forbidden")),
        Err(error) => Err(map_domain_store_error(error)),
    }
}

type LightningOpsControlPlaneResponse =
    Result<(StatusCode, Json<serde_json::Value>), (StatusCode, Json<serde_json::Value>)>;

async fn lightning_ops_control_plane_query(
    State(state): State<AppState>,
    Json(payload): Json<serde_json::Value>,
) -> LightningOpsControlPlaneResponse {
    let (function_name, mut args) = lightning_ops_payload(payload)?;
    lightning_ops_assert_secret(&mut args)?;

    match function_name.as_str() {
        "lightning/ops:listPaywallControlPlaneState" => {
            let statuses = lightning_ops_statuses(&args);
            let mut rows = state
                ._domain_store
                .list_all_l402_paywalls(true)
                .await
                .map_err(lightning_ops_map_domain_store_error)?;
            rows.sort_by(|left, right| left.created_at.cmp(&right.created_at));

            let paywalls = rows
                .iter()
                .map(lightning_ops_paywall_payload)
                .filter(|payload| {
                    if statuses.is_empty() {
                        return true;
                    }
                    payload
                        .get("status")
                        .and_then(serde_json::Value::as_str)
                        .map(|status| statuses.iter().any(|value| value == status))
                        .unwrap_or(false)
                })
                .collect::<Vec<_>>();

            Ok((
                StatusCode::OK,
                Json(serde_json::json!({
                    "ok": true,
                    "paywalls": paywalls,
                })),
            ))
        }
        "lightning/security:getControlPlaneSecurityState" => {
            let store = state.lightning_ops_control_plane.store.lock().await;

            let global = store
                .global_security
                .as_ref()
                .map(lightning_ops_global_security_payload)
                .unwrap_or_else(|| {
                    serde_json::json!({
                        "stateId": "global",
                        "globalPause": false,
                        "updatedAtMs": 0,
                    })
                });

            let mut owner_controls = store
                .owner_controls
                .values()
                .cloned()
                .collect::<Vec<LightningOpsOwnerControlRecord>>();
            owner_controls.sort_by(|left, right| left.owner_id.cmp(&right.owner_id));

            let mut credential_roles = store
                .credential_roles
                .values()
                .cloned()
                .collect::<Vec<LightningOpsCredentialRoleRecord>>();
            credential_roles.sort_by(|left, right| left.role.cmp(&right.role));

            Ok((
                StatusCode::OK,
                Json(serde_json::json!({
                    "ok": true,
                    "global": global,
                    "ownerControls": owner_controls
                        .iter()
                        .map(lightning_ops_owner_control_payload)
                        .collect::<Vec<_>>(),
                    "credentialRoles": credential_roles
                        .iter()
                        .map(lightning_ops_credential_role_payload)
                        .collect::<Vec<_>>(),
                })),
            ))
        }
        _ => Err(lightning_ops_error(
            StatusCode::NOT_FOUND,
            "unsupported_function",
            format!("unsupported function: {function_name}"),
        )),
    }
}

async fn lightning_ops_control_plane_mutation(
    State(state): State<AppState>,
    Json(payload): Json<serde_json::Value>,
) -> LightningOpsControlPlaneResponse {
    let (function_name, mut args) = lightning_ops_payload(payload)?;
    lightning_ops_assert_secret(&mut args)?;

    match function_name.as_str() {
        "lightning/ops:recordGatewayCompileIntent" => {
            let deployment_id = lightning_ops_optional_string(&args, "deploymentId")
                .unwrap_or_else(|| Uuid::new_v4().to_string());
            let config_hash = lightning_ops_required_string(&args, "configHash")?;
            let status = lightning_ops_required_string(&args, "status")?;
            let now = Utc::now();

            let mut store = state.lightning_ops_control_plane.store.lock().await;
            let entry = store
                .deployments
                .entry(deployment_id.clone())
                .or_insert_with(|| LightningOpsDeploymentRecord {
                    deployment_id: deployment_id.clone(),
                    paywall_id: None,
                    owner_id: None,
                    config_hash: config_hash.clone(),
                    image_digest: None,
                    status: status.clone(),
                    diagnostics: None,
                    metadata: None,
                    request_id: None,
                    applied_at_ms: None,
                    rolled_back_from: None,
                    created_at: now,
                    updated_at: now,
                });

            entry.paywall_id = lightning_ops_optional_string(&args, "paywallId");
            entry.owner_id = lightning_ops_optional_string(&args, "ownerId");
            entry.config_hash = config_hash;
            entry.image_digest = lightning_ops_optional_string(&args, "imageDigest");
            entry.status = status;
            entry.diagnostics = lightning_ops_optional_json(&args, "diagnostics");
            entry.metadata = lightning_ops_optional_json(&args, "metadata");
            entry.request_id = lightning_ops_optional_string(&args, "requestId");
            entry.applied_at_ms = lightning_ops_optional_i64(&args, "appliedAtMs");
            entry.rolled_back_from = lightning_ops_optional_string(&args, "rolledBackFrom");
            entry.updated_at = now;

            Ok((
                StatusCode::OK,
                Json(serde_json::json!({
                    "ok": true,
                    "deployment": lightning_ops_deployment_payload(entry),
                })),
            ))
        }
        "lightning/ops:recordGatewayDeploymentEvent" => {
            let paywall_id = lightning_ops_required_string(&args, "paywallId")?;
            let owner_id = lightning_ops_required_string(&args, "ownerId")?;
            let event_type = lightning_ops_required_string(&args, "eventType")?;
            let level = lightning_ops_required_string(&args, "level")?;
            let now = Utc::now();
            let event = LightningOpsGatewayEventRecord {
                event_id: format!("evt_{}", Uuid::new_v4().simple()),
                paywall_id,
                owner_id,
                event_type,
                level,
                request_id: lightning_ops_optional_string(&args, "requestId"),
                metadata: lightning_ops_optional_json(&args, "metadata"),
                created_at: now,
            };

            state
                .lightning_ops_control_plane
                .store
                .lock()
                .await
                .gateway_events
                .push(event.clone());

            Ok((
                StatusCode::OK,
                Json(serde_json::json!({
                    "ok": true,
                    "event": lightning_ops_gateway_event_payload(&event),
                })),
            ))
        }
        "lightning/settlements:ingestInvoiceLifecycle" => {
            let input = lightning_ops_invoice_lifecycle_input(&args, None)?;
            let mut store = state.lightning_ops_control_plane.store.lock().await;
            let (changed, invoice) = lightning_ops_apply_invoice_lifecycle(&mut store, input)?;

            Ok((
                StatusCode::OK,
                Json(serde_json::json!({
                    "ok": true,
                    "changed": changed,
                    "invoice": lightning_ops_invoice_payload(&invoice),
                })),
            ))
        }
        "lightning/settlements:ingestSettlement" => {
            let settlement_id = lightning_ops_required_string(&args, "settlementId")?;
            let invoice_id = lightning_ops_optional_string(&args, "invoiceId");
            let now = Utc::now();

            let mut store = state.lightning_ops_control_plane.store.lock().await;
            let invoice_payload = if invoice_id.is_some() {
                let input = lightning_ops_invoice_lifecycle_input(&args, Some("settled"))?;
                let (_, invoice) = lightning_ops_apply_invoice_lifecycle(&mut store, input)?;
                Some(invoice)
            } else {
                None
            };

            if let Some(existing) = store.settlements.get(&settlement_id).cloned() {
                let mut payload = serde_json::json!({
                    "ok": true,
                    "existed": true,
                    "settlement": lightning_ops_settlement_payload(&existing),
                });
                if let Some(invoice) = invoice_payload.as_ref() {
                    payload["invoice"] = lightning_ops_invoice_payload(invoice);
                }
                return Ok((StatusCode::OK, Json(payload)));
            }

            let payment_proof_type = lightning_ops_required_string(&args, "paymentProofType")?;
            if payment_proof_type != "lightning_preimage" {
                return Err(lightning_ops_invalid_arguments(
                    "invalid_payment_proof_type",
                ));
            }
            let preimage = lightning_ops_required_string(&args, "paymentProofValue")?
                .trim()
                .to_lowercase();
            if preimage.is_empty()
                || !preimage
                    .chars()
                    .all(|value| value.is_ascii_hexdigit() && !value.is_ascii_uppercase())
            {
                return Err(lightning_ops_invalid_arguments("invalid_preimage"));
            }

            let settlement = LightningOpsSettlementRecord {
                settlement_id,
                paywall_id: lightning_ops_required_string(&args, "paywallId")?,
                owner_id: lightning_ops_required_string(&args, "ownerId")?,
                invoice_id,
                amount_msats: lightning_ops_required_i64(&args, "amountMsats")?,
                payment_proof_ref: format!(
                    "lightning_preimage:{}",
                    preimage.chars().take(24).collect::<String>()
                ),
                request_id: lightning_ops_optional_string(&args, "requestId"),
                metadata: lightning_ops_optional_json(&args, "metadata"),
                created_at: now,
            };
            store
                .settlements
                .insert(settlement.settlement_id.clone(), settlement.clone());

            let mut payload = serde_json::json!({
                "ok": true,
                "existed": false,
                "settlement": lightning_ops_settlement_payload(&settlement),
            });
            if let Some(invoice) = invoice_payload.as_ref() {
                payload["invoice"] = lightning_ops_invoice_payload(invoice);
            }
            Ok((StatusCode::OK, Json(payload)))
        }
        "lightning/security:setGlobalPause" => {
            let active = lightning_ops_bool(&args, "active");
            let now = Utc::now();
            let now_ms = now.timestamp_millis();
            let global = LightningOpsGlobalSecurityRecord {
                global_pause: active,
                deny_reason_code: if active {
                    Some("global_pause_active".to_string())
                } else {
                    None
                },
                deny_reason: if active {
                    Some(
                        lightning_ops_optional_string(&args, "reason")
                            .unwrap_or_else(|| "Global paywall pause is active".to_string()),
                    )
                } else {
                    None
                },
                updated_by: lightning_ops_optional_string(&args, "updatedBy"),
                updated_at_ms: now_ms,
            };

            state
                .lightning_ops_control_plane
                .store
                .lock()
                .await
                .global_security = Some(global.clone());

            Ok((
                StatusCode::OK,
                Json(serde_json::json!({
                    "ok": true,
                    "global": lightning_ops_global_security_payload(&global),
                })),
            ))
        }
        "lightning/security:setOwnerKillSwitch" => {
            let owner_id = lightning_ops_required_string(&args, "ownerId")?;
            let active = lightning_ops_bool(&args, "active");
            let now = Utc::now();
            let now_ms = now.timestamp_millis();
            let owner_control = LightningOpsOwnerControlRecord {
                owner_id: owner_id.clone(),
                kill_switch: active,
                deny_reason_code: if active {
                    Some("owner_kill_switch_active".to_string())
                } else {
                    None
                },
                deny_reason: if active {
                    Some(
                        lightning_ops_optional_string(&args, "reason")
                            .unwrap_or_else(|| "Owner kill switch is active".to_string()),
                    )
                } else {
                    None
                },
                updated_by: lightning_ops_optional_string(&args, "updatedBy"),
                updated_at_ms: now_ms,
            };

            state
                .lightning_ops_control_plane
                .store
                .lock()
                .await
                .owner_controls
                .insert(owner_id, owner_control.clone());

            Ok((
                StatusCode::OK,
                Json(serde_json::json!({
                    "ok": true,
                    "ownerControl": lightning_ops_owner_control_payload(&owner_control),
                })),
            ))
        }
        "lightning/security:rotateCredentialRole" => {
            let role = lightning_ops_required_string(&args, "role")?;
            let now = Utc::now();
            let now_ms = now.timestamp_millis();
            let mut store = state.lightning_ops_control_plane.store.lock().await;
            let next_version = store
                .credential_roles
                .get(&role)
                .map(|row| row.version.saturating_add(1).max(1))
                .unwrap_or(1);

            let record = LightningOpsCredentialRoleRecord {
                role: role.clone(),
                status: "rotating".to_string(),
                version: next_version,
                fingerprint: lightning_ops_optional_string(&args, "fingerprint"),
                note: lightning_ops_optional_string(&args, "note"),
                updated_at_ms: now_ms,
                last_rotated_at_ms: Some(now_ms),
                revoked_at_ms: None,
            };
            store.credential_roles.insert(role, record.clone());

            Ok((
                StatusCode::OK,
                Json(serde_json::json!({
                    "ok": true,
                    "role": lightning_ops_credential_role_payload(&record),
                })),
            ))
        }
        "lightning/security:activateCredentialRole" => {
            let role = lightning_ops_required_string(&args, "role")?;
            let now = Utc::now();
            let now_ms = now.timestamp_millis();
            let mut store = state.lightning_ops_control_plane.store.lock().await;
            let next_version = if let Some(existing) = store.credential_roles.get(&role) {
                if existing.status == "rotating" {
                    existing.version.max(1)
                } else {
                    existing.version.saturating_add(1).max(1)
                }
            } else {
                1
            };

            let record = LightningOpsCredentialRoleRecord {
                role: role.clone(),
                status: "active".to_string(),
                version: next_version,
                fingerprint: lightning_ops_optional_string(&args, "fingerprint"),
                note: lightning_ops_optional_string(&args, "note"),
                updated_at_ms: now_ms,
                last_rotated_at_ms: Some(now_ms),
                revoked_at_ms: None,
            };
            store.credential_roles.insert(role, record.clone());

            Ok((
                StatusCode::OK,
                Json(serde_json::json!({
                    "ok": true,
                    "role": lightning_ops_credential_role_payload(&record),
                })),
            ))
        }
        "lightning/security:revokeCredentialRole" => {
            let role = lightning_ops_required_string(&args, "role")?;
            let now = Utc::now();
            let now_ms = now.timestamp_millis();
            let mut store = state.lightning_ops_control_plane.store.lock().await;
            let version = store
                .credential_roles
                .get(&role)
                .map(|record| record.version.max(1))
                .unwrap_or(1);

            let record = LightningOpsCredentialRoleRecord {
                role: role.clone(),
                status: "revoked".to_string(),
                version,
                fingerprint: None,
                note: lightning_ops_optional_string(&args, "note"),
                updated_at_ms: now_ms,
                last_rotated_at_ms: None,
                revoked_at_ms: Some(now_ms),
            };
            store.credential_roles.insert(role, record.clone());

            Ok((
                StatusCode::OK,
                Json(serde_json::json!({
                    "ok": true,
                    "role": lightning_ops_credential_role_payload(&record),
                })),
            ))
        }
        _ => Err(lightning_ops_error(
            StatusCode::NOT_FOUND,
            "unsupported_function",
            format!("unsupported function: {function_name}"),
        )),
    }
}

fn lightning_ops_payload(
    payload: serde_json::Value,
) -> Result<
    (String, serde_json::Map<String, serde_json::Value>),
    (StatusCode, Json<serde_json::Value>),
> {
    let object = payload
        .as_object()
        .ok_or_else(|| lightning_ops_invalid_arguments("invalid_payload"))?;
    let function_name = object
        .get("functionName")
        .and_then(serde_json::Value::as_str)
        .map(str::trim)
        .filter(|value| !value.is_empty())
        .ok_or_else(|| lightning_ops_invalid_arguments("missing_functionName"))?
        .to_string();
    if function_name.chars().count() > 180 {
        return Err(lightning_ops_invalid_arguments("invalid_functionName"));
    }

    let args = object
        .get("args")
        .and_then(serde_json::Value::as_object)
        .cloned()
        .ok_or_else(|| lightning_ops_invalid_arguments("missing_args"))?;

    Ok((function_name, args))
}

fn lightning_ops_assert_secret(
    args: &mut serde_json::Map<String, serde_json::Value>,
) -> Result<(), (StatusCode, Json<serde_json::Value>)> {
    let expected = lightning_ops_expected_secret();
    let Some(expected) = expected else {
        return Err(lightning_ops_error(
            StatusCode::INTERNAL_SERVER_ERROR,
            "ops_secret_unconfigured",
            "lightning ops secret is not configured",
        ));
    };

    let provided = args
        .get("secret")
        .and_then(serde_json::Value::as_str)
        .map(str::trim)
        .unwrap_or_default()
        .to_string();
    if provided.is_empty() || provided != expected {
        return Err(lightning_ops_error(
            StatusCode::UNAUTHORIZED,
            "invalid_ops_secret",
            "invalid lightning ops secret",
        ));
    }
    args.remove("secret");
    Ok(())
}

fn lightning_ops_expected_secret() -> Option<String> {
    std::env::var("OA_LIGHTNING_OPS_SECRET")
        .ok()
        .map(|value| value.trim().to_string())
        .filter(|value| !value.is_empty())
        .or_else(|| {
            if cfg!(test) {
                Some("ops-secret-test".to_string())
            } else {
                None
            }
        })
}

fn lightning_ops_statuses(args: &serde_json::Map<String, serde_json::Value>) -> Vec<String> {
    let Some(values) = args.get("statuses").and_then(serde_json::Value::as_array) else {
        return vec!["active".to_string(), "paused".to_string()];
    };
    values
        .iter()
        .filter_map(serde_json::Value::as_str)
        .map(str::trim)
        .filter(|value| !value.is_empty())
        .map(ToString::to_string)
        .collect()
}

fn lightning_ops_paywall_payload(paywall: &L402PaywallRecord) -> serde_json::Value {
    let status = if paywall.deleted_at.is_some() {
        "archived"
    } else if paywall.enabled {
        "active"
    } else {
        "paused"
    };
    let paywall_id = paywall.id.clone();
    let owner_id = format!("owner_{}", paywall.owner_user_id);
    let created_at_ms = paywall.created_at.timestamp_millis();
    let updated_at_ms = paywall.updated_at.timestamp_millis();
    let protocol = if paywall.upstream.to_ascii_lowercase().starts_with("http://") {
        "http"
    } else {
        "https"
    };
    let timeout_ms =
        lightning_ops_meta_i64(paywall.meta.as_ref(), "timeoutMs").unwrap_or_else(|| {
            std::env::var("OA_LIGHTNING_OPS_CONTROL_PLANE_TIMEOUT_MS")
                .ok()
                .and_then(|value| value.trim().parse::<i64>().ok())
                .filter(|value| *value > 0)
                .unwrap_or(6000)
        });
    let priority = lightning_ops_meta_i64(paywall.meta.as_ref(), "priority").unwrap_or_else(|| {
        std::env::var("OA_LIGHTNING_OPS_CONTROL_PLANE_PRIORITY")
            .ok()
            .and_then(|value| value.trim().parse::<i64>().ok())
            .filter(|value| *value >= 0)
            .unwrap_or(10)
    });

    let mut policy = serde_json::Map::new();
    policy.insert("paywallId".to_string(), serde_json::json!(paywall_id));
    policy.insert("ownerId".to_string(), serde_json::json!(owner_id));
    policy.insert("pricingMode".to_string(), serde_json::json!("fixed"));
    policy.insert(
        "fixedAmountMsats".to_string(),
        serde_json::json!(paywall.price_msats),
    );
    if let Some(value) = lightning_ops_meta_i64(paywall.meta.as_ref(), "maxPerRequestMsats") {
        policy.insert("maxPerRequestMsats".to_string(), serde_json::json!(value));
    }
    if let Some(value) = lightning_ops_meta_string_list(paywall.meta.as_ref(), "allowedHosts") {
        policy.insert("allowedHosts".to_string(), serde_json::json!(value));
    }
    if let Some(value) = lightning_ops_meta_string_list(paywall.meta.as_ref(), "blockedHosts") {
        policy.insert("blockedHosts".to_string(), serde_json::json!(value));
    }
    if let Some(value) = lightning_ops_meta_i64(paywall.meta.as_ref(), "quotaPerMinute") {
        policy.insert("quotaPerMinute".to_string(), serde_json::json!(value));
    }
    if let Some(value) = lightning_ops_meta_i64(paywall.meta.as_ref(), "quotaPerDay") {
        policy.insert("quotaPerDay".to_string(), serde_json::json!(value));
    }
    policy.insert("killSwitch".to_string(), serde_json::json!(false));
    policy.insert("createdAtMs".to_string(), serde_json::json!(created_at_ms));
    policy.insert("updatedAtMs".to_string(), serde_json::json!(updated_at_ms));

    serde_json::json!({
        "paywallId": paywall.id,
        "ownerId": format!("owner_{}", paywall.owner_user_id),
        "name": paywall.name,
        "status": status,
        "createdAtMs": created_at_ms,
        "updatedAtMs": updated_at_ms,
        "policy": policy,
        "routes": [
            {
                "routeId": format!("route_{}", paywall.id),
                "paywallId": paywall.id,
                "ownerId": format!("owner_{}", paywall.owner_user_id),
                "hostPattern": paywall.host_regexp,
                "pathPattern": paywall.path_regexp,
                "upstreamUrl": paywall.upstream,
                "protocol": protocol,
                "timeoutMs": timeout_ms,
                "priority": priority,
                "createdAtMs": created_at_ms,
                "updatedAtMs": updated_at_ms,
            }
        ]
    })
}

fn lightning_ops_deployment_payload(record: &LightningOpsDeploymentRecord) -> serde_json::Value {
    let mut payload = serde_json::json!({
        "deploymentId": record.deployment_id,
        "configHash": record.config_hash,
        "status": record.status,
        "createdAtMs": record.created_at.timestamp_millis(),
        "updatedAtMs": record.updated_at.timestamp_millis(),
    });
    if let Some(value) = record.paywall_id.as_ref() {
        payload["paywallId"] = serde_json::json!(value);
    }
    if let Some(value) = record.owner_id.as_ref() {
        payload["ownerId"] = serde_json::json!(value);
    }
    if let Some(value) = record.image_digest.as_ref() {
        payload["imageDigest"] = serde_json::json!(value);
    }
    if let Some(value) = record.diagnostics.as_ref() {
        payload["diagnostics"] = value.clone();
    }
    if let Some(value) = record.applied_at_ms {
        payload["appliedAtMs"] = serde_json::json!(value);
    }
    if let Some(value) = record.rolled_back_from.as_ref() {
        payload["rolledBackFrom"] = serde_json::json!(value);
    }
    payload
}

fn lightning_ops_gateway_event_payload(
    record: &LightningOpsGatewayEventRecord,
) -> serde_json::Value {
    let mut payload = serde_json::json!({
        "eventId": record.event_id,
        "paywallId": record.paywall_id,
        "ownerId": record.owner_id,
        "eventType": record.event_type,
        "level": record.level,
        "createdAtMs": record.created_at.timestamp_millis(),
    });
    if let Some(value) = record.request_id.as_ref() {
        payload["requestId"] = serde_json::json!(value);
    }
    if let Some(value) = record.metadata.as_ref() {
        payload["metadata"] = value.clone();
    }
    payload
}

fn lightning_ops_invoice_payload(record: &LightningOpsInvoiceRecord) -> serde_json::Value {
    let mut payload = serde_json::json!({
        "invoiceId": record.invoice_id,
        "paywallId": record.paywall_id,
        "ownerId": record.owner_id,
        "amountMsats": record.amount_msats,
        "status": record.status,
        "createdAtMs": record.created_at.timestamp_millis(),
        "updatedAtMs": record.updated_at.timestamp_millis(),
    });
    if let Some(value) = record.payment_hash.as_ref() {
        payload["paymentHash"] = serde_json::json!(value);
    }
    if let Some(value) = record.payment_request.as_ref() {
        payload["paymentRequest"] = serde_json::json!(value);
    }
    if let Some(value) = record.payment_proof_ref.as_ref() {
        payload["paymentProofRef"] = serde_json::json!(value);
    }
    if let Some(value) = record.request_id.as_ref() {
        payload["requestId"] = serde_json::json!(value);
    }
    if let Some(value) = record.settled_at_ms {
        payload["settledAtMs"] = serde_json::json!(value);
    }
    payload
}

fn lightning_ops_settlement_payload(record: &LightningOpsSettlementRecord) -> serde_json::Value {
    let mut payload = serde_json::json!({
        "settlementId": record.settlement_id,
        "paywallId": record.paywall_id,
        "ownerId": record.owner_id,
        "amountMsats": record.amount_msats,
        "paymentProofRef": record.payment_proof_ref,
        "createdAtMs": record.created_at.timestamp_millis(),
    });
    if let Some(value) = record.invoice_id.as_ref() {
        payload["invoiceId"] = serde_json::json!(value);
    }
    if let Some(value) = record.request_id.as_ref() {
        payload["requestId"] = serde_json::json!(value);
    }
    if let Some(value) = record.metadata.as_ref() {
        payload["metadata"] = value.clone();
    }
    payload
}

fn lightning_ops_global_security_payload(
    record: &LightningOpsGlobalSecurityRecord,
) -> serde_json::Value {
    let mut payload = serde_json::json!({
        "stateId": "global",
        "globalPause": record.global_pause,
        "updatedAtMs": record.updated_at_ms,
    });
    if let Some(value) = record.deny_reason_code.as_ref() {
        payload["denyReasonCode"] = serde_json::json!(value);
    }
    if let Some(value) = record.deny_reason.as_ref() {
        payload["denyReason"] = serde_json::json!(value);
    }
    if let Some(value) = record.updated_by.as_ref() {
        payload["updatedBy"] = serde_json::json!(value);
    }
    payload
}

fn lightning_ops_owner_control_payload(
    record: &LightningOpsOwnerControlRecord,
) -> serde_json::Value {
    let mut payload = serde_json::json!({
        "ownerId": record.owner_id,
        "killSwitch": record.kill_switch,
        "updatedAtMs": record.updated_at_ms,
    });
    if let Some(value) = record.deny_reason_code.as_ref() {
        payload["denyReasonCode"] = serde_json::json!(value);
    }
    if let Some(value) = record.deny_reason.as_ref() {
        payload["denyReason"] = serde_json::json!(value);
    }
    if let Some(value) = record.updated_by.as_ref() {
        payload["updatedBy"] = serde_json::json!(value);
    }
    payload
}

fn lightning_ops_credential_role_payload(
    record: &LightningOpsCredentialRoleRecord,
) -> serde_json::Value {
    let mut payload = serde_json::json!({
        "role": record.role,
        "status": record.status,
        "version": record.version,
        "updatedAtMs": record.updated_at_ms,
    });
    if let Some(value) = record.fingerprint.as_ref() {
        payload["fingerprint"] = serde_json::json!(value);
    }
    if let Some(value) = record.note.as_ref() {
        payload["note"] = serde_json::json!(value);
    }
    if let Some(value) = record.last_rotated_at_ms {
        payload["lastRotatedAtMs"] = serde_json::json!(value);
    }
    if let Some(value) = record.revoked_at_ms {
        payload["revokedAtMs"] = serde_json::json!(value);
    }
    payload
}

fn lightning_ops_invoice_lifecycle_input(
    args: &serde_json::Map<String, serde_json::Value>,
    status_override: Option<&str>,
) -> Result<LightningOpsInvoiceLifecycleInput, (StatusCode, Json<serde_json::Value>)> {
    let status = match status_override {
        Some(value) => value.to_string(),
        None => lightning_ops_required_string(args, "status")?,
    };
    if lightning_ops_invoice_status_rank(&status).is_none() {
        return Err(lightning_ops_invalid_arguments("invalid_invoice_status"));
    }

    Ok(LightningOpsInvoiceLifecycleInput {
        invoice_id: lightning_ops_required_string(args, "invoiceId")?,
        paywall_id: lightning_ops_required_string(args, "paywallId")?,
        owner_id: lightning_ops_required_string(args, "ownerId")?,
        amount_msats: lightning_ops_required_i64(args, "amountMsats")?,
        status,
        payment_hash: lightning_ops_optional_string(args, "paymentHash"),
        payment_request: lightning_ops_optional_string(args, "paymentRequest"),
        payment_proof_ref: lightning_ops_optional_string(args, "paymentProofRef"),
        request_id: lightning_ops_optional_string(args, "requestId"),
        settled_at_ms: lightning_ops_optional_i64(args, "settledAtMs"),
    })
}

fn lightning_ops_apply_invoice_lifecycle(
    store: &mut LightningOpsControlPlaneStore,
    input: LightningOpsInvoiceLifecycleInput,
) -> Result<(bool, LightningOpsInvoiceRecord), (StatusCode, Json<serde_json::Value>)> {
    let now = Utc::now();
    let now_ms = now.timestamp_millis();
    if let Some(existing) = store.invoices.get(&input.invoice_id).cloned() {
        let next_status = lightning_ops_choose_invoice_status(&existing.status, &input.status);
        let next_payment_hash = existing.payment_hash.clone().or(input.payment_hash.clone());
        let next_payment_request = existing
            .payment_request
            .clone()
            .or(input.payment_request.clone());
        let next_payment_proof_ref = existing
            .payment_proof_ref
            .clone()
            .or(input.payment_proof_ref.clone());
        let next_request_id = existing.request_id.clone().or(input.request_id.clone());
        let next_settled_at_ms = if next_status == "settled" {
            existing
                .settled_at_ms
                .or(input.settled_at_ms)
                .or(Some(now_ms))
        } else {
            existing.settled_at_ms
        };

        let changed = next_status != existing.status
            || input.amount_msats != existing.amount_msats
            || next_payment_hash != existing.payment_hash
            || next_payment_request != existing.payment_request
            || next_payment_proof_ref != existing.payment_proof_ref
            || next_request_id != existing.request_id
            || next_settled_at_ms != existing.settled_at_ms
            || input.paywall_id != existing.paywall_id
            || input.owner_id != existing.owner_id;

        let updated = LightningOpsInvoiceRecord {
            invoice_id: input.invoice_id.clone(),
            paywall_id: input.paywall_id,
            owner_id: input.owner_id,
            amount_msats: input.amount_msats,
            status: next_status,
            payment_hash: next_payment_hash,
            payment_request: next_payment_request,
            payment_proof_ref: next_payment_proof_ref,
            request_id: next_request_id,
            settled_at_ms: next_settled_at_ms,
            created_at: existing.created_at,
            updated_at: now,
        };
        store.invoices.insert(input.invoice_id, updated.clone());
        return Ok((changed, updated));
    }

    let settled_at_ms = if input.status == "settled" {
        input.settled_at_ms.or(Some(now_ms))
    } else {
        None
    };

    let created = LightningOpsInvoiceRecord {
        invoice_id: input.invoice_id.clone(),
        paywall_id: input.paywall_id,
        owner_id: input.owner_id,
        amount_msats: input.amount_msats,
        status: input.status,
        payment_hash: input.payment_hash,
        payment_request: input.payment_request,
        payment_proof_ref: input.payment_proof_ref,
        request_id: input.request_id,
        settled_at_ms,
        created_at: now,
        updated_at: now,
    };
    store.invoices.insert(input.invoice_id, created.clone());
    Ok((true, created))
}

fn lightning_ops_choose_invoice_status(current: &str, incoming: &str) -> String {
    let current_rank = lightning_ops_invoice_status_rank(current).unwrap_or(0);
    let incoming_rank = lightning_ops_invoice_status_rank(incoming).unwrap_or(0);
    if incoming_rank > current_rank {
        incoming.to_string()
    } else {
        current.to_string()
    }
}

fn lightning_ops_invoice_status_rank(status: &str) -> Option<i32> {
    match status {
        "open" => Some(0),
        "canceled" | "expired" => Some(1),
        "settled" => Some(2),
        _ => None,
    }
}

fn lightning_ops_required_string(
    args: &serde_json::Map<String, serde_json::Value>,
    field: &'static str,
) -> Result<String, (StatusCode, Json<serde_json::Value>)> {
    lightning_ops_optional_string(args, field)
        .ok_or_else(|| lightning_ops_invalid_arguments(format!("missing_{field}")))
}

fn lightning_ops_optional_string(
    args: &serde_json::Map<String, serde_json::Value>,
    field: &'static str,
) -> Option<String> {
    args.get(field)
        .and_then(serde_json::Value::as_str)
        .map(str::trim)
        .filter(|value| !value.is_empty())
        .map(ToString::to_string)
}

fn lightning_ops_required_i64(
    args: &serde_json::Map<String, serde_json::Value>,
    field: &'static str,
) -> Result<i64, (StatusCode, Json<serde_json::Value>)> {
    lightning_ops_optional_i64(args, field)
        .ok_or_else(|| lightning_ops_invalid_arguments(format!("missing_{field}")))
}

fn lightning_ops_optional_i64(
    args: &serde_json::Map<String, serde_json::Value>,
    field: &'static str,
) -> Option<i64> {
    let value = args.get(field)?;
    match value {
        serde_json::Value::Number(number) => number
            .as_i64()
            .or_else(|| number.as_u64().and_then(|raw| i64::try_from(raw).ok())),
        serde_json::Value::String(raw) => raw.trim().parse::<i64>().ok(),
        _ => None,
    }
}

fn lightning_ops_optional_json(
    args: &serde_json::Map<String, serde_json::Value>,
    field: &'static str,
) -> Option<serde_json::Value> {
    args.get(field).and_then(|value| {
        if value.is_object() || value.is_array() {
            Some(value.clone())
        } else {
            None
        }
    })
}

fn lightning_ops_bool(
    args: &serde_json::Map<String, serde_json::Value>,
    field: &'static str,
) -> bool {
    args.get(field)
        .and_then(|value| match value {
            serde_json::Value::Bool(boolean) => Some(*boolean),
            serde_json::Value::Number(number) => number
                .as_i64()
                .map(|value| value != 0)
                .or_else(|| number.as_u64().map(|value| value != 0)),
            serde_json::Value::String(raw) => {
                let normalized = raw.trim().to_ascii_lowercase();
                if normalized.is_empty() || normalized == "0" {
                    Some(false)
                } else if matches!(normalized.as_str(), "false" | "off" | "no") {
                    Some(false)
                } else {
                    Some(true)
                }
            }
            _ => None,
        })
        .unwrap_or(false)
}

fn lightning_ops_meta_i64(meta: Option<&serde_json::Value>, key: &'static str) -> Option<i64> {
    let object = meta.and_then(serde_json::Value::as_object)?;
    match object.get(key) {
        Some(serde_json::Value::Number(number)) => number
            .as_i64()
            .or_else(|| number.as_u64().and_then(|raw| i64::try_from(raw).ok())),
        Some(serde_json::Value::String(raw)) => raw.trim().parse::<i64>().ok(),
        _ => None,
    }
}

fn lightning_ops_meta_string_list(
    meta: Option<&serde_json::Value>,
    key: &'static str,
) -> Option<Vec<String>> {
    let object = meta.and_then(serde_json::Value::as_object)?;
    let values = object.get(key)?.as_array()?;
    Some(
        values
            .iter()
            .filter_map(serde_json::Value::as_str)
            .map(str::trim)
            .filter(|value| !value.is_empty())
            .map(ToString::to_string)
            .collect::<Vec<_>>(),
    )
}

fn lightning_ops_map_domain_store_error(
    error: DomainStoreError,
) -> (StatusCode, Json<serde_json::Value>) {
    match error {
        DomainStoreError::NotFound => lightning_ops_invalid_arguments("not_found"),
        DomainStoreError::Forbidden => lightning_ops_invalid_arguments("forbidden"),
        DomainStoreError::Validation { message, .. } => lightning_ops_invalid_arguments(message),
        DomainStoreError::Conflict { message } => lightning_ops_invalid_arguments(message),
        DomainStoreError::Persistence { message } => lightning_ops_error(
            StatusCode::SERVICE_UNAVAILABLE,
            "service_unavailable",
            message,
        ),
    }
}

fn lightning_ops_invalid_arguments(
    message: impl Into<String>,
) -> (StatusCode, Json<serde_json::Value>) {
    lightning_ops_error(
        StatusCode::UNPROCESSABLE_ENTITY,
        "invalid_arguments",
        message.into(),
    )
}

fn lightning_ops_error(
    status: StatusCode,
    code: &'static str,
    message: impl Into<String>,
) -> (StatusCode, Json<serde_json::Value>) {
    (
        status,
        Json(serde_json::json!({
            "error": {
                "code": code,
                "message": message.into(),
            }
        })),
    )
}

async fn l402_wallet(
    State(state): State<AppState>,
    headers: HeaderMap,
    Query(query): Query<L402AutopilotQuery>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let autopilot_filter =
        resolve_l402_autopilot_filter(&state, &bundle.user.id, query.autopilot).await?;
    let autopilot_id = autopilot_filter.as_ref().map(|value| value.id.as_str());

    let receipts = state
        ._domain_store
        .list_l402_receipts_for_user(&bundle.user.id, autopilot_id, 200, 0)
        .await
        .map_err(map_domain_store_error)?
        .into_iter()
        .map(map_l402_receipt_row)
        .collect::<Vec<_>>();

    let total_paid_msats: i64 = receipts
        .iter()
        .filter(|receipt| receipt.paid)
        .filter_map(|receipt| receipt.amount_msats)
        .sum();

    let summary = serde_json::json!({
        "totalAttempts": receipts.len(),
        "paidCount": receipts.iter().filter(|receipt| receipt.paid).count(),
        "cachedCount": receipts
            .iter()
            .filter(|receipt| receipt.status == "cached" || receipt.cache_status.as_deref() == Some("hit"))
            .count(),
        "blockedCount": receipts.iter().filter(|receipt| receipt.status == "blocked").count(),
        "failedCount": receipts.iter().filter(|receipt| receipt.status == "failed").count(),
        "totalPaidMsats": total_paid_msats,
        "totalPaidSats": l402_msats_to_sats(Some(total_paid_msats)).unwrap_or(0.0),
    });

    let last_paid = receipts
        .iter()
        .find(|receipt| receipt.paid)
        .map(l402_receipt_payload)
        .unwrap_or(serde_json::Value::Null);

    let recent = receipts
        .iter()
        .take(20)
        .map(l402_receipt_payload)
        .collect::<Vec<_>>();

    let spark_wallet = state
        ._domain_store
        .find_user_spark_wallet(&bundle.user.id)
        .await
        .map_err(map_domain_store_error)?;

    Ok(ok_data(serde_json::json!({
        "summary": summary,
        "lastPaid": last_paid,
        "recent": recent,
        "sparkWallet": l402_wallet_payload(spark_wallet.as_ref()),
        "settings": l402_settings_payload(),
        "filter": {
            "autopilot": l402_filter_payload(autopilot_filter.as_ref())
        }
    })))
}

async fn l402_transactions(
    State(state): State<AppState>,
    headers: HeaderMap,
    Query(query): Query<L402TransactionsQuery>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let autopilot_filter =
        resolve_l402_autopilot_filter(&state, &bundle.user.id, query.autopilot).await?;
    let autopilot_id = autopilot_filter.as_ref().map(|value| value.id.as_str());

    let per_page = query.per_page.unwrap_or(30).clamp(1, 200);
    let page = query.page.unwrap_or(1).max(1);
    let offset = page.saturating_sub(1).saturating_mul(per_page);

    let total = state
        ._domain_store
        .count_l402_receipts_for_user(&bundle.user.id, autopilot_id)
        .await
        .map_err(map_domain_store_error)?;
    let rows = state
        ._domain_store
        .list_l402_receipts_for_user(&bundle.user.id, autopilot_id, per_page, offset)
        .await
        .map_err(map_domain_store_error)?
        .into_iter()
        .map(map_l402_receipt_row)
        .collect::<Vec<_>>();

    let last_page = if total == 0 {
        1
    } else {
        ((total - 1) / per_page as u64) + 1
    };

    Ok(ok_data(serde_json::json!({
        "transactions": rows.iter().map(l402_receipt_payload).collect::<Vec<_>>(),
        "pagination": {
            "currentPage": page,
            "lastPage": last_page,
            "perPage": per_page,
            "total": total,
            "hasMorePages": (page as u64) < last_page,
        },
        "filter": {
            "autopilot": l402_filter_payload(autopilot_filter.as_ref())
        }
    })))
}

async fn l402_transaction_show(
    State(state): State<AppState>,
    Path(event_id): Path<String>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let normalized_event_id = event_id
        .trim()
        .parse::<u64>()
        .map_err(|_| not_found_error("Not found."))?;

    let row = state
        ._domain_store
        .find_l402_receipt_for_user(&bundle.user.id, normalized_event_id)
        .await
        .map_err(map_domain_store_error)?
        .ok_or_else(|| not_found_error("Not found."))?;

    Ok(ok_data(serde_json::json!({
        "transaction": l402_receipt_payload(&map_l402_receipt_row(row))
    })))
}

async fn l402_paywalls(
    State(state): State<AppState>,
    headers: HeaderMap,
    Query(query): Query<L402AutopilotQuery>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let autopilot_filter =
        resolve_l402_autopilot_filter(&state, &bundle.user.id, query.autopilot).await?;
    let autopilot_id = autopilot_filter.as_ref().map(|value| value.id.as_str());

    let receipts = state
        ._domain_store
        .list_l402_receipts_for_user(&bundle.user.id, autopilot_id, 500, 0)
        .await
        .map_err(map_domain_store_error)?
        .into_iter()
        .map(map_l402_receipt_row)
        .collect::<Vec<_>>();

    let mut grouped: HashMap<String, Vec<L402ReceiptView>> = HashMap::new();
    for receipt in receipts.iter().cloned() {
        let scope = receipt.scope.clone().unwrap_or_default();
        let key = format!("{}|{}", receipt.host, scope);
        grouped.entry(key).or_default().push(receipt);
    }

    let mut paywalls = grouped
        .into_iter()
        .map(|(key, mut items)| {
            let mut parts = key.splitn(2, '|');
            let host = parts.next().unwrap_or("unknown").to_string();
            let scope = parts.next().unwrap_or_default().to_string();
            items.sort_by(|left, right| right.created_at.cmp(&left.created_at));

            let total_paid_msats: i64 = items
                .iter()
                .filter(|receipt| receipt.paid)
                .filter_map(|receipt| receipt.amount_msats)
                .sum();

            let last = items.first();
            serde_json::json!({
                "host": host,
                "scope": scope,
                "attempts": items.len(),
                "paid": items.iter().filter(|receipt| receipt.paid).count(),
                "cached": items
                    .iter()
                    .filter(|receipt| receipt.status == "cached" || receipt.cache_status.as_deref() == Some("hit"))
                    .count(),
                "blocked": items.iter().filter(|receipt| receipt.status == "blocked").count(),
                "failed": items.iter().filter(|receipt| receipt.status == "failed").count(),
                "totalPaidMsats": total_paid_msats,
                "totalPaidSats": l402_msats_to_sats(Some(total_paid_msats)).unwrap_or(0.0),
                "lastAttemptAt": last.map(|receipt| receipt.created_at.clone()),
                "lastStatus": last
                    .map(|receipt| receipt.status.clone())
                    .unwrap_or_else(|| "unknown".to_string()),
            })
        })
        .collect::<Vec<_>>();

    paywalls.sort_by(|left, right| {
        let right_value = right
            .get("lastAttemptAt")
            .and_then(serde_json::Value::as_str)
            .unwrap_or_default();
        let left_value = left
            .get("lastAttemptAt")
            .and_then(serde_json::Value::as_str)
            .unwrap_or_default();
        right_value.cmp(left_value)
    });

    Ok(ok_data(serde_json::json!({
        "paywalls": paywalls,
        "summary": {
            "uniqueTargets": receipts
                .iter()
                .map(|receipt| format!("{}|{}", receipt.host, receipt.scope.clone().unwrap_or_default()))
                .collect::<std::collections::HashSet<_>>()
                .len(),
            "totalAttempts": receipts.len(),
            "totalPaidCount": receipts.iter().filter(|receipt| receipt.paid).count(),
        },
        "filter": {
            "autopilot": l402_filter_payload(autopilot_filter.as_ref())
        }
    })))
}

async fn l402_settlements(
    State(state): State<AppState>,
    headers: HeaderMap,
    Query(query): Query<L402AutopilotQuery>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let autopilot_filter =
        resolve_l402_autopilot_filter(&state, &bundle.user.id, query.autopilot).await?;
    let autopilot_id = autopilot_filter.as_ref().map(|value| value.id.as_str());

    let receipts = state
        ._domain_store
        .list_l402_receipts_for_user(&bundle.user.id, autopilot_id, 500, 0)
        .await
        .map_err(map_domain_store_error)?
        .into_iter()
        .map(map_l402_receipt_row)
        .collect::<Vec<_>>();

    let settlements = receipts
        .iter()
        .filter(|receipt| receipt.paid)
        .cloned()
        .collect::<Vec<_>>();

    let mut daily_map: HashMap<String, Vec<L402ReceiptView>> = HashMap::new();
    for receipt in settlements.iter().cloned() {
        let date = receipt.created_at.chars().take(10).collect::<String>();
        daily_map.entry(date).or_default().push(receipt);
    }

    let mut daily = daily_map
        .into_iter()
        .map(|(date, items)| {
            let total_msats: i64 = items
                .iter()
                .filter_map(|receipt| receipt.amount_msats)
                .sum();
            serde_json::json!({
                "date": date,
                "count": items.len(),
                "totalMsats": total_msats,
                "totalSats": l402_msats_to_sats(Some(total_msats)).unwrap_or(0.0),
            })
        })
        .collect::<Vec<_>>();
    daily.sort_by(|left, right| {
        right
            .get("date")
            .and_then(serde_json::Value::as_str)
            .unwrap_or_default()
            .cmp(
                left.get("date")
                    .and_then(serde_json::Value::as_str)
                    .unwrap_or_default(),
            )
    });

    let total_msats: i64 = settlements
        .iter()
        .filter_map(|receipt| receipt.amount_msats)
        .sum();

    Ok(ok_data(serde_json::json!({
        "summary": {
            "settledCount": settlements.len(),
            "totalMsats": total_msats,
            "totalSats": l402_msats_to_sats(Some(total_msats)).unwrap_or(0.0),
            "latestSettlementAt": settlements.first().map(|receipt| receipt.created_at.clone()),
        },
        "daily": daily,
        "settlements": settlements.iter().take(100).map(l402_receipt_payload).collect::<Vec<_>>(),
        "filter": {
            "autopilot": l402_filter_payload(autopilot_filter.as_ref())
        }
    })))
}

async fn l402_deployments(
    State(state): State<AppState>,
    headers: HeaderMap,
    Query(query): Query<L402AutopilotQuery>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let autopilot_filter =
        resolve_l402_autopilot_filter(&state, &bundle.user.id, query.autopilot).await?;
    let autopilot_id = autopilot_filter.as_ref().map(|value| value.id.as_str());

    let allowed_types = [
        "l402_gateway_deployment",
        "l402_gateway_event",
        "l402_executor_heartbeat",
        "l402_paywall_created",
        "l402_paywall_updated",
        "l402_paywall_deleted",
    ];

    let deployments = state
        ._domain_store
        .list_l402_gateway_events_for_user(&bundle.user.id, autopilot_id, 100)
        .await
        .map_err(map_domain_store_error)?
        .into_iter()
        .filter(|event| allowed_types.contains(&event.event_type.as_str()))
        .map(l402_gateway_event_payload)
        .collect::<Vec<_>>();

    Ok(ok_data(serde_json::json!({
        "deployments": deployments,
        "configSnapshot": l402_deployments_config_snapshot_payload(),
        "filter": {
            "autopilot": l402_filter_payload(autopilot_filter.as_ref())
        }
    })))
}

async fn l402_paywall_create(
    State(state): State<AppState>,
    headers: HeaderMap,
    Json(payload): Json<L402PaywallCreateRequestPayload>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;

    let name = validate_l402_required_string(payload.name, "name", 120)?;
    let host_regexp = validate_l402_regex_body(payload.host_regexp, "hostRegexp", false)?;
    let path_regexp = validate_l402_regex_body(payload.path_regexp, "pathRegexp", true)?;
    let price_msats = validate_l402_price_msats(payload.price_msats, "priceMsats")?;
    let upstream = validate_l402_upstream(payload.upstream, "upstream")?;
    let metadata = validate_optional_json_object_or_array(payload.meta, "metadata")?;

    let paywall = state
        ._domain_store
        .create_l402_paywall(CreateL402PaywallInput {
            owner_user_id: bundle.user.id.clone(),
            name,
            host_regexp,
            path_regexp,
            price_msats,
            upstream,
            enabled: payload.enabled,
            meta: metadata,
        })
        .await
        .map_err(map_domain_store_error)?;

    let mutation_event = state
        ._domain_store
        .record_l402_gateway_event(RecordL402GatewayEventInput {
            user_id: bundle.user.id.clone(),
            autopilot_id: None,
            event_type: "l402_paywall_created".to_string(),
            payload: serde_json::json!({
                "paywallId": paywall.id.clone(),
                "name": paywall.name.clone(),
                "priceMsats": paywall.price_msats,
                "enabled": paywall.enabled,
            }),
            created_at: Some(Utc::now()),
        })
        .await
        .map_err(map_domain_store_error)?;

    state.observability.audit(
        AuditEvent::new("l402.paywall.created", request_id.clone())
            .with_user_id(bundle.user.id.clone())
            .with_session_id(bundle.session.session_id.clone())
            .with_org_id(bundle.session.active_org_id.clone())
            .with_device_id(bundle.session.device_id.clone())
            .with_attribute("paywall_id", paywall.id.clone())
            .with_attribute("price_msats", paywall.price_msats.to_string())
            .with_attribute("enabled", paywall.enabled.to_string()),
    );
    state
        .observability
        .increment_counter("l402.paywall.created", &request_id);

    Ok((
        StatusCode::CREATED,
        Json(serde_json::json!({
            "data": {
                "paywall": l402_paywall_payload(&paywall),
                "deployment": l402_paywall_deployment_payload(&mutation_event),
                "mutationEventId": mutation_event.id,
            }
        })),
    ))
}

async fn l402_paywall_update(
    State(state): State<AppState>,
    Path(paywall_id): Path<String>,
    headers: HeaderMap,
    Json(payload): Json<L402PaywallUpdateRequestPayload>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let paywall_id = non_empty(paywall_id).ok_or_else(|| not_found_error("Not found."))?;

    let name = validate_l402_optional_mutable_string(payload.name, "name", 120)?;
    let host_regexp = validate_l402_optional_regex_body(payload.host_regexp, "hostRegexp", false)?;
    let path_regexp = validate_l402_optional_regex_body(payload.path_regexp, "pathRegexp", true)?;
    let price_msats = payload
        .price_msats
        .map(|value| validate_l402_price_msats(value, "priceMsats"))
        .transpose()?;
    let upstream = payload
        .upstream
        .map(|value| validate_l402_upstream(value, "upstream"))
        .transpose()?;
    let metadata = validate_optional_json_object_or_array(payload.meta, "metadata")?;

    if name.is_none()
        && host_regexp.is_none()
        && path_regexp.is_none()
        && price_msats.is_none()
        && upstream.is_none()
        && payload.enabled.is_none()
        && metadata.is_none()
    {
        return Err(validation_error(
            "payload",
            "At least one mutable paywall field must be provided.",
        ));
    }

    let paywall = state
        ._domain_store
        .update_owned_l402_paywall(
            &bundle.user.id,
            &paywall_id,
            UpdateL402PaywallInput {
                name,
                host_regexp,
                path_regexp,
                price_msats,
                upstream,
                enabled: payload.enabled,
                meta: metadata,
                last_reconcile_status: Some("applied".to_string()),
                last_reconcile_error: Some(String::new()),
                last_reconciled_at: Some(Utc::now()),
            },
        )
        .await
        .map_err(map_domain_store_error)?;

    let mutation_event = state
        ._domain_store
        .record_l402_gateway_event(RecordL402GatewayEventInput {
            user_id: bundle.user.id.clone(),
            autopilot_id: None,
            event_type: "l402_paywall_updated".to_string(),
            payload: serde_json::json!({
                "paywallId": paywall.id.clone(),
                "priceMsats": paywall.price_msats,
                "enabled": paywall.enabled,
            }),
            created_at: Some(Utc::now()),
        })
        .await
        .map_err(map_domain_store_error)?;

    state.observability.audit(
        AuditEvent::new("l402.paywall.updated", request_id.clone())
            .with_user_id(bundle.user.id.clone())
            .with_session_id(bundle.session.session_id.clone())
            .with_org_id(bundle.session.active_org_id.clone())
            .with_device_id(bundle.session.device_id.clone())
            .with_attribute("paywall_id", paywall.id.clone())
            .with_attribute("mutation_event_id", mutation_event.id.to_string()),
    );
    state
        .observability
        .increment_counter("l402.paywall.updated", &request_id);

    Ok(ok_data(serde_json::json!({
        "paywall": l402_paywall_payload(&paywall),
        "deployment": l402_paywall_deployment_payload(&mutation_event),
        "mutationEventId": mutation_event.id,
    })))
}

async fn l402_paywall_delete(
    State(state): State<AppState>,
    Path(paywall_id): Path<String>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let paywall_id = non_empty(paywall_id).ok_or_else(|| not_found_error("Not found."))?;

    let paywall = state
        ._domain_store
        .soft_delete_owned_l402_paywall(&bundle.user.id, &paywall_id)
        .await
        .map_err(map_domain_store_error)?;

    let mutation_event = state
        ._domain_store
        .record_l402_gateway_event(RecordL402GatewayEventInput {
            user_id: bundle.user.id.clone(),
            autopilot_id: None,
            event_type: "l402_paywall_deleted".to_string(),
            payload: serde_json::json!({
                "paywallId": paywall.id.clone(),
                "deletedAt": paywall.deleted_at.map(timestamp),
            }),
            created_at: Some(Utc::now()),
        })
        .await
        .map_err(map_domain_store_error)?;

    state.observability.audit(
        AuditEvent::new("l402.paywall.deleted", request_id.clone())
            .with_user_id(bundle.user.id.clone())
            .with_session_id(bundle.session.session_id.clone())
            .with_org_id(bundle.session.active_org_id.clone())
            .with_device_id(bundle.session.device_id.clone())
            .with_attribute("paywall_id", paywall.id.clone())
            .with_attribute("mutation_event_id", mutation_event.id.to_string()),
    );
    state
        .observability
        .increment_counter("l402.paywall.deleted", &request_id);

    Ok(ok_data(serde_json::json!({
        "deleted": true,
        "paywall": l402_paywall_payload(&paywall),
        "deployment": l402_paywall_deployment_payload(&mutation_event),
        "mutationEventId": mutation_event.id,
    })))
}

fn l402_paywall_payload(paywall: &L402PaywallRecord) -> serde_json::Value {
    let metadata = paywall
        .meta
        .clone()
        .unwrap_or_else(|| serde_json::Value::Array(Vec::new()));

    serde_json::json!({
        "id": paywall.id,
        "ownerUserId": paywall.owner_user_id,
        "name": paywall.name,
        "hostRegexp": paywall.host_regexp,
        "pathRegexp": paywall.path_regexp,
        "priceMsats": paywall.price_msats,
        "upstream": paywall.upstream,
        "enabled": paywall.enabled,
        "metadata": metadata,
        "lastReconcileStatus": paywall.last_reconcile_status,
        "lastReconcileError": paywall.last_reconcile_error,
        "lastReconciledAt": paywall.last_reconciled_at.map(timestamp),
        "createdAt": timestamp(paywall.created_at),
        "updatedAt": timestamp(paywall.updated_at),
        "deletedAt": paywall.deleted_at.map(timestamp),
    })
}

fn l402_paywall_deployment_payload(event: &L402GatewayEventRecord) -> serde_json::Value {
    serde_json::json!({
        "status": "applied",
        "eventType": event.event_type,
        "eventId": event.id,
        "reverted": false,
    })
}

fn validate_l402_required_string(
    value: String,
    field: &'static str,
    max_chars: usize,
) -> Result<String, (StatusCode, Json<ApiErrorResponse>)> {
    let trimmed = value.trim();
    if trimmed.is_empty() {
        return Err(validation_error(field, "The field is required."));
    }
    if trimmed.chars().count() > max_chars {
        return Err(validation_error(
            field,
            &format!("Value may not be greater than {max_chars} characters."),
        ));
    }
    Ok(trimmed.to_string())
}

fn validate_l402_optional_mutable_string(
    value: Option<String>,
    field: &'static str,
    max_chars: usize,
) -> Result<Option<String>, (StatusCode, Json<ApiErrorResponse>)> {
    let Some(value) = value else {
        return Ok(None);
    };

    let trimmed = value.trim();
    if trimmed.is_empty() {
        return Err(validation_error(
            field,
            "The field is required when present.",
        ));
    }
    if trimmed.chars().count() > max_chars {
        return Err(validation_error(
            field,
            &format!("Value may not be greater than {max_chars} characters."),
        ));
    }

    Ok(Some(trimmed.to_string()))
}

fn validate_l402_regex_body(
    value: String,
    field: &'static str,
    must_start_with_path_anchor: bool,
) -> Result<String, (StatusCode, Json<ApiErrorResponse>)> {
    let normalized = validate_l402_required_string(value, field, 255)?;

    if must_start_with_path_anchor && !normalized.starts_with("^/") {
        return Err(validation_error(
            field,
            "The field must start with '^/' to scope path matching.",
        ));
    }

    if !must_start_with_path_anchor && !normalized.contains('.') && !normalized.contains("\\.") {
        return Err(validation_error(
            field,
            "The field must include an explicit host pattern.",
        ));
    }

    Ok(normalized)
}

fn validate_l402_optional_regex_body(
    value: Option<String>,
    field: &'static str,
    must_start_with_path_anchor: bool,
) -> Result<Option<String>, (StatusCode, Json<ApiErrorResponse>)> {
    let Some(value) = value else {
        return Ok(None);
    };
    validate_l402_regex_body(value, field, must_start_with_path_anchor).map(Some)
}

fn validate_l402_price_msats(
    value: u64,
    field: &'static str,
) -> Result<u64, (StatusCode, Json<ApiErrorResponse>)> {
    const MAX_PRICE_MSATS: u64 = 1_000_000_000_000;
    if value < 1 {
        return Err(validation_error(field, "The value must be at least 1."));
    }
    if value > MAX_PRICE_MSATS {
        return Err(validation_error(
            field,
            "The value may not be greater than 1000000000000.",
        ));
    }
    Ok(value)
}

fn validate_l402_upstream(
    value: String,
    field: &'static str,
) -> Result<String, (StatusCode, Json<ApiErrorResponse>)> {
    let normalized = validate_l402_required_string(value, field, 2048)?;
    let parsed = reqwest::Url::parse(&normalized)
        .map_err(|_| validation_error(field, "The field must be a valid URL."))?;
    if !matches!(parsed.scheme(), "http" | "https") {
        return Err(validation_error(
            field,
            "The field must start with http:// or https://.",
        ));
    }
    Ok(normalized)
}

fn map_l402_receipt_row(row: L402ReceiptRecord) -> L402ReceiptView {
    let payload = if row.payload.is_object() {
        row.payload
    } else {
        serde_json::json!({})
    };

    let amount_msats = l402_optional_i64(payload.get("amountMsats"));
    let quoted_amount_msats = l402_optional_i64(payload.get("quotedAmountMsats"));
    let max_spend_msats = l402_optional_i64(payload.get("maxSpendMsats"));

    L402ReceiptView {
        event_id: row.id,
        thread_id: row.thread_id,
        thread_title: row
            .thread_title
            .unwrap_or_else(|| "Conversation".to_string()),
        run_id: row.run_id,
        run_status: row.run_status,
        run_started_at: row.run_started_at.map(timestamp),
        run_completed_at: row.run_completed_at.map(timestamp),
        created_at: timestamp(row.created_at),
        status: l402_optional_string(payload.get("status"))
            .unwrap_or_else(|| "unknown".to_string()),
        host: l402_optional_string(payload.get("host")).unwrap_or_else(|| "unknown".to_string()),
        scope: l402_optional_string(payload.get("scope")),
        paid: l402_optional_bool(payload.get("paid")).unwrap_or(false),
        cache_hit: l402_optional_bool(payload.get("cacheHit")).unwrap_or(false),
        cache_status: l402_optional_string(payload.get("cacheStatus")),
        amount_msats,
        quoted_amount_msats,
        max_spend_msats,
        proof_reference: l402_optional_string(payload.get("proofReference")),
        deny_code: l402_optional_string(payload.get("denyCode")),
        task_id: l402_optional_string(payload.get("taskId")),
        approval_required: l402_optional_bool(payload.get("approvalRequired")).unwrap_or(false),
        response_status_code: l402_optional_i64(payload.get("responseStatusCode")),
        response_body_sha256: l402_optional_string(payload.get("responseBodySha256")),
        tool_call_id: l402_optional_string(payload.get("tool_call_id"))
            .or_else(|| l402_optional_string(payload.get("toolCallId"))),
        raw_payload: payload,
    }
}

fn l402_receipt_payload(receipt: &L402ReceiptView) -> serde_json::Value {
    serde_json::json!({
        "eventId": receipt.event_id,
        "threadId": receipt.thread_id,
        "threadTitle": receipt.thread_title,
        "runId": receipt.run_id,
        "runStatus": receipt.run_status,
        "runStartedAt": receipt.run_started_at,
        "runCompletedAt": receipt.run_completed_at,
        "createdAt": receipt.created_at,
        "status": receipt.status,
        "host": receipt.host,
        "scope": receipt.scope,
        "paid": receipt.paid,
        "cacheHit": receipt.cache_hit,
        "cacheStatus": receipt.cache_status,
        "amountMsats": receipt.amount_msats,
        "amountSats": l402_msats_to_sats(receipt.amount_msats),
        "quotedAmountMsats": receipt.quoted_amount_msats,
        "quotedAmountSats": l402_msats_to_sats(receipt.quoted_amount_msats),
        "maxSpendMsats": receipt.max_spend_msats,
        "maxSpendSats": l402_msats_to_sats(receipt.max_spend_msats),
        "proofReference": receipt.proof_reference,
        "denyCode": receipt.deny_code,
        "taskId": receipt.task_id,
        "approvalRequired": receipt.approval_required,
        "responseStatusCode": receipt.response_status_code,
        "responseBodySha256": receipt.response_body_sha256,
        "toolCallId": receipt.tool_call_id,
        "rawPayload": receipt.raw_payload,
    })
}

fn l402_gateway_event_payload(event: L402GatewayEventRecord) -> serde_json::Value {
    let payload = if event.payload.is_object() {
        event.payload
    } else {
        serde_json::json!({})
    };

    serde_json::json!({
        "eventId": event.id,
        "type": event.event_type,
        "createdAt": timestamp(event.created_at),
        "payload": payload,
    })
}

fn l402_filter_payload(filter: Option<&L402AutopilotFilterValue>) -> serde_json::Value {
    filter
        .map(|value| {
            serde_json::json!({
                "id": value.id,
                "handle": value.handle,
            })
        })
        .unwrap_or(serde_json::Value::Null)
}

fn l402_wallet_payload(wallet: Option<&UserSparkWalletRecord>) -> serde_json::Value {
    wallet
        .map(|value| {
            serde_json::json!({
                "walletId": value.wallet_id,
                "sparkAddress": value.spark_address,
                "lightningAddress": value.lightning_address,
                "identityPubkey": value.identity_pubkey,
                "balanceSats": value.last_balance_sats,
                "status": value.status,
                "provider": value.provider,
                "lastError": value.last_error,
                "lastSyncedAt": value.last_synced_at.map(timestamp),
            })
        })
        .unwrap_or(serde_json::Value::Null)
}

fn l402_settings_payload() -> serde_json::Value {
    let invoice_payer = l402_invoice_payer_kind();
    let allowlist_hosts = l402_allowlist_hosts_from_env();
    serde_json::json!({
        "enforceHostAllowlist": env_bool("L402_ENFORCE_HOST_ALLOWLIST", false),
        "allowlistHosts": allowlist_hosts,
        "invoicePayer": invoice_payer,
        "credentialTtlSeconds": env_u64("L402_CREDENTIAL_TTL_SECONDS", 600),
        "paymentTimeoutMs": env_u64("L402_PAYMENT_TIMEOUT_MS", 12_000),
        "responseMaxBytes": env_u64("L402_RESPONSE_MAX_BYTES", 65_536),
        "responsePreviewBytes": env_u64("L402_RESPONSE_PREVIEW_BYTES", 1_024),
    })
}

fn l402_deployments_config_snapshot_payload() -> serde_json::Value {
    let invoice_payer = l402_invoice_payer_kind();
    let allowlist_hosts = l402_allowlist_hosts_from_env();
    serde_json::json!({
        "enforceHostAllowlist": env_bool("L402_ENFORCE_HOST_ALLOWLIST", false),
        "allowlistHosts": allowlist_hosts,
        "invoicePayer": invoice_payer,
        "credentialTtlSeconds": env_u64("L402_CREDENTIAL_TTL_SECONDS", 600),
        "paymentTimeoutMs": env_u64("L402_PAYMENT_TIMEOUT_MS", 12_000),
        "demoPresets": vec![
            "sats4ai",
            "ep212_openagents_premium",
            "ep212_openagents_expensive",
            "fake",
        ],
    })
}

fn l402_optional_string(value: Option<&serde_json::Value>) -> Option<String> {
    let value = value?.as_str()?.trim();
    if value.is_empty() {
        None
    } else {
        Some(value.to_string())
    }
}

fn l402_optional_i64(value: Option<&serde_json::Value>) -> Option<i64> {
    let value = value?;
    if let Some(int_value) = value.as_i64() {
        return Some(int_value);
    }
    if let Some(uint_value) = value.as_u64() {
        return i64::try_from(uint_value).ok();
    }
    value
        .as_str()
        .and_then(|raw| raw.trim().parse::<i64>().ok())
}

fn l402_optional_bool(value: Option<&serde_json::Value>) -> Option<bool> {
    let value = value?;
    if let Some(bool_value) = value.as_bool() {
        return Some(bool_value);
    }
    if let Some(int_value) = value.as_i64() {
        return match int_value {
            1 => Some(true),
            0 => Some(false),
            _ => None,
        };
    }
    value.as_str().and_then(|raw| match raw.trim() {
        "1" | "true" | "TRUE" => Some(true),
        "0" | "false" | "FALSE" => Some(false),
        _ => None,
    })
}

fn l402_msats_to_sats(msats: Option<i64>) -> Option<f64> {
    msats.map(|value| (value as f64 / 1000.0 * 1000.0).round() / 1000.0)
}

async fn legacy_chats_index(
    State(state): State<AppState>,
    headers: HeaderMap,
    Query(query): Query<LegacyChatsListQuery>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let access_token =
        bearer_token(&headers).ok_or_else(|| unauthorized_error("Unauthenticated."))?;
    let session = state
        .auth
        .session_from_access_token(&access_token)
        .await
        .map_err(map_auth_error)?;

    let limit = query.limit.unwrap_or(50).clamp(1, 200);
    let mut threads = state
        .codex_thread_store
        .list_threads_for_user(&session.user.id, Some(&session.session.active_org_id))
        .await
        .map_err(map_thread_store_error)?;
    threads.truncate(limit);

    let data = threads
        .iter()
        .map(|thread| legacy_chat_summary(thread, None))
        .collect::<Vec<_>>();

    Ok(legacy_chat_data_response(
        serde_json::json!(data),
        StatusCode::OK,
    ))
}

async fn legacy_chats_store(
    State(state): State<AppState>,
    headers: HeaderMap,
    Json(payload): Json<LegacyCreateChatRequest>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let access_token =
        bearer_token(&headers).ok_or_else(|| unauthorized_error("Unauthenticated."))?;
    let session = state
        .auth
        .session_from_access_token(&access_token)
        .await
        .map_err(map_auth_error)?;

    let title = payload
        .title
        .as_deref()
        .and_then(|value| non_empty(value.to_string()))
        .unwrap_or_else(|| "New conversation".to_string());
    let conversation_id = format!("thread_{}", uuid::Uuid::new_v4().simple());
    let thread = state
        .codex_thread_store
        .create_thread_for_user(
            &session.user.id,
            &session.session.active_org_id,
            &conversation_id,
        )
        .await
        .map_err(map_thread_store_error)?;

    Ok(legacy_chat_data_response(
        legacy_chat_summary(&thread, Some(&title)),
        StatusCode::CREATED,
    ))
}

async fn legacy_chats_show(
    State(state): State<AppState>,
    Path(conversation_id): Path<String>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let access_token =
        bearer_token(&headers).ok_or_else(|| unauthorized_error("Unauthenticated."))?;
    let session = state
        .auth
        .session_from_access_token(&access_token)
        .await
        .map_err(map_auth_error)?;
    let normalized_conversation_id = normalized_conversation_id(&conversation_id)?;

    let thread = state
        .codex_thread_store
        .get_thread_for_user(&session.user.id, &normalized_conversation_id)
        .await
        .map_err(map_thread_store_error)?;
    let messages = state
        .codex_thread_store
        .list_thread_messages_for_user(&session.user.id, &normalized_conversation_id)
        .await
        .map_err(map_thread_store_error)?;

    Ok(legacy_chat_data_response(
        serde_json::json!({
            "conversation": legacy_chat_summary(&thread, None),
            "messages": legacy_chat_messages(&messages),
            "runs": [],
        }),
        StatusCode::OK,
    ))
}

async fn legacy_chats_messages(
    State(state): State<AppState>,
    Path(conversation_id): Path<String>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let access_token =
        bearer_token(&headers).ok_or_else(|| unauthorized_error("Unauthenticated."))?;
    let session = state
        .auth
        .session_from_access_token(&access_token)
        .await
        .map_err(map_auth_error)?;
    let normalized_conversation_id = normalized_conversation_id(&conversation_id)?;

    let _ = state
        .codex_thread_store
        .get_thread_for_user(&session.user.id, &normalized_conversation_id)
        .await
        .map_err(map_thread_store_error)?;
    let messages = state
        .codex_thread_store
        .list_thread_messages_for_user(&session.user.id, &normalized_conversation_id)
        .await
        .map_err(map_thread_store_error)?;

    Ok(legacy_chat_data_response(
        serde_json::json!(legacy_chat_messages(&messages)),
        StatusCode::OK,
    ))
}

async fn legacy_chat_guest_session_retired(
    State(state): State<AppState>,
    headers: HeaderMap,
) -> Result<Response, (StatusCode, Json<ApiErrorResponse>)> {
    let audit_request_id = request_id(&headers);
    let access_token = access_token_from_headers(&headers).ok_or_else(|| {
        unauthorized_error("Codex chat requires an authenticated ChatGPT account.")
    })?;
    let session = state
        .auth
        .session_from_access_token(&access_token)
        .await
        .map_err(map_auth_error)?;

    state.observability.audit(
        AuditEvent::new(
            "legacy.chat.guest_session.retired",
            audit_request_id.clone(),
        )
        .with_user_id(session.user.id.clone())
        .with_session_id(session.session.session_id.clone())
        .with_org_id(session.session.active_org_id.clone())
        .with_device_id(session.session.device_id.clone())
        .with_attribute("canonical", "/api/runtime/threads".to_string())
        .with_attribute("auth_policy", "codex_auth_required".to_string()),
    );
    state
        .observability
        .increment_counter("legacy.chat.guest_session.retired", &audit_request_id);

    let mut response = legacy_chat_data_response(
        serde_json::json!({
            "retired": true,
            "status": "codex_auth_required",
            "canonical": "/api/runtime/threads",
            "message": "Guest chat is retired. Authenticate with a ChatGPT account to use Codex threads."
        }),
        StatusCode::GONE,
    );
    response.headers_mut().insert(
        "x-oa-chat-auth-policy",
        HeaderValue::from_static("codex-auth-required"),
    );
    Ok(response)
}

async fn legacy_chat_stream(
    State(state): State<AppState>,
    headers: HeaderMap,
    Json(payload): Json<serde_json::Value>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    legacy_stream_bridge(state, None, headers, payload).await
}

async fn legacy_chats_stream(
    State(state): State<AppState>,
    Path(conversation_id): Path<String>,
    headers: HeaderMap,
    Json(payload): Json<serde_json::Value>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    legacy_stream_bridge(state, Some(conversation_id), headers, payload).await
}

async fn legacy_stream_bridge(
    state: AppState,
    conversation_id: Option<String>,
    headers: HeaderMap,
    payload: serde_json::Value,
) -> Result<Response, (StatusCode, Json<ApiErrorResponse>)> {
    let audit_request_id = request_id(&headers);
    let access_token =
        bearer_token(&headers).ok_or_else(|| unauthorized_error("Unauthenticated."))?;
    let session = state
        .auth
        .session_from_access_token(&access_token)
        .await
        .map_err(map_auth_error)?;

    let normalized_request =
        vercel_sse_adapter::normalize_legacy_stream_request(conversation_id.as_deref(), &payload)
            .map_err(map_legacy_stream_adapter_error)?;
    let thread_id = normalized_request.thread_id;
    let text = normalized_request.user_text;
    let worker_id = normalized_request.worker_id;
    validate_codex_turn_text(&text)?;
    let thread_id_for_bridge = thread_id.clone();
    let text_for_bridge = text.clone();
    let bridge_request_id = format!("legacy_stream_{}", uuid::Uuid::new_v4().simple());
    let control_request = RuntimeCodexWorkerControlRequest {
        request_id: bridge_request_id.clone(),
        method: "turn/start".to_string(),
        params: serde_json::json!({
            "thread_id": thread_id_for_bridge,
            "text": text_for_bridge,
        }),
        request_version: Some("v1".to_string()),
        source: Some("legacy_chat_stream_alias".to_string()),
        session_id: None,
        thread_id: None,
    };

    let worker_id_for_response = worker_id.unwrap_or_else(|| "desktopw:shared".to_string());
    let bridge_response =
        execute_codex_control_request(&state, &session, "turn/start", &control_request).await?;
    let stream_preview = vercel_sse_adapter::build_turn_start_preview(
        &thread_id,
        bridge_response
            .get("turn")
            .and_then(|turn| turn.get("id"))
            .and_then(serde_json::Value::as_str),
    )
    .ok();
    let preview_event_count = stream_preview
        .as_ref()
        .map(|preview| preview.events.len())
        .unwrap_or(0);
    let preview_wire_bytes = stream_preview
        .as_ref()
        .map(|preview| preview.wire.len())
        .unwrap_or(0);

    state.observability.audit(
        AuditEvent::new(
            "legacy.chat.stream.bridge.accepted",
            audit_request_id.clone(),
        )
        .with_user_id(session.user.id.clone())
        .with_session_id(session.session.session_id.clone())
        .with_org_id(session.session.active_org_id.clone())
        .with_device_id(session.session.device_id.clone())
        .with_attribute("thread_id", thread_id)
        .with_attribute("bridge_method", "turn/start")
        .with_attribute("bridge_request_id", bridge_request_id.clone())
        .with_attribute("worker_id", worker_id_for_response.clone())
        .with_attribute("adapter_preview_events", preview_event_count.to_string())
        .with_attribute("adapter_preview_wire_bytes", preview_wire_bytes.to_string()),
    );
    state
        .observability
        .increment_counter("legacy.chat.stream.bridge.accepted", &audit_request_id);

    let wire = stream_preview
        .map(|preview| preview.wire)
        .unwrap_or_else(|| {
            vercel_sse_adapter::serialize_sse(&[
                serde_json::json!({
                    "type": "error",
                    "code": "adapter_preview_unavailable",
                    "message": "stream preview unavailable",
                    "retryable": false
                }),
                serde_json::json!({
                    "type": "finish",
                    "status": "error"
                }),
            ])
        });

    Ok(legacy_chat_stream_sse_response(&state.config, wire))
}

async fn legacy_chats_runs(
    State(state): State<AppState>,
    Path(conversation_id): Path<String>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let access_token =
        bearer_token(&headers).ok_or_else(|| unauthorized_error("Unauthenticated."))?;
    let session = state
        .auth
        .session_from_access_token(&access_token)
        .await
        .map_err(map_auth_error)?;
    let normalized_conversation_id = normalized_conversation_id(&conversation_id)?;

    let _ = state
        .codex_thread_store
        .get_thread_for_user(&session.user.id, &normalized_conversation_id)
        .await
        .map_err(map_thread_store_error)?;

    Ok(legacy_chat_data_response(
        serde_json::json!([]),
        StatusCode::OK,
    ))
}

async fn legacy_chats_run_events(
    State(state): State<AppState>,
    Path((conversation_id, run_id)): Path<(String, String)>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let access_token =
        bearer_token(&headers).ok_or_else(|| unauthorized_error("Unauthenticated."))?;
    let session = state
        .auth
        .session_from_access_token(&access_token)
        .await
        .map_err(map_auth_error)?;
    let normalized_conversation_id = normalized_conversation_id(&conversation_id)?;
    let normalized_run_id = run_id.trim().to_string();
    if normalized_run_id.is_empty() {
        return Err(validation_error("run_id", "Run id is required."));
    }

    let _ = state
        .codex_thread_store
        .get_thread_for_user(&session.user.id, &normalized_conversation_id)
        .await
        .map_err(map_thread_store_error)?;

    Ok(legacy_chat_data_response(
        serde_json::json!({
            "run": {
                "id": normalized_run_id,
                "status": "retired",
                "modelProvider": "codex_app_server",
                "model": null,
            },
            "events": [],
        }),
        StatusCode::OK,
    ))
}

fn normalized_conversation_id(
    raw_conversation_id: &str,
) -> Result<String, (StatusCode, Json<ApiErrorResponse>)> {
    let normalized = raw_conversation_id.trim().to_string();
    if normalized.is_empty() {
        return Err(validation_error(
            "conversation_id",
            "Conversation id is required.",
        ));
    }
    Ok(normalized)
}

fn legacy_chat_data_response(payload: serde_json::Value, status: StatusCode) -> Response {
    (status, Json(serde_json::json!({ "data": payload }))).into_response()
}

fn legacy_chat_stream_sse_response(config: &Config, wire: String) -> Response {
    let mut response = (StatusCode::OK, Body::from(wire)).into_response();
    response.headers_mut().insert(
        CONTENT_TYPE,
        HeaderValue::from_static("text/event-stream; charset=utf-8"),
    );
    response.headers_mut().insert(
        CACHE_CONTROL,
        HeaderValue::from_static("no-cache, no-transform"),
    );
    response
        .headers_mut()
        .insert("connection", HeaderValue::from_static("keep-alive"));
    response
        .headers_mut()
        .insert("x-accel-buffering", HeaderValue::from_static("no"));
    response.headers_mut().insert(
        "x-vercel-ai-ui-message-stream",
        HeaderValue::from_static("v1"),
    );
    if let Ok(value) = HeaderValue::from_str(&config.compat_control_protocol_version) {
        response
            .headers_mut()
            .insert(HEADER_OA_PROTOCOL_VERSION, value);
    }
    if let Ok(value) = HeaderValue::from_str(&config.compat_control_min_client_build_id) {
        response
            .headers_mut()
            .insert(HEADER_OA_COMPAT_MIN_BUILD, value);
    }
    if let Some(max_build_id) = &config.compat_control_max_client_build_id
        && let Ok(value) = HeaderValue::from_str(max_build_id)
    {
        response
            .headers_mut()
            .insert(HEADER_OA_COMPAT_MAX_BUILD, value);
    }
    if let Ok(value) = HeaderValue::from_str(&config.compat_control_min_schema_version.to_string())
    {
        response
            .headers_mut()
            .insert(HEADER_OA_COMPAT_MIN_SCHEMA, value);
    }
    if let Ok(value) = HeaderValue::from_str(&config.compat_control_max_schema_version.to_string())
    {
        response
            .headers_mut()
            .insert(HEADER_OA_COMPAT_MAX_SCHEMA, value);
    }
    response
}

fn autopilot_stream_thread_id_from_payload(payload: &serde_json::Value) -> Option<String> {
    json_non_empty_string(payload.get("conversationId"))
        .or_else(|| json_non_empty_string(payload.get("conversation_id")))
        .or_else(|| json_non_empty_string(payload.get("threadId")))
        .or_else(|| json_non_empty_string(payload.get("thread_id")))
}

fn legacy_stream_worker_id_from_payload(payload: &serde_json::Value) -> Option<String> {
    json_non_empty_string(payload.get("worker_id"))
        .or_else(|| json_non_empty_string(payload.get("workerId")))
}

fn org_worker_events_topic(org_id: &str) -> String {
    if org_id.starts_with("org:") {
        format!("{org_id}:worker_events")
    } else {
        format!("org:{org_id}:worker_events")
    }
}

fn legacy_stream_user_text_from_payload(payload: &serde_json::Value) -> Option<String> {
    if let Some(text) = json_non_empty_string(payload.get("text"))
        .or_else(|| json_non_empty_string(payload.get("message")))
    {
        return Some(text);
    }

    let messages = payload.get("messages")?.as_array()?;
    for message in messages.iter().rev() {
        let role = json_non_empty_string(message.get("role"))
            .unwrap_or_else(|| "user".to_string())
            .to_ascii_lowercase();
        if role != "user" {
            continue;
        }
        if let Some(text) = legacy_stream_message_text(message) {
            return Some(text);
        }
    }

    None
}

fn legacy_stream_message_text(message: &serde_json::Value) -> Option<String> {
    if let Some(text) = json_non_empty_string(message.get("text"))
        .or_else(|| json_non_empty_string(message.get("message")))
    {
        return Some(text);
    }

    match message.get("content") {
        Some(serde_json::Value::String(content)) => non_empty(content.to_string()),
        Some(serde_json::Value::Object(content)) => json_non_empty_string(content.get("text")),
        Some(serde_json::Value::Array(parts)) => {
            let joined = parts
                .iter()
                .filter_map(|part| match part {
                    serde_json::Value::String(text) => non_empty(text.to_string()),
                    serde_json::Value::Object(object) => json_non_empty_string(object.get("text"))
                        .or_else(|| json_non_empty_string(object.get("value"))),
                    _ => None,
                })
                .collect::<Vec<_>>()
                .join("\n");
            non_empty(joined)
        }
        _ => None,
    }
}

fn json_non_empty_string(value: Option<&serde_json::Value>) -> Option<String> {
    let value = value?;
    let raw = value.as_str()?;
    non_empty(raw.to_string())
}

fn legacy_chat_summary(
    thread: &ThreadProjection,
    title_override: Option<&str>,
) -> serde_json::Value {
    serde_json::json!({
        "id": thread.thread_id,
        "title": title_override
            .map(str::to_string)
            .unwrap_or_else(|| format!("Codex Thread {}", thread.thread_id)),
        "autopilotId": serde_json::Value::Null,
        "createdAt": thread.created_at.to_rfc3339_opts(SecondsFormat::Millis, true),
        "updatedAt": thread.updated_at.to_rfc3339_opts(SecondsFormat::Millis, true),
    })
}

fn legacy_chat_messages(messages: &[ThreadMessageProjection]) -> Vec<serde_json::Value> {
    messages
        .iter()
        .map(|message| {
            serde_json::json!({
                "id": message.message_id,
                "runId": serde_json::Value::Null,
                "autopilotId": serde_json::Value::Null,
                "role": message.role,
                "content": message.text,
                "meta": serde_json::Value::Null,
                "createdAt": message.created_at.to_rfc3339_opts(SecondsFormat::Millis, true),
                "updatedAt": message.created_at.to_rfc3339_opts(SecondsFormat::Millis, true),
            })
        })
        .collect()
}

#[derive(Debug, Clone)]
struct CodingToolInvocation {
    integration_id: String,
    operation: String,
    repository: String,
    issue_number: Option<u64>,
    pull_number: Option<u64>,
    body: Option<String>,
    tool_call_id: Option<String>,
}

async fn runtime_tools_execute(
    State(state): State<AppState>,
    headers: HeaderMap,
    Json(payload): Json<RuntimeToolsExecuteRequestPayload>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let access_token =
        bearer_token(&headers).ok_or_else(|| unauthorized_error("Unauthenticated."))?;
    let session = state
        .auth
        .session_from_access_token(&access_token)
        .await
        .map_err(map_auth_error)?;

    let tool_pack = payload.tool_pack.trim().to_string();
    if tool_pack.is_empty() {
        return Err(validation_error(
            "tool_pack",
            "The tool_pack field is required.",
        ));
    }
    if tool_pack.chars().count() > 120 {
        return Err(validation_error(
            "tool_pack",
            "The tool_pack field may not be greater than 120 characters.",
        ));
    }
    if tool_pack != "coding.v1" {
        return Err(validation_error(
            "tool_pack",
            "Only coding.v1 is currently supported.",
        ));
    }

    let mode = payload
        .mode
        .and_then(non_empty)
        .unwrap_or_else(|| "execute".to_string())
        .to_lowercase();
    if !matches!(mode.as_str(), "execute" | "replay") {
        return Err(validation_error("mode", "The selected mode is invalid."));
    }

    let run_id = normalize_optional_bounded_string(payload.run_id, "run_id", 160)?;
    let thread_id = normalize_optional_bounded_string(payload.thread_id, "thread_id", 160)?;
    let requested_user_id = parse_optional_positive_u64(payload.user_id, "user_id")?;
    let authenticated_user_id = runtime_tools_principal_user_id(&session.user.id);

    if requested_user_id
        .map(|requested| requested != authenticated_user_id)
        .unwrap_or(false)
    {
        return Err(forbidden_error(
            "user_id does not match authenticated principal",
        ));
    }

    let manifest = validate_optional_json_object_or_array(payload.manifest, "manifest")?;
    let manifest_ref =
        validate_optional_json_object_or_array(payload.manifest_ref, "manifest_ref")?;
    if manifest.is_none() && manifest_ref.is_none() {
        return Err(error_response_with_status(
            StatusCode::UNPROCESSABLE_ENTITY,
            ApiErrorCode::InvalidRequest,
            "manifest or manifest_ref is required",
        ));
    }

    let mut request = payload.request;
    if !request.is_object() {
        return Err(validation_error(
            "request",
            "The request field must be an object.",
        ));
    }
    let policy = validate_optional_json_object_or_array(payload.policy, "policy")?
        .unwrap_or_else(|| serde_json::Value::Array(Vec::new()));

    let request_object = request
        .as_object_mut()
        .ok_or_else(|| validation_error("request", "The request field must be an object."))?;
    request_object.insert(
        "user_id".to_string(),
        serde_json::json!(authenticated_user_id),
    );
    if let Some(run_id) = run_id.as_ref() {
        if !request_object.contains_key("run_id") {
            request_object.insert("run_id".to_string(), serde_json::json!(run_id));
        }
    }
    if let Some(thread_id) = thread_id.as_ref() {
        if !request_object.contains_key("thread_id") {
            request_object.insert("thread_id".to_string(), serde_json::json!(thread_id));
        }
    }

    let invocation = parse_coding_tool_invocation(request_object)?;
    let evaluation = evaluate_coding_policy(&invocation, manifest.as_ref(), &policy);

    let receipt_seed = serde_json::json!({
        "tool_pack": tool_pack,
        "manifest": manifest.clone().unwrap_or_else(|| serde_json::Value::Array(Vec::new())),
        "manifest_ref": manifest_ref.clone().unwrap_or_else(|| serde_json::Value::Array(Vec::new())),
        "request": request,
        "policy": policy,
        "run_id": run_id.clone(),
        "thread_id": thread_id.clone(),
        "user_id": authenticated_user_id,
    });
    let replay_hash_hex = runtime_tools_replay_hash_hex(&receipt_seed);
    let replay_hash = format!("sha256:{replay_hash_hex}");
    let replay_key = format!("{authenticated_user_id}:{replay_hash_hex}");

    if let Some(replayed) = state
        .runtime_tool_receipts
        .entries
        .lock()
        .await
        .get(&replay_key)
        .cloned()
    {
        let replayed = mark_runtime_tools_replay(replayed);
        state.observability.audit(
            AuditEvent::new("runtime.tools.execute.accepted", request_id.clone())
                .with_user_id(session.user.id.clone())
                .with_session_id(session.session.session_id.clone())
                .with_org_id(session.session.active_org_id.clone())
                .with_device_id(session.session.device_id.clone())
                .with_attribute("tool_pack", "coding.v1".to_string())
                .with_attribute("operation", invocation.operation.clone())
                .with_attribute("mode", mode.clone())
                .with_attribute("idempotent_replay", "true".to_string())
                .with_attribute("decision", evaluation.decision.to_string())
                .with_attribute("reason_code", evaluation.reason_code.to_string()),
        );
        state
            .observability
            .increment_counter("runtime.tools.execute.accepted", &request_id);
        return Ok(ok_data(replayed));
    }

    let execution_result =
        build_coding_execution_result(&invocation, &evaluation, &replay_hash_hex);
    let mut response_payload = serde_json::json!({
        "state": evaluation.state,
        "decision": evaluation.decision,
        "reason_code": evaluation.reason_code,
        "tool_pack": "coding.v1",
        "mode": mode.clone(),
        "idempotentReplay": false,
        "receipt": {
            "receipt_id": format!("coding_{}", &replay_hash_hex[..24]),
            "replay_hash": replay_hash,
        },
        "policy": {
            "writeApproved": evaluation.write_approved,
            "writeOperationsMode": evaluation.write_operations_mode,
            "maxPerCallSats": evaluation.max_per_call_sats,
            "operationCostSats": evaluation.operation_cost_sats,
        },
        "request": {
            "integration_id": invocation.integration_id.clone(),
            "operation": invocation.operation.clone(),
            "repository": invocation.repository.clone(),
            "issue_number": invocation.issue_number,
            "pull_number": invocation.pull_number,
            "tool_call_id": invocation.tool_call_id.clone(),
            "run_id": run_id,
            "thread_id": thread_id,
            "user_id": authenticated_user_id,
        },
        "result": execution_result,
    });
    if let Some(message) = evaluation.denial_message.clone() {
        response_payload["error"] = serde_json::json!({
            "code": "policy_denied",
            "message": message,
        });
    }

    state
        .runtime_tool_receipts
        .entries
        .lock()
        .await
        .insert(replay_key, response_payload.clone());

    state.observability.audit(
        AuditEvent::new("runtime.tools.execute.accepted", request_id.clone())
            .with_user_id(session.user.id.clone())
            .with_session_id(session.session.session_id.clone())
            .with_org_id(session.session.active_org_id.clone())
            .with_device_id(session.session.device_id.clone())
            .with_attribute("tool_pack", "coding.v1".to_string())
            .with_attribute("operation", invocation.operation.clone())
            .with_attribute("mode", mode)
            .with_attribute("idempotent_replay", "false".to_string())
            .with_attribute("decision", evaluation.decision.to_string())
            .with_attribute("reason_code", evaluation.reason_code.to_string()),
    );
    state
        .observability
        .increment_counter("runtime.tools.execute.accepted", &request_id);

    Ok(ok_data(response_payload))
}

async fn runtime_skill_tool_specs_list(
    State(state): State<AppState>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let _ = session_bundle_from_headers(&state, &headers).await?;

    let mut by_key: HashMap<String, serde_json::Value> = HashMap::new();
    for spec in builtin_tool_specs() {
        let key = registry_item_key(&spec, "tool_id");
        by_key.insert(key, spec);
    }
    {
        let stored = state.runtime_skill_registry.tool_specs.lock().await;
        for (key, spec) in stored.iter() {
            by_key.insert(key.clone(), spec.clone());
        }
    }

    let mut payload = by_key.into_values().collect::<Vec<_>>();
    payload.sort_by_key(|item| registry_sort_key(item, "tool_id"));
    Ok(ok_data(payload))
}

async fn runtime_skill_tool_spec_store(
    State(state): State<AppState>,
    headers: HeaderMap,
    Json(payload): Json<RuntimeToolSpecUpsertRequestPayload>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let state_value = normalize_registry_state(payload.state, "state")?;
    let tool_spec = payload
        .tool_spec
        .as_object()
        .ok_or_else(|| validation_error("tool_spec", "The tool_spec field must be an array."))?;
    let (tool_id, version, tool_pack) = validate_tool_spec_schema(tool_spec)?;

    let now = timestamp(Utc::now());
    let key = registry_key(&tool_id, version);
    let existing_created_at = {
        let store = state.runtime_skill_registry.tool_specs.lock().await;
        store
            .get(&key)
            .and_then(|entry| entry.get("created_at"))
            .cloned()
            .unwrap_or_else(|| serde_json::json!(now.clone()))
    };

    let record = serde_json::json!({
        "tool_id": tool_id.clone(),
        "version": version,
        "tool_pack": tool_pack,
        "state": state_value.clone(),
        "tool_spec": payload.tool_spec,
        "created_at": existing_created_at,
        "updated_at": now,
    });

    state
        .runtime_skill_registry
        .tool_specs
        .lock()
        .await
        .insert(key, record.clone());

    state.observability.audit(
        AuditEvent::new("runtime.skills.tool_spec.upserted", request_id.clone())
            .with_user_id(bundle.user.id.clone())
            .with_session_id(bundle.session.session_id.clone())
            .with_org_id(bundle.session.active_org_id.clone())
            .with_device_id(bundle.session.device_id.clone())
            .with_attribute("tool_id", tool_id)
            .with_attribute("version", version.to_string())
            .with_attribute("state", state_value),
    );
    state
        .observability
        .increment_counter("runtime.skills.tool_spec.upserted", &request_id);

    Ok((
        StatusCode::CREATED,
        Json(serde_json::json!({ "data": record })),
    ))
}

async fn runtime_skill_specs_list(
    State(state): State<AppState>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let _ = session_bundle_from_headers(&state, &headers).await?;

    let mut by_key: HashMap<String, serde_json::Value> = HashMap::new();
    for spec in builtin_skill_specs() {
        let key = registry_item_key(&spec, "skill_id");
        by_key.insert(key, spec);
    }
    {
        let stored = state.runtime_skill_registry.skill_specs.lock().await;
        for (key, spec) in stored.iter() {
            by_key.insert(key.clone(), spec.clone());
        }
    }

    let mut payload = by_key.into_values().collect::<Vec<_>>();
    payload.sort_by_key(|item| registry_sort_key(item, "skill_id"));
    Ok(ok_data(payload))
}

async fn runtime_skill_spec_store(
    State(state): State<AppState>,
    headers: HeaderMap,
    Json(payload): Json<RuntimeSkillSpecUpsertRequestPayload>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let state_value = normalize_registry_state(payload.state, "state")?;
    let skill_spec = payload
        .skill_spec
        .as_object()
        .ok_or_else(|| validation_error("skill_spec", "The skill_spec field must be an array."))?;
    let (skill_id, version) = validate_skill_spec_schema(skill_spec)?;

    let now = timestamp(Utc::now());
    let key = registry_key(&skill_id, version);
    let existing_created_at = {
        let store = state.runtime_skill_registry.skill_specs.lock().await;
        store
            .get(&key)
            .and_then(|entry| entry.get("created_at"))
            .cloned()
            .unwrap_or_else(|| serde_json::json!(now.clone()))
    };

    let record = serde_json::json!({
        "skill_id": skill_id.clone(),
        "version": version,
        "state": state_value.clone(),
        "skill_spec": payload.skill_spec,
        "created_at": existing_created_at,
        "updated_at": now,
    });

    state
        .runtime_skill_registry
        .skill_specs
        .lock()
        .await
        .insert(key, record.clone());

    state.observability.audit(
        AuditEvent::new("runtime.skills.skill_spec.upserted", request_id.clone())
            .with_user_id(bundle.user.id.clone())
            .with_session_id(bundle.session.session_id.clone())
            .with_org_id(bundle.session.active_org_id.clone())
            .with_device_id(bundle.session.device_id.clone())
            .with_attribute("skill_id", skill_id)
            .with_attribute("version", version.to_string())
            .with_attribute("state", state_value),
    );
    state
        .observability
        .increment_counter("runtime.skills.skill_spec.upserted", &request_id);

    Ok((
        StatusCode::CREATED,
        Json(serde_json::json!({ "data": record })),
    ))
}

async fn runtime_skill_spec_publish(
    State(state): State<AppState>,
    Path((skill_id, version)): Path<(String, String)>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let normalized_skill_id = skill_id.trim().to_string();
    if normalized_skill_id.is_empty() {
        return Err(validation_error(
            "skill_id",
            "The skill_id route parameter is required.",
        ));
    }
    let normalized_version = version.trim().parse::<u64>().map_err(|_| {
        validation_error("version", "The version route parameter must be an integer.")
    })?;
    if normalized_version < 1 {
        return Err(validation_error(
            "version",
            "The version route parameter must be at least 1.",
        ));
    }

    let key = registry_key(&normalized_skill_id, normalized_version);
    let mut skill_spec_row = {
        let mut skill_specs = state.runtime_skill_registry.skill_specs.lock().await;
        if !skill_specs.contains_key(&key) {
            if let Some(builtin) = builtin_skill_spec(&normalized_skill_id, normalized_version) {
                skill_specs.insert(key.clone(), builtin);
            }
        }
        let row = skill_specs
            .get(&key)
            .cloned()
            .ok_or_else(|| not_found_error("Not found."))?;
        if let Some(existing) = skill_specs.get_mut(&key) {
            existing["state"] = serde_json::json!("published");
            existing["updated_at"] = serde_json::json!(timestamp(Utc::now()));
        }
        row
    };

    let skill_spec_payload = skill_spec_row
        .get("skill_spec")
        .cloned()
        .unwrap_or_else(|| serde_json::Value::Object(serde_json::Map::new()));
    let bundle_hash = runtime_tools_replay_hash_hex(&skill_spec_payload);
    let now = timestamp(Utc::now());
    let release = serde_json::json!({
        "release_id": format!("skillrel_{}", &bundle_hash[..12]),
        "skill_id": normalized_skill_id.clone(),
        "version": normalized_version,
        "bundle_hash": bundle_hash,
        "published_at": now,
        "bundle": {
            "bundle_format": "agent_skills.v1",
            "skill_spec": skill_spec_payload,
        }
    });

    state
        .runtime_skill_registry
        .releases
        .lock()
        .await
        .insert(key, release.clone());

    skill_spec_row["state"] = serde_json::json!("published");

    state.observability.audit(
        AuditEvent::new("runtime.skills.skill_spec.published", request_id.clone())
            .with_user_id(bundle.user.id.clone())
            .with_session_id(bundle.session.session_id.clone())
            .with_org_id(bundle.session.active_org_id.clone())
            .with_device_id(bundle.session.device_id.clone())
            .with_attribute("skill_id", normalized_skill_id)
            .with_attribute("version", normalized_version.to_string())
            .with_attribute(
                "release_id",
                release["release_id"]
                    .as_str()
                    .unwrap_or_default()
                    .to_string(),
            ),
    );
    state
        .observability
        .increment_counter("runtime.skills.skill_spec.published", &request_id);

    Ok((
        StatusCode::CREATED,
        Json(serde_json::json!({ "data": release })),
    ))
}

async fn runtime_skill_release_show(
    State(state): State<AppState>,
    Path((skill_id, version)): Path<(String, String)>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let _ = session_bundle_from_headers(&state, &headers).await?;
    let normalized_skill_id = skill_id.trim().to_string();
    if normalized_skill_id.is_empty() {
        return Err(validation_error(
            "skill_id",
            "The skill_id route parameter is required.",
        ));
    }
    let normalized_version = version.trim().parse::<u64>().map_err(|_| {
        validation_error("version", "The version route parameter must be an integer.")
    })?;
    if normalized_version < 1 {
        return Err(validation_error(
            "version",
            "The version route parameter must be at least 1.",
        ));
    }

    let key = registry_key(&normalized_skill_id, normalized_version);
    let release = state
        .runtime_skill_registry
        .releases
        .lock()
        .await
        .get(&key)
        .cloned()
        .ok_or_else(|| not_found_error("Not found."))?;
    Ok(ok_data(release))
}

async fn list_runtime_threads(
    State(state): State<AppState>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let access_token =
        bearer_token(&headers).ok_or_else(|| unauthorized_error("Unauthenticated."))?;
    let session = state
        .auth
        .session_from_access_token(&access_token)
        .await
        .map_err(map_auth_error)?;

    let threads = state
        .codex_thread_store
        .list_threads_for_user(&session.user.id, Some(&session.session.active_org_id))
        .await
        .map_err(map_thread_store_error)?;

    Ok(ok_data(serde_json::json!({
        "threads": threads,
    })))
}

async fn list_runtime_thread_messages(
    State(state): State<AppState>,
    Path(thread_id): Path<String>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let access_token =
        bearer_token(&headers).ok_or_else(|| unauthorized_error("Unauthenticated."))?;
    let session = state
        .auth
        .session_from_access_token(&access_token)
        .await
        .map_err(map_auth_error)?;

    let normalized_thread_id = thread_id.trim().to_string();
    if normalized_thread_id.is_empty() {
        return Err(validation_error("thread_id", "Thread id is required."));
    }

    let messages = state
        .codex_thread_store
        .list_thread_messages_for_user(&session.user.id, &normalized_thread_id)
        .await
        .map_err(map_thread_store_error)?;

    Ok(ok_data(serde_json::json!({
        "thread_id": normalized_thread_id,
        "messages": messages,
    })))
}

async fn send_thread_message(
    State(state): State<AppState>,
    Path(thread_id): Path<String>,
    headers: HeaderMap,
    Json(payload): Json<SendThreadMessageRequest>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let access_token =
        bearer_token(&headers).ok_or_else(|| unauthorized_error("Unauthenticated."))?;
    let session = state
        .auth
        .session_from_access_token(&access_token)
        .await
        .map_err(map_auth_error)?;

    let normalized_thread_id = thread_id.trim().to_string();
    if normalized_thread_id.is_empty() {
        return Err(validation_error("thread_id", "Thread id is required."));
    }

    let normalized_text = payload.text.trim().to_string();
    if normalized_text.is_empty() {
        return Err(validation_error("text", "Message text is required."));
    }

    if normalized_text.chars().count() > 20_000 {
        return Err(validation_error(
            "text",
            "Message text exceeds 20000 characters.",
        ));
    }

    let appended = state
        .codex_thread_store
        .append_user_message(
            &session.user.id,
            &session.session.active_org_id,
            &normalized_thread_id,
            normalized_text,
        )
        .await
        .map_err(map_thread_store_error)?;
    let accepted_at = appended
        .message
        .created_at
        .to_rfc3339_opts(SecondsFormat::Millis, true);

    state.observability.audit(
        AuditEvent::new("runtime.thread.message.accepted", request_id.clone())
            .with_user_id(session.user.id.clone())
            .with_session_id(session.session.session_id.clone())
            .with_org_id(session.session.active_org_id.clone())
            .with_device_id(session.session.device_id.clone())
            .with_attribute("thread_id", normalized_thread_id.clone())
            .with_attribute("message_id", appended.message.message_id.clone()),
    );
    state
        .observability
        .increment_counter("runtime.thread.message.accepted", &request_id);

    Ok(ok_data(serde_json::json!({
        "accepted": true,
        "thread": appended.thread,
        "message": {
            "id": appended.message.message_id,
            "thread_id": appended.message.thread_id,
            "role": appended.message.role,
            "text": appended.message.text,
            "accepted_at": accepted_at,
        }
    })))
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
struct RuntimeWorkerRegisterRequestPayload {
    worker_id: Option<String>,
    workspace_ref: Option<String>,
    codex_home_ref: Option<String>,
    adapter: Option<String>,
    metadata: Option<serde_json::Value>,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
struct RuntimeWorkerHeartbeatRequestPayload {
    metadata_patch: Option<serde_json::Value>,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
struct RuntimeWorkerTransitionRequestPayload {
    status: String,
    reason: Option<String>,
}

fn runtime_internal_client(
    state: &AppState,
) -> Result<RuntimeInternalClient, (StatusCode, Json<ApiErrorResponse>)> {
    RuntimeInternalClient::from_base_url(
        state.config.runtime_elixir_base_url.as_deref(),
        COMPUTE_DASHBOARD_TIMEOUT_MS,
    )
    .map_err(|error| {
        tracing::warn!(error = %error, "runtime client unavailable");
        error_response_with_status(
            StatusCode::SERVICE_UNAVAILABLE,
            ApiErrorCode::ServiceUnavailable,
            "Runtime is not configured.",
        )
    })
}

fn runtime_client_service_error(
    action: &str,
    error: RuntimeClientError,
) -> (StatusCode, Json<ApiErrorResponse>) {
    error_response_with_status(
        StatusCode::SERVICE_UNAVAILABLE,
        ApiErrorCode::ServiceUnavailable,
        format!("Failed to {action}: {error}"),
    )
}

async fn runtime_workers_index(
    State(state): State<AppState>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let client = runtime_internal_client(&state)?;
    let owner_user_id = runtime_tools_principal_user_id(&bundle.user.id);
    let response = client
        .list_workers_json(owner_user_id)
        .await
        .map_err(|error| runtime_client_service_error("fetch runtime workers", error))?;
    let workers = response
        .get("workers")
        .cloned()
        .filter(|value| value.is_array())
        .unwrap_or_else(|| serde_json::Value::Array(Vec::new()));
    Ok(ok_data(workers))
}

async fn runtime_workers_create(
    State(state): State<AppState>,
    headers: HeaderMap,
    Json(payload): Json<RuntimeWorkerRegisterRequestPayload>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let client = runtime_internal_client(&state)?;

    let worker_id = normalize_optional_bounded_string(payload.worker_id, "worker_id", 160)?;
    let workspace_ref =
        normalize_optional_bounded_string(payload.workspace_ref, "workspace_ref", 255)?;
    let codex_home_ref =
        normalize_optional_bounded_string(payload.codex_home_ref, "codex_home_ref", 255)?;
    let adapter = normalize_optional_bounded_string(payload.adapter, "adapter", 120)?;
    let metadata = validate_optional_json_object_or_array(payload.metadata, "metadata")?
        .unwrap_or_else(|| serde_json::json!({}));
    let owner_user_id = runtime_tools_principal_user_id(&bundle.user.id);

    let request = RuntimeWorkerRegisterRequest {
        worker_id,
        owner_user_id,
        workspace_ref,
        codex_home_ref,
        adapter,
        metadata,
    };

    let response = client
        .register_worker(&request)
        .await
        .map_err(|error| runtime_client_service_error("register runtime worker", error))?;
    let snapshot = response
        .get("worker")
        .cloned()
        .unwrap_or_else(|| serde_json::Value::Null);
    Ok(ok_data(snapshot))
}

async fn runtime_worker_show(
    State(state): State<AppState>,
    headers: HeaderMap,
    Path(worker_id): Path<String>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let client = runtime_internal_client(&state)?;

    let worker_id = normalize_optional_bounded_string(Some(worker_id), "worker_id", 160)?
        .unwrap_or_else(|| "worker".to_string());
    let owner_user_id = runtime_tools_principal_user_id(&bundle.user.id);
    let response = client
        .get_worker_json(&worker_id, owner_user_id)
        .await
        .map_err(|error| runtime_client_service_error("fetch runtime worker", error))?;
    let snapshot = response
        .get("worker")
        .cloned()
        .unwrap_or_else(|| serde_json::Value::Null);
    Ok(ok_data(snapshot))
}

async fn runtime_worker_heartbeat(
    State(state): State<AppState>,
    headers: HeaderMap,
    Path(worker_id): Path<String>,
    Json(payload): Json<RuntimeWorkerHeartbeatRequestPayload>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let client = runtime_internal_client(&state)?;

    let worker_id = normalize_optional_bounded_string(Some(worker_id), "worker_id", 160)?
        .unwrap_or_else(|| "worker".to_string());
    let owner_user_id = runtime_tools_principal_user_id(&bundle.user.id);
    let metadata_patch =
        validate_optional_json_object_or_array(payload.metadata_patch, "metadataPatch")?
            .unwrap_or_else(|| serde_json::json!({}));

    let request = RuntimeWorkerHeartbeatRequest {
        owner_user_id,
        metadata_patch,
    };
    let response = client
        .heartbeat_worker(&worker_id, &request)
        .await
        .map_err(|error| runtime_client_service_error("heartbeat runtime worker", error))?;
    let snapshot = response
        .get("worker")
        .cloned()
        .unwrap_or_else(|| serde_json::Value::Null);
    Ok(ok_data(snapshot))
}

async fn runtime_worker_transition(
    State(state): State<AppState>,
    headers: HeaderMap,
    Path(worker_id): Path<String>,
    Json(payload): Json<RuntimeWorkerTransitionRequestPayload>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let client = runtime_internal_client(&state)?;

    let normalized_status = payload.status.trim().to_lowercase();
    if !matches!(
        normalized_status.as_str(),
        "starting" | "running" | "stopping" | "stopped" | "failed"
    ) {
        return Err(validation_error(
            "status",
            "The selected status is invalid.",
        ));
    }
    let worker_id = normalize_optional_bounded_string(Some(worker_id), "worker_id", 160)?
        .unwrap_or_else(|| "worker".to_string());
    let owner_user_id = runtime_tools_principal_user_id(&bundle.user.id);
    let request = RuntimeWorkerTransitionRequest {
        owner_user_id,
        status: normalized_status,
        reason: payload.reason,
    };
    let response = client
        .transition_worker(&worker_id, &request)
        .await
        .map_err(|error| runtime_client_service_error("transition runtime worker", error))?;
    let snapshot = response
        .get("worker")
        .cloned()
        .unwrap_or_else(|| serde_json::Value::Null);
    Ok(ok_data(snapshot))
}

async fn runtime_codex_workers_index(
    State(state): State<AppState>,
    headers: HeaderMap,
    Query(query): Query<RuntimeCodexWorkersListQuery>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let status_filter = query
        .status
        .and_then(non_empty)
        .map(|value| value.to_lowercase());
    if status_filter
        .as_deref()
        .map(|value| {
            !matches!(
                value,
                "starting" | "running" | "stopping" | "stopped" | "failed"
            )
        })
        .unwrap_or(false)
    {
        return Err(validation_error(
            "status",
            "The selected status is invalid.",
        ));
    }
    let workspace_ref =
        normalize_optional_bounded_string(query.workspace_ref, "workspace_ref", 255)?;
    let limit = query.limit.unwrap_or(50).clamp(1, 200);

    let now = Utc::now();
    let workers = state.runtime_workers.workers.lock().await;
    let mut payload = workers
        .values()
        .filter(|worker| worker.owner_user_id == bundle.user.id)
        .filter(|worker| {
            status_filter
                .as_deref()
                .map(|status| worker.status == status)
                .unwrap_or(true)
        })
        .filter(|worker| {
            workspace_ref
                .as_deref()
                .map(|workspace| worker.workspace_ref.as_deref() == Some(workspace))
                .unwrap_or(true)
        })
        .map(|worker| runtime_worker_snapshot_payload(worker, now))
        .collect::<Vec<_>>();
    payload.sort_by(|left, right| {
        let left_updated = left
            .get("updated_at")
            .and_then(serde_json::Value::as_str)
            .unwrap_or_default();
        let right_updated = right
            .get("updated_at")
            .and_then(serde_json::Value::as_str)
            .unwrap_or_default();
        right_updated.cmp(left_updated)
    });
    payload.truncate(limit);

    Ok(ok_data(payload))
}

async fn runtime_codex_workers_create(
    State(state): State<AppState>,
    headers: HeaderMap,
    Json(payload): Json<RuntimeCodexWorkerCreateRequestPayload>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let worker_id = normalize_optional_bounded_string(payload.worker_id, "worker_id", 160)?
        .unwrap_or_else(|| format!("codexw_{}", uuid::Uuid::new_v4().simple()));
    let workspace_ref =
        normalize_optional_bounded_string(payload.workspace_ref, "workspace_ref", 255)?;
    let codex_home_ref =
        normalize_optional_bounded_string(payload.codex_home_ref, "codex_home_ref", 255)?;
    let adapter = normalize_optional_bounded_string(payload.adapter, "adapter", 120)?
        .unwrap_or_else(|| "in_memory".to_string());
    let metadata = validate_optional_json_object_or_array(payload.metadata, "metadata")?;

    let now = Utc::now();
    let mut workers = state.runtime_workers.workers.lock().await;
    let (status, latest_seq, idempotent_replay) =
        if let Some(existing) = workers.get_mut(&worker_id) {
            if existing.owner_user_id != bundle.user.id {
                return Err(forbidden_error(
                    "worker does not belong to authenticated principal",
                ));
            }
            let replay = existing.status == "running";
            existing.status = "running".to_string();
            existing.workspace_ref = workspace_ref.clone().or(existing.workspace_ref.clone());
            existing.codex_home_ref = codex_home_ref.clone().or(existing.codex_home_ref.clone());
            existing.adapter = adapter.clone();
            if metadata.is_some() {
                existing.metadata = metadata.clone();
            }
            existing.stopped_at = None;
            existing.last_heartbeat_at = Some(now);
            existing.updated_at = now;
            (existing.status.clone(), existing.latest_seq, replay)
        } else {
            workers.insert(
                worker_id.clone(),
                RuntimeWorkerRecord {
                    worker_id: worker_id.clone(),
                    owner_user_id: bundle.user.id.clone(),
                    status: "running".to_string(),
                    latest_seq: 0,
                    workspace_ref,
                    codex_home_ref,
                    adapter,
                    metadata,
                    started_at: Some(now),
                    stopped_at: None,
                    last_heartbeat_at: Some(now),
                    heartbeat_stale_after_ms: 120_000,
                    updated_at: now,
                },
            );
            ("running".to_string(), 0, false)
        };

    Ok((
        StatusCode::ACCEPTED,
        Json(serde_json::json!({
            "data": {
                "workerId": worker_id,
                "status": status,
                "latestSeq": latest_seq,
                "idempotentReplay": idempotent_replay,
            }
        })),
    ))
}

async fn runtime_codex_worker_show(
    State(state): State<AppState>,
    Path(worker_id): Path<String>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let normalized_worker_id = worker_id.trim().to_string();
    if normalized_worker_id.is_empty() {
        return Err(validation_error("worker_id", "Worker id is required."));
    }

    let now = Utc::now();
    let workers = state.runtime_workers.workers.lock().await;
    let worker = workers
        .get(&normalized_worker_id)
        .ok_or_else(|| not_found_error("Not found."))?;
    if worker.owner_user_id != bundle.user.id {
        return Err(forbidden_error(
            "worker does not belong to authenticated principal",
        ));
    }

    Ok(ok_data(runtime_worker_snapshot_payload(worker, now)))
}

async fn runtime_codex_worker_stream(
    State(state): State<AppState>,
    Path(worker_id): Path<String>,
    headers: HeaderMap,
    Query(query): Query<RuntimeCodexWorkerStreamQuery>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let normalized_worker_id = worker_id.trim().to_string();
    if normalized_worker_id.is_empty() {
        return Err(validation_error("worker_id", "Worker id is required."));
    }
    if query
        .tail_ms
        .map(|tail_ms| !(1..=120_000).contains(&tail_ms))
        .unwrap_or(false)
    {
        return Err(validation_error(
            "tail_ms",
            "The tail_ms field must be between 1 and 120000.",
        ));
    }

    let now = Utc::now();
    let worker = {
        let workers = state.runtime_workers.workers.lock().await;
        let worker = workers
            .get(&normalized_worker_id)
            .cloned()
            .ok_or_else(|| not_found_error("Not found."))?;
        if worker.owner_user_id != bundle.user.id {
            return Err(forbidden_error(
                "worker does not belong to authenticated principal",
            ));
        }
        worker
    };

    let cursor = query.cursor.unwrap_or(0);
    let events = {
        let event_log = state.runtime_workers.events.lock().await;
        event_log
            .get(&normalized_worker_id)
            .cloned()
            .unwrap_or_default()
            .into_iter()
            .filter(|event| event.seq > cursor)
            .map(|event| runtime_worker_event_payload(&event))
            .collect::<Vec<_>>()
    };

    Ok(ok_data(serde_json::json!({
        "worker_id": normalized_worker_id,
        "stream_protocol": "khala_ws",
        "cursor": cursor,
        "tail_ms": query.tail_ms.unwrap_or(15_000),
        "delivery": {
            "transport": "khala_ws",
            "topic": org_worker_events_topic(&bundle.session.active_org_id),
            "scope": "runtime.codex_worker_events",
            "syncTokenRoute": ROUTE_SYNC_TOKEN,
        },
        "snapshot": runtime_worker_snapshot_payload(&worker, now),
        "events": events,
    })))
}

async fn runtime_codex_worker_events(
    State(state): State<AppState>,
    Path(worker_id): Path<String>,
    headers: HeaderMap,
    Json(payload): Json<RuntimeCodexWorkerEventEnvelope>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let normalized_worker_id = worker_id.trim().to_string();
    if normalized_worker_id.is_empty() {
        return Err(validation_error("worker_id", "Worker id is required."));
    }

    let event_type = payload.event.event_type.trim().to_string();
    if event_type.is_empty() {
        return Err(validation_error(
            "event.event_type",
            "The event.event_type field is required.",
        ));
    }
    if event_type.chars().count() > 160 || !event_type.starts_with("worker.") {
        return Err(validation_error(
            "event.event_type",
            "The event.event_type field format is invalid.",
        ));
    }
    let event_payload = payload
        .event
        .payload
        .unwrap_or_else(|| serde_json::Value::Object(serde_json::Map::new()));
    if !event_payload.is_object() {
        return Err(validation_error(
            "event.payload",
            "The event.payload field must be an object.",
        ));
    }
    validate_worker_handshake_payload(&event_type, &event_payload)?;

    ensure_runtime_worker_runnable(&state, &bundle.user.id, &normalized_worker_id, true).await?;
    let occurred_at = parse_event_occurred_at(&event_payload).unwrap_or_else(Utc::now);
    let seq = append_runtime_worker_event(
        &state,
        &normalized_worker_id,
        &event_type,
        event_payload.clone(),
        occurred_at,
    )
    .await?;

    Ok((
        StatusCode::ACCEPTED,
        Json(serde_json::json!({
            "data": {
                "worker_id": normalized_worker_id,
                "seq": seq,
                "event_type": event_type,
                "payload": event_payload,
                "occurred_at": timestamp(occurred_at),
            }
        })),
    ))
}

async fn runtime_codex_worker_stop(
    State(state): State<AppState>,
    Path(worker_id): Path<String>,
    headers: HeaderMap,
    Json(payload): Json<RuntimeCodexWorkerStopRequestPayload>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let bundle = session_bundle_from_headers(&state, &headers).await?;
    let normalized_worker_id = worker_id.trim().to_string();
    if normalized_worker_id.is_empty() {
        return Err(validation_error("worker_id", "Worker id is required."));
    }
    let reason = normalize_optional_bounded_string(payload.reason, "reason", 255)?;

    let now = Utc::now();
    let (idempotent_replay, seq) = {
        let mut workers = state.runtime_workers.workers.lock().await;
        let worker = workers
            .get_mut(&normalized_worker_id)
            .ok_or_else(|| not_found_error("Not found."))?;
        if worker.owner_user_id != bundle.user.id {
            return Err(forbidden_error(
                "worker does not belong to authenticated principal",
            ));
        }
        if worker.status == "stopped" {
            (true, worker.latest_seq)
        } else {
            worker.latest_seq = worker.latest_seq.saturating_add(1);
            worker.status = "stopped".to_string();
            worker.stopped_at = Some(now);
            worker.updated_at = now;
            let seq = worker.latest_seq;
            let payload = serde_json::json!({
                "reason": reason.clone().unwrap_or_else(|| "requested".to_string())
            });
            let mut events = state.runtime_workers.events.lock().await;
            let entry = events.entry(normalized_worker_id.clone()).or_default();
            entry.push(RuntimeWorkerEventRecord {
                seq,
                event_type: "worker.stopped".to_string(),
                payload,
                occurred_at: now,
            });
            (false, seq)
        }
    };

    Ok((
        StatusCode::ACCEPTED,
        Json(serde_json::json!({
            "data": {
                "worker_id": normalized_worker_id,
                "status": "stopped",
                "seq": seq,
                "idempotent_replay": idempotent_replay,
                "idempotentReplay": idempotent_replay,
            }
        })),
    ))
}

async fn runtime_codex_worker_request(
    State(state): State<AppState>,
    Path(worker_id): Path<String>,
    headers: HeaderMap,
    Json(payload): Json<RuntimeCodexWorkerControlRequestEnvelope>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let access_token =
        bearer_token(&headers).ok_or_else(|| unauthorized_error("Unauthenticated."))?;
    let session = state
        .auth
        .session_from_access_token(&access_token)
        .await
        .map_err(map_auth_error)?;

    let normalized_worker_id = worker_id.trim().to_string();
    if normalized_worker_id.is_empty() {
        return Err(validation_error("worker_id", "Worker id is required."));
    }

    let control_request = payload.request;
    let normalized_control_request_id = control_request.request_id.trim().to_string();
    if normalized_control_request_id.is_empty() {
        return Err(validation_error(
            "request.request_id",
            "Request id is required.",
        ));
    }

    let normalized_method = control_request.method.trim().to_lowercase();
    if !is_codex_control_method_allowed(&normalized_method) {
        return Err(validation_error(
            "request.method",
            "Control method is not allowlisted.",
        ));
    }

    let replay_key = format!(
        "{}:{}:{}",
        session.user.id, normalized_worker_id, normalized_control_request_id
    );
    if let Some(replayed) = state
        .codex_control_receipts
        .entries
        .lock()
        .await
        .get(&replay_key)
        .cloned()
    {
        let replayed = mark_codex_control_replay(replayed);
        state.observability.audit(
            AuditEvent::new("runtime.codex.control.request.accepted", request_id.clone())
                .with_user_id(session.user.id.clone())
                .with_session_id(session.session.session_id.clone())
                .with_org_id(session.session.active_org_id.clone())
                .with_device_id(session.session.device_id.clone())
                .with_attribute("worker_id", normalized_worker_id.clone())
                .with_attribute("control_request_id", normalized_control_request_id.clone())
                .with_attribute("method", normalized_method.clone())
                .with_attribute("idempotent_replay", "true".to_string()),
        );
        state
            .observability
            .increment_counter("runtime.codex.control.request.accepted", &request_id);
        return Ok(ok_data(replayed));
    }
    ensure_runtime_worker_runnable(&state, &session.user.id, &normalized_worker_id, true).await?;

    let response =
        execute_codex_control_request(&state, &session, &normalized_method, &control_request)
            .await?;

    let mut envelope = serde_json::json!({
        "worker_id": normalized_worker_id.clone(),
        "request_id": normalized_control_request_id.clone(),
        "ok": true,
        "method": normalized_method.clone(),
        "idempotent_replay": false,
        "response": response.clone(),
    });

    if let Some(source) = control_request
        .source
        .as_deref()
        .and_then(|value| non_empty(value.to_string()))
    {
        envelope["source"] = serde_json::json!(source);
    }
    if let Some(request_version) = control_request
        .request_version
        .as_deref()
        .and_then(|value| non_empty(value.to_string()))
    {
        envelope["request_version"] = serde_json::json!(request_version);
    }
    if let Some(session_id) = control_request
        .session_id
        .as_deref()
        .and_then(|value| non_empty(value.to_string()))
    {
        envelope["session_id"] = serde_json::json!(session_id);
    }

    state
        .codex_control_receipts
        .entries
        .lock()
        .await
        .insert(replay_key, envelope.clone());

    let event_payload = serde_json::json!({
        "request_id": normalized_control_request_id.clone(),
        "method": normalized_method.clone(),
        "response": response,
    });
    let _ = append_runtime_worker_event(
        &state,
        &normalized_worker_id,
        "worker.response",
        event_payload,
        Utc::now(),
    )
    .await?;

    state.observability.audit(
        AuditEvent::new("runtime.codex.control.request.accepted", request_id.clone())
            .with_user_id(session.user.id.clone())
            .with_session_id(session.session.session_id.clone())
            .with_org_id(session.session.active_org_id.clone())
            .with_device_id(session.session.device_id.clone())
            .with_attribute("worker_id", normalized_worker_id)
            .with_attribute("control_request_id", normalized_control_request_id)
            .with_attribute("method", normalized_method)
            .with_attribute("idempotent_replay", "false".to_string()),
    );
    state
        .observability
        .increment_counter("runtime.codex.control.request.accepted", &request_id);

    Ok(ok_data(envelope))
}

async fn execute_codex_control_request(
    state: &AppState,
    session: &SessionBundle,
    method: &str,
    control_request: &RuntimeCodexWorkerControlRequest,
) -> Result<serde_json::Value, (StatusCode, Json<ApiErrorResponse>)> {
    match method {
        "thread/start" => {
            let thread_id = codex_request_thread_id(control_request)
                .unwrap_or_else(|| format!("thread_{}", uuid::Uuid::new_v4().simple()));
            let mut payload = serde_json::json!({
                "thread_id": thread_id,
            });
            if let Some(text) = codex_request_text(control_request) {
                validate_codex_turn_text(&text)?;
                let appended = state
                    .codex_thread_store
                    .append_user_message(
                        &session.user.id,
                        &session.session.active_org_id,
                        &thread_id,
                        text,
                    )
                    .await
                    .map_err(map_thread_store_error)?;
                payload["message"] = serde_json::json!({
                    "id": appended.message.message_id,
                    "thread_id": appended.message.thread_id,
                    "role": appended.message.role,
                    "text": appended.message.text,
                });
            }
            Ok(payload)
        }
        "thread/resume" => {
            let thread_id = codex_request_thread_id(control_request).ok_or_else(|| {
                validation_error("request.params.thread_id", "Thread id is required.")
            })?;
            let _ = state
                .codex_thread_store
                .list_thread_messages_for_user(&session.user.id, &thread_id)
                .await
                .map_err(map_thread_store_error)?;
            Ok(serde_json::json!({
                "thread_id": thread_id,
            }))
        }
        "thread/list" => {
            let threads = state
                .codex_thread_store
                .list_threads_for_user(&session.user.id, Some(&session.session.active_org_id))
                .await
                .map_err(map_thread_store_error)?;
            Ok(serde_json::json!({
                "threads": threads,
            }))
        }
        "thread/read" => {
            let thread_id = codex_request_thread_id(control_request).ok_or_else(|| {
                validation_error("request.params.thread_id", "Thread id is required.")
            })?;
            let messages = state
                .codex_thread_store
                .list_thread_messages_for_user(&session.user.id, &thread_id)
                .await
                .map_err(map_thread_store_error)?;
            Ok(serde_json::json!({
                "thread_id": thread_id,
                "messages": messages,
            }))
        }
        "turn/start" => {
            let thread_id = codex_request_thread_id(control_request).ok_or_else(|| {
                validation_error("request.params.thread_id", "Thread id is required.")
            })?;
            let text = codex_request_text(control_request).ok_or_else(|| {
                validation_error("request.params.text", "Message text is required.")
            })?;
            validate_codex_turn_text(&text)?;

            let appended = state
                .codex_thread_store
                .append_user_message(
                    &session.user.id,
                    &session.session.active_org_id,
                    &thread_id,
                    text,
                )
                .await
                .map_err(map_thread_store_error)?;

            Ok(serde_json::json!({
                "thread_id": thread_id,
                "turn": {
                    "id": format!("turn_{}", uuid::Uuid::new_v4().simple()),
                },
                "message": {
                    "id": appended.message.message_id,
                    "thread_id": appended.message.thread_id,
                    "role": appended.message.role,
                    "text": appended.message.text,
                },
            }))
        }
        "turn/interrupt" => Ok(serde_json::json!({
            "thread_id": codex_request_thread_id(control_request),
            "turn_id": normalized_json_string(control_request.params.get("turn_id"))
                .or_else(|| normalized_json_string(control_request.params.get("turnId"))),
            "status": "interrupted",
        })),
        _ => Err(validation_error(
            "request.method",
            "Control method is not allowlisted.",
        )),
    }
}

fn is_codex_control_method_allowed(method: &str) -> bool {
    CODEX_CONTROL_METHOD_ALLOWLIST
        .iter()
        .any(|allowed| *allowed == method)
}

fn mark_codex_control_replay(mut payload: serde_json::Value) -> serde_json::Value {
    if let Some(object) = payload.as_object_mut() {
        object.insert("idempotent_replay".to_string(), serde_json::json!(true));
    }
    payload
}

fn codex_request_thread_id(request: &RuntimeCodexWorkerControlRequest) -> Option<String> {
    request
        .thread_id
        .as_deref()
        .and_then(|value| non_empty(value.to_string()))
        .or_else(|| normalized_json_string(request.params.get("thread_id")))
        .or_else(|| normalized_json_string(request.params.get("threadId")))
}

fn codex_request_text(request: &RuntimeCodexWorkerControlRequest) -> Option<String> {
    normalized_json_string(request.params.get("text"))
        .or_else(|| normalized_json_string(request.params.get("message")))
        .or_else(|| normalized_json_string(request.params.get("prompt")))
        .or_else(|| {
            request
                .params
                .get("input")
                .and_then(serde_json::Value::as_array)
                .and_then(|parts| {
                    parts.iter().find_map(|part| {
                        let part_type =
                            normalized_json_string(part.get("type")).unwrap_or_default();
                        if part_type == "text" {
                            normalized_json_string(part.get("text"))
                        } else {
                            None
                        }
                    })
                })
        })
}

fn normalized_json_string(value: Option<&serde_json::Value>) -> Option<String> {
    value
        .and_then(serde_json::Value::as_str)
        .and_then(|raw| non_empty(raw.to_string()))
}

fn parse_runtime_internal_user_id(
    value: Option<&serde_json::Value>,
) -> Result<(String, serde_json::Value), (StatusCode, Json<ApiErrorResponse>)> {
    let Some(value) = value else {
        return Err(validation_error(
            "user_id",
            "The user_id field is required.",
        ));
    };

    match value {
        serde_json::Value::String(raw) => {
            let normalized = non_empty(raw.to_string())
                .ok_or_else(|| validation_error("user_id", "The user_id field is required."))?;
            Ok((normalized.clone(), serde_json::Value::String(normalized)))
        }
        serde_json::Value::Number(number) => {
            let Some(user_id) = number.as_u64() else {
                return Err(validation_error(
                    "user_id",
                    "The user_id field must be an integer greater than 0.",
                ));
            };
            if user_id == 0 {
                return Err(validation_error(
                    "user_id",
                    "The user_id field must be an integer greater than 0.",
                ));
            }
            Ok((
                user_id.to_string(),
                serde_json::Value::Number(serde_json::Number::from(user_id)),
            ))
        }
        _ => Err(validation_error(
            "user_id",
            "The user_id field must be a string or integer.",
        )),
    }
}

fn validate_codex_turn_text(text: &str) -> Result<(), (StatusCode, Json<ApiErrorResponse>)> {
    let normalized = text.trim();
    if normalized.is_empty() {
        return Err(validation_error(
            "request.params.text",
            "Message text is required.",
        ));
    }
    if normalized.chars().count() > 20_000 {
        return Err(validation_error(
            "request.params.text",
            "Message text exceeds 20000 characters.",
        ));
    }
    Ok(())
}

async fn refresh_session(
    State(state): State<AppState>,
    headers: HeaderMap,
    Json(payload): Json<RefreshSessionRequest>,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let token = payload
        .refresh_token
        .and_then(non_empty)
        .or_else(|| bearer_token(&headers))
        .ok_or_else(|| unauthorized_error("Invalid refresh token."))?;
    let requested_device_id = payload
        .device_id
        .and_then(non_empty)
        .or_else(|| header_string(&headers, "x-device-id"));

    let rotate = payload.rotate_refresh_token.unwrap_or(true);

    let refreshed = match state
        .auth
        .refresh_session(&token, requested_device_id.as_deref(), rotate)
        .await
    {
        Ok(refreshed) => refreshed,
        Err(error) => {
            emit_auth_failure_event(&state, &request_id, "auth.refresh.failed", &error);
            return Err(map_auth_error(error));
        }
    };

    state.observability.audit(
        AuditEvent::new("auth.refresh.completed", request_id.clone())
            .with_user_id(refreshed.session.user_id.clone())
            .with_session_id(refreshed.session.session_id.clone())
            .with_org_id(refreshed.session.active_org_id.clone())
            .with_device_id(refreshed.session.device_id.clone())
            .with_attribute("rotated_refresh_token", rotate.to_string()),
    );
    state
        .observability
        .increment_counter("auth.refresh.completed", &request_id);

    let response = serde_json::json!({
        "ok": true,
        "status": "active",
        "tokenType": refreshed.token_type,
        "token": refreshed.access_token,
        "refreshToken": refreshed.refresh_token,
        "refreshTokenId": refreshed.refresh_token_id,
        "replacedRefreshTokenId": refreshed.replaced_refresh_token_id,
        "sessionId": refreshed.session.session_id,
        "accessExpiresAt": timestamp(refreshed.session.access_expires_at),
        "refreshExpiresAt": timestamp(refreshed.session.refresh_expires_at),
    });

    Ok((StatusCode::OK, Json(response)))
}

async fn logout_session(
    State(state): State<AppState>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let request_id = request_id(&headers);
    let access_token =
        bearer_token(&headers).ok_or_else(|| unauthorized_error("Unauthenticated."))?;

    let bundle = match state.auth.session_from_access_token(&access_token).await {
        Ok(bundle) => bundle,
        Err(error) => {
            emit_auth_failure_event(&state, &request_id, "auth.logout.failed", &error);
            return Err(map_auth_error(error));
        }
    };

    let revoked = match state
        .auth
        .revoke_session_by_access_token(&access_token)
        .await
    {
        Ok(revoked) => revoked,
        Err(error) => {
            emit_auth_failure_event(&state, &request_id, "auth.logout.failed", &error);
            return Err(map_auth_error(error));
        }
    };

    state.observability.audit(
        AuditEvent::new("auth.logout.completed", request_id.clone())
            .with_user_id(bundle.user.id.clone())
            .with_session_id(revoked.session_id.clone())
            .with_org_id(bundle.session.active_org_id.clone())
            .with_device_id(bundle.session.device_id.clone()),
    );
    state
        .observability
        .increment_counter("auth.logout.completed", &request_id);

    propagate_runtime_revocation(
        &state,
        &request_id,
        vec![revoked.session_id.clone()],
        vec![revoked.device_id.clone()],
        SessionRevocationReason::UserRequested,
    )
    .await?;

    let response = serde_json::json!({
        "ok": true,
        "status": "revoked",
        "sessionId": revoked.session_id,
        "revokedAt": timestamp(revoked.revoked_at),
    });

    Ok((StatusCode::OK, Json(response)))
}

async fn control_status(
    State(state): State<AppState>,
    headers: HeaderMap,
) -> Result<impl IntoResponse, (StatusCode, Json<ApiErrorResponse>)> {
    let access_token =
        bearer_token(&headers).ok_or_else(|| unauthorized_error("Unauthenticated."))?;

    let bundle = state
        .auth
        .session_from_access_token(&access_token)
        .await
        .map_err(map_auth_error)?;
    let route_split_status = state.route_split.status().await;
    let runtime_routing_status = state.runtime_routing.status(&state._domain_store).await;

    let response = serde_json::json!({
        "data": {
            "service": SERVICE_NAME,
            "authProvider": state.auth.provider_name(),
            "activeOrgId": bundle.session.active_org_id,
            "memberships": bundle.memberships,
            "compatibility": {
                "protocolVersion": state.config.compat_control_protocol_version,
                "minClientBuildId": state.config.compat_control_min_client_build_id,
                "maxClientBuildId": state.config.compat_control_max_client_build_id,
                "minSchemaVersion": state.config.compat_control_min_schema_version,
                "maxSchemaVersion": state.config.compat_control_max_schema_version,
            },
            "routeSplit": route_split_status,
            "runtimeRouting": runtime_routing_status,
        }
    });

    Ok((StatusCode::OK, Json(response)))
}

async fn propagate_runtime_revocation(
    state: &AppState,
    request_id: &str,
    session_ids: Vec<String>,
    device_ids: Vec<String>,
    reason: SessionRevocationReason,
) -> Result<(), (StatusCode, Json<ApiErrorResponse>)> {
    if session_ids.is_empty() && device_ids.is_empty() {
        return Ok(());
    }

    let Some(client) = state.runtime_revocation_client.as_ref() else {
        state.observability.audit(
            AuditEvent::new(
                "auth.sessions.revocation.propagation.skipped",
                request_id.to_string(),
            )
            .with_attribute(
                "reason",
                "runtime_revocation_client_not_configured".to_string(),
            )
            .with_attribute("session_count", session_ids.len().to_string())
            .with_attribute("device_count", device_ids.len().to_string()),
        );

        return Ok(());
    };

    client
        .revoke_sessions(session_ids.clone(), device_ids.clone(), reason)
        .await
        .map_err(|message| {
            error_response_with_status(
                StatusCode::SERVICE_UNAVAILABLE,
                ApiErrorCode::ServiceUnavailable,
                format!("Failed to propagate websocket session revocation: {message}"),
            )
        })?;

    state.observability.audit(
        AuditEvent::new(
            "auth.sessions.revocation.propagation.completed",
            request_id.to_string(),
        )
        .with_attribute("reason", reason.as_str().to_string())
        .with_attribute("session_count", session_ids.len().to_string())
        .with_attribute("device_count", device_ids.len().to_string()),
    );

    Ok(())
}

fn map_auth_error(error: AuthError) -> (StatusCode, Json<ApiErrorResponse>) {
    match error {
        AuthError::Validation { field, message } => validation_error(field, &message),
        AuthError::Unauthorized { message } => unauthorized_error(&message),
        AuthError::Forbidden { message } => forbidden_error(&message),
        AuthError::Conflict { message } => {
            error_response_with_status(StatusCode::CONFLICT, ApiErrorCode::Conflict, message)
        }
        AuthError::Provider { message } => error_response_with_status(
            StatusCode::SERVICE_UNAVAILABLE,
            ApiErrorCode::ServiceUnavailable,
            message,
        ),
    }
}

fn auth_error_reason(error: &AuthError) -> (&'static str, Option<&'static str>) {
    match error {
        AuthError::Validation { field, .. } => ("invalid_request", Some(*field)),
        AuthError::Unauthorized { .. } => ("unauthorized", None),
        AuthError::Forbidden { .. } => ("forbidden", None),
        AuthError::Conflict { .. } => ("conflict", None),
        AuthError::Provider { .. } => ("service_unavailable", None),
    }
}

fn emit_auth_failure_event(
    state: &AppState,
    request_id: &str,
    event_name: &str,
    error: &AuthError,
) {
    let (reason, field) = auth_error_reason(error);
    let mut event = AuditEvent::new(event_name, request_id.to_string())
        .with_outcome("failure")
        .with_attribute("reason", reason.to_string());

    if let Some(field) = field {
        event = event.with_attribute("field", field.to_string());
    }

    state.observability.audit(event);
    state
        .observability
        .increment_counter(event_name, request_id);
}

fn map_sync_error(error: SyncTokenError) -> (StatusCode, Json<ApiErrorResponse>) {
    match error {
        SyncTokenError::InvalidScope { message } => error_response_with_status(
            StatusCode::UNPROCESSABLE_ENTITY,
            ApiErrorCode::InvalidScope,
            message,
        ),
        SyncTokenError::InvalidRequest { message } => error_response_with_status(
            StatusCode::UNPROCESSABLE_ENTITY,
            ApiErrorCode::InvalidRequest,
            message,
        ),
        SyncTokenError::Unavailable { message } => error_response_with_status(
            StatusCode::SERVICE_UNAVAILABLE,
            ApiErrorCode::SyncTokenUnavailable,
            message,
        ),
    }
}

fn map_khala_error(error: KhalaTokenError) -> (StatusCode, Json<ApiErrorResponse>) {
    match error {
        KhalaTokenError::InvalidRequest { message } => error_response_with_status(
            StatusCode::UNPROCESSABLE_ENTITY,
            ApiErrorCode::InvalidRequest,
            message,
        ),
        KhalaTokenError::Unavailable { message } => error_response_with_status(
            StatusCode::SERVICE_UNAVAILABLE,
            ApiErrorCode::KhalaTokenUnavailable,
            message,
        ),
    }
}

fn map_thread_store_error(error: ThreadStoreError) -> (StatusCode, Json<ApiErrorResponse>) {
    match error {
        ThreadStoreError::NotFound => not_found_error("Thread not found."),
        ThreadStoreError::Forbidden => forbidden_error("Requested thread is not available."),
        ThreadStoreError::Persistence { message } => error_response_with_status(
            StatusCode::SERVICE_UNAVAILABLE,
            ApiErrorCode::ServiceUnavailable,
            message,
        ),
    }
}

fn map_legacy_stream_adapter_error(
    error: vercel_sse_adapter::AdapterError,
) -> (StatusCode, Json<ApiErrorResponse>) {
    match error {
        vercel_sse_adapter::AdapterError::MissingConversationId => {
            validation_error("conversation_id", "Conversation id is required.")
        }
        vercel_sse_adapter::AdapterError::MissingUserText => validation_error(
            "messages",
            "Legacy stream payload must include user message text.",
        ),
        _ => validation_error("messages", &error.to_string()),
    }
}

fn map_autopilot_stream_thread_error(
    error: ThreadStoreError,
) -> (StatusCode, Json<ApiErrorResponse>) {
    match error {
        ThreadStoreError::NotFound | ThreadStoreError::Forbidden => not_found_error("Not found."),
        ThreadStoreError::Persistence { message } => error_response_with_status(
            StatusCode::SERVICE_UNAVAILABLE,
            ApiErrorCode::ServiceUnavailable,
            message,
        ),
    }
}

fn map_domain_store_error(error: DomainStoreError) -> (StatusCode, Json<ApiErrorResponse>) {
    match error {
        DomainStoreError::NotFound => not_found_error("Requested resource was not found."),
        DomainStoreError::Forbidden => forbidden_error("Forbidden."),
        DomainStoreError::Validation { field, message } => validation_error(field, &message),
        DomainStoreError::Conflict { message } => {
            error_response_with_status(StatusCode::CONFLICT, ApiErrorCode::Conflict, message)
        }
        DomainStoreError::Persistence { message } => error_response_with_status(
            StatusCode::SERVICE_UNAVAILABLE,
            ApiErrorCode::ServiceUnavailable,
            message,
        ),
    }
}

fn session_payload(bundle: SessionBundle) -> serde_json::Value {
    serde_json::json!({
        "data": {
            "session": {
                "sessionId": bundle.session.session_id,
                "userId": bundle.session.user_id,
                "email": bundle.session.email,
                "deviceId": bundle.session.device_id,
                "status": bundle.session.status,
                "tokenName": bundle.session.token_name,
                "issuedAt": timestamp(bundle.session.issued_at),
                "accessExpiresAt": timestamp(bundle.session.access_expires_at),
                "refreshExpiresAt": timestamp(bundle.session.refresh_expires_at),
                "activeOrgId": bundle.session.active_org_id,
                "reauthRequired": bundle.session.reauth_required,
                "lastRefreshedAt": bundle.session.last_refreshed_at.map(timestamp),
                "revokedAt": bundle.session.revoked_at.map(timestamp),
                "revokedReason": bundle.session.revoked_reason,
            },
            "user": {
                "id": bundle.user.id,
                "email": bundle.user.email,
                "name": bundle.user.name,
                "workosId": bundle.user.workos_user_id,
            },
            "memberships": bundle.memberships,
        }
    })
}

fn maintenance_response() -> Response {
    let html = r#"<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>We'll be right back | OpenAgents</title>
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      min-height: 100%;
      width: 100%;
      background: #0a0a0a;
      color: #f5f5f5;
      font-family: 'Berkeley Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace;
    }
    body { position: relative; overflow: hidden; }
    .bg {
      position: fixed;
      inset: 0;
      pointer-events: none;
      background:
        radial-gradient(120% 85% at 50% 0%, rgba(255, 255, 255, 0.07) 0%, rgba(255, 255, 255, 0) 55%),
        radial-gradient(ellipse 100% 100% at 50% 50%, transparent 12%, rgba(0, 0, 0, 0.55) 60%, rgba(0, 0, 0, 0.88) 100%);
    }
    .grid {
      position: fixed;
      inset: 0;
      pointer-events: none;
      background-image: radial-gradient(circle at center, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
      background-size: 48px 48px;
    }
    .container {
      position: fixed;
      inset: 0;
      z-index: 2;
      display: grid;
      place-items: center;
      padding: 2rem;
    }
    .panel {
      width: min(640px, 100%);
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(10, 10, 10, 0.75);
      backdrop-filter: blur(2px);
      border-radius: 12px;
      padding: 2rem;
      box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.04) inset;
    }
    h1 {
      margin: 0;
      font-size: clamp(1.6rem, 2.2vw, 2.25rem);
      letter-spacing: 0.01em;
      line-height: 1.15;
    }
    p {
      margin: 0.9rem 0 0;
      color: rgba(255, 255, 255, 0.8);
      line-height: 1.5;
      font-size: 0.98rem;
    }
    .status {
      margin-top: 1.4rem;
      display: inline-block;
      font-size: 0.8rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      border: 1px solid rgba(255, 255, 255, 0.25);
      padding: 0.45rem 0.65rem;
      border-radius: 8px;
      color: rgba(255, 255, 255, 0.88);
    }
  </style>
</head>
<body>
  <div class="bg" aria-hidden="true"></div>
  <div class="grid" aria-hidden="true"></div>
  <main class="container">
    <section class="panel" role="status" aria-live="polite">
      <h1>We'll be right back.</h1>
      <p>OpenAgents is temporarily unavailable while we complete an infrastructure switch. Please check back shortly.</p>
      <span class="status">Maintenance in progress</span>
    </section>
  </main>
</body>
</html>
"#;

    (
        StatusCode::SERVICE_UNAVAILABLE,
        [
            (CONTENT_TYPE, "text/html; charset=utf-8"),
            (CACHE_CONTROL, MAINTENANCE_CACHE_CONTROL),
        ],
        html,
    )
        .into_response()
}

fn maintenance_path_is_allowed(path: &str, allowed_paths: &[String]) -> bool {
    if path.is_empty() {
        return false;
    }

    allowed_paths.iter().any(|allowed| {
        let candidate = allowed.trim();
        if candidate.is_empty() {
            return false;
        }

        if candidate.ends_with('*') {
            let prefix = candidate.trim_end_matches('*');
            return !prefix.is_empty() && path.starts_with(prefix);
        }

        path == candidate
    })
}

fn query_param_value(query: Option<&str>, key: &str) -> Option<String> {
    let query = query?;
    for pair in query.split('&') {
        let mut pieces = pair.splitn(2, '=');
        let candidate = pieces.next()?.trim();
        let value = pieces.next().unwrap_or_default().trim();
        if candidate == key && !value.is_empty() {
            return Some(value.to_string());
        }
    }
    None
}

fn local_test_login_signature_is_valid(uri: &axum::http::Uri, signing_key: &str) -> bool {
    let provided_signature = query_param_value(uri.query(), "signature")
        .map(|value| value.to_lowercase())
        .unwrap_or_default();
    if provided_signature.is_empty() {
        return false;
    }

    let unsigned_query = uri
        .query()
        .unwrap_or_default()
        .split('&')
        .filter(|segment| !segment.trim().is_empty())
        .filter(|segment| {
            let mut pieces = segment.splitn(2, '=');
            pieces.next().unwrap_or_default().trim() != "signature"
        })
        .collect::<Vec<_>>()
        .join("&");

    let canonical_payload = if unsigned_query.is_empty() {
        uri.path().to_string()
    } else {
        format!("{}?{unsigned_query}", uri.path())
    };

    let mut mac = match HmacSha256::new_from_slice(signing_key.as_bytes()) {
        Ok(value) => value,
        Err(_) => return false,
    };
    mac.update(canonical_payload.as_bytes());
    let expected = sha256_bytes_hex(&mac.finalize().into_bytes());

    expected == provided_signature
}

fn local_test_login_email_allowed(email: &str, allowed_emails: &[String]) -> bool {
    if allowed_emails.is_empty() {
        return false;
    }

    let normalized_email = email.trim().to_lowercase();
    if normalized_email.is_empty() {
        return false;
    }

    allowed_emails.iter().any(|allowed| {
        let candidate = allowed.trim().to_lowercase();
        !candidate.is_empty() && candidate == normalized_email
    })
}

fn maintenance_redirect_location(uri: &axum::http::Uri) -> String {
    let path = uri.path();
    let query = uri.query().unwrap_or_default();
    let filtered = query
        .split('&')
        .filter(|segment| !segment.trim().is_empty())
        .filter(|segment| {
            let mut pieces = segment.splitn(2, '=');
            pieces.next().unwrap_or_default().trim() != MAINTENANCE_BYPASS_QUERY_PARAM
        })
        .collect::<Vec<_>>();

    if filtered.is_empty() {
        if path.is_empty() {
            "/".to_string()
        } else {
            path.to_string()
        }
    } else {
        format!("{path}?{}", filtered.join("&"))
    }
}

fn maintenance_bypass_cookie_payload(token: &str, expires_at: u64) -> Option<String> {
    let payload = expires_at.to_string();
    let mut mac = HmacSha256::new_from_slice(token.as_bytes()).ok()?;
    mac.update(payload.as_bytes());
    let signature = URL_SAFE_NO_PAD.encode(mac.finalize().into_bytes());
    Some(format!("{payload}.{signature}"))
}

fn maintenance_cookie_is_valid(cookie_value: &str, token: &str) -> bool {
    let mut parts = cookie_value.splitn(2, '.');
    let expires_at_raw = parts.next().unwrap_or_default();
    let signature_segment = parts.next().unwrap_or_default();
    if expires_at_raw.is_empty() || signature_segment.is_empty() {
        return false;
    }

    let expires_at = match expires_at_raw.parse::<u64>() {
        Ok(value) => value,
        Err(_) => return false,
    };
    let now = Utc::now().timestamp().max(0) as u64;
    if expires_at <= now {
        return false;
    }

    let signature = match URL_SAFE_NO_PAD.decode(signature_segment) {
        Ok(value) => value,
        Err(_) => return false,
    };

    let mut mac = match HmacSha256::new_from_slice(token.as_bytes()) {
        Ok(value) => value,
        Err(_) => return false,
    };
    mac.update(expires_at_raw.as_bytes());
    mac.verify_slice(&signature).is_ok()
}

fn maintenance_bypass_cookie(
    cookie_name: &str,
    cookie_payload: &str,
    max_age_seconds: u64,
) -> String {
    format!(
        "{cookie_name}={cookie_payload}; Path=/; HttpOnly; Secure; SameSite=Lax; Max-Age={max_age_seconds}"
    )
}

fn challenge_cookie(challenge_id: &str, max_age_seconds: u64) -> String {
    format!(
        "{CHALLENGE_COOKIE_NAME}={challenge_id}; Path=/; HttpOnly; Secure; SameSite=Lax; Max-Age={max_age_seconds}"
    )
}

fn auth_access_cookie(access_token: &str, max_age_seconds: u64) -> String {
    format!(
        "{AUTH_ACCESS_COOKIE_NAME}={access_token}; Path=/; HttpOnly; Secure; SameSite=Lax; Max-Age={max_age_seconds}"
    )
}

fn auth_refresh_cookie(refresh_token: &str, max_age_seconds: u64) -> String {
    format!(
        "{AUTH_REFRESH_COOKIE_NAME}={refresh_token}; Path=/; HttpOnly; Secure; SameSite=Lax; Max-Age={max_age_seconds}"
    )
}

fn local_test_auth_cookie(max_age_seconds: u64) -> String {
    format!(
        "{LOCAL_TEST_AUTH_COOKIE_NAME}=1; Path=/; HttpOnly; Secure; SameSite=Lax; Max-Age={max_age_seconds}"
    )
}

fn clear_cookie(name: &str) -> String {
    format!("{name}=; Path=/; HttpOnly; Secure; SameSite=Lax; Max-Age=0")
}

fn append_set_cookie_header(
    response: &mut Response,
    cookie: &str,
) -> Result<(), (StatusCode, Json<ApiErrorResponse>)> {
    response
        .headers_mut()
        .append(SET_COOKIE, header_value(cookie)?);
    Ok(())
}

fn extract_cookie_value(headers: &HeaderMap, cookie_name: &str) -> Option<String> {
    let raw = headers.get(COOKIE)?.to_str().ok()?;
    for part in raw.split(';') {
        let mut pieces = part.trim().splitn(2, '=');
        let key = pieces.next()?.trim();
        let value = pieces.next()?.trim();

        if key == cookie_name {
            return non_empty(value.to_string());
        }
    }

    None
}

fn request_id(headers: &HeaderMap) -> String {
    header_string(headers, "x-request-id")
        .and_then(non_empty)
        .unwrap_or_else(|| format!("req_{}", uuid::Uuid::new_v4().simple()))
}

fn normalize_route_path(raw_path: &str) -> String {
    let normalized = raw_path.trim();
    if normalized.is_empty() {
        return ROUTE_RUNTIME_INTERNAL_SECRET_FETCH.to_string();
    }
    if normalized.starts_with('/') {
        normalized.to_string()
    } else {
        format!("/{normalized}")
    }
}

fn runtime_internal_error(
    status: StatusCode,
    code: &'static str,
    message: impl Into<String>,
) -> (StatusCode, Json<ApiErrorResponse>) {
    let message = message.into();
    (
        status,
        Json(ApiErrorResponse {
            message: message.clone(),
            error: ApiErrorDetail { code, message },
            errors: None,
        }),
    )
}

fn email_domain(email: &str) -> Option<String> {
    let domain = email.split('@').nth(1)?.trim();
    if domain.is_empty() {
        None
    } else {
        Some(domain.to_string())
    }
}

fn resolve_route_cohort_key(headers: &HeaderMap) -> String {
    header_string(headers, "x-oa-route-key")
        .or_else(|| header_string(headers, "x-device-id"))
        .or_else(|| header_string(headers, "x-forwarded-for"))
        .or_else(|| header_string(headers, "user-agent"))
        .and_then(non_empty)
        .unwrap_or_else(|| "anonymous".to_string())
}

fn is_pilot_chat_route(path: &str) -> bool {
    let normalized = path.trim();
    normalized == "/" || normalized == "/chat" || normalized.starts_with("/chat/")
}

fn is_retired_web_route(path: &str) -> bool {
    let normalized = path.trim();
    normalized == "/aui" || normalized.starts_with("/aui/")
}

fn emit_route_split_decision_audit(
    state: &AppState,
    request_id: &str,
    decision: &RouteSplitDecision,
    user_agent: &str,
) {
    let mut event = AuditEvent::new("route.split.decision", request_id.to_string())
        .with_attribute("path", decision.path.clone())
        .with_attribute(
            "target",
            match decision.target {
                RouteTarget::Legacy => "legacy".to_string(),
                RouteTarget::RustShell => "rust_shell".to_string(),
            },
        )
        .with_attribute("reason", decision.reason.clone())
        .with_attribute("route_domain", decision.route_domain.clone())
        .with_attribute("cohort_key", decision.cohort_key.clone())
        .with_attribute("user_agent", user_agent.to_string());

    if let Some(bucket) = decision.cohort_bucket {
        event = event.with_attribute("cohort_bucket", bucket.to_string());
    }

    if let Some(rollback_target) = decision.rollback_target {
        event = event.with_attribute(
            "rollback_target",
            match rollback_target {
                RouteTarget::Legacy => "legacy".to_string(),
                RouteTarget::RustShell => "rust_shell".to_string(),
            },
        );
    }

    state.observability.audit(event);
    state
        .observability
        .increment_counter("route.split.decision", request_id);
}

fn htmx_mode_label(mode: HtmxModeTarget) -> &'static str {
    match mode {
        HtmxModeTarget::Fragment => "fragment",
        HtmxModeTarget::FullPage => "full_page",
    }
}

fn emit_htmx_mode_decision_audit(
    state: &AppState,
    request_id: &str,
    decision: &HtmxModeDecision,
    htmx: &HtmxRequest,
) {
    let mut event = AuditEvent::new("route.htmx.mode.decision", request_id.to_string())
        .with_attribute("path", decision.path.clone())
        .with_attribute("route_domain", decision.route_domain.clone())
        .with_attribute("mode", htmx_mode_label(decision.mode).to_string())
        .with_attribute("reason", decision.reason.clone())
        .with_attribute(
            "rollback_mode",
            htmx_mode_label(decision.rollback_mode).to_string(),
        )
        .with_attribute("is_hx_request", htmx.is_hx_request.to_string())
        .with_attribute("hx_boosted", htmx.boosted.to_string())
        .with_attribute(
            "hx_history_restore_request",
            htmx.history_restore_request.to_string(),
        );

    if let Some(target) = htmx.target.as_ref() {
        event = event.with_attribute("hx_target", target.clone());
    }
    if let Some(trigger) = htmx.trigger.as_ref() {
        event = event.with_attribute("hx_trigger", trigger.clone());
    }
    if let Some(current_url) = htmx.current_url.as_ref() {
        event = event.with_attribute("hx_current_url", current_url.clone());
    }

    state.observability.audit(event);
    state
        .observability
        .increment_counter("route.htmx.mode.decision", request_id);
}

fn header_string(headers: &HeaderMap, key: &str) -> Option<String> {
    headers
        .get(key)
        .and_then(|value| value.to_str().ok())
        .map(|value| value.trim().to_string())
        .filter(|value| !value.is_empty())
}

fn constant_time_eq(left: &[u8], right: &[u8]) -> bool {
    if left.len() != right.len() {
        return false;
    }
    let mut diff: u8 = 0;
    for (lhs, rhs) in left.iter().zip(right.iter()) {
        diff |= lhs ^ rhs;
    }
    diff == 0
}

fn bearer_token(headers: &HeaderMap) -> Option<String> {
    let authorization = headers.get(AUTHORIZATION)?.to_str().ok()?.trim();
    let token = authorization.strip_prefix("Bearer ")?.trim();
    non_empty(token.to_string())
}

fn access_token_from_headers(headers: &HeaderMap) -> Option<String> {
    bearer_token(headers).or_else(|| extract_cookie_value(headers, AUTH_ACCESS_COOKIE_NAME))
}

fn non_empty(value: String) -> Option<String> {
    let trimmed = value.trim();
    if trimmed.is_empty() {
        None
    } else {
        Some(trimmed.to_string())
    }
}

fn auth_api_signup_is_enabled(config: &Config) -> bool {
    config.auth_api_signup_enabled && config.auth_provider_mode == "mock"
}

fn normalize_register_token_name(
    token_name: Option<String>,
    default_token_name: &str,
) -> Result<String, (StatusCode, Json<ApiErrorResponse>)> {
    let normalized = token_name
        .and_then(non_empty)
        .unwrap_or_else(|| default_token_name.trim().to_string());
    if normalized.chars().count() > 120 {
        return Err(validation_error(
            "tokenName",
            "Token name may not be greater than 120 characters.",
        ));
    }

    Ok(normalized)
}

fn normalize_register_token_abilities(
    token_abilities: Option<Vec<String>>,
) -> Result<Vec<String>, (StatusCode, Json<ApiErrorResponse>)> {
    let Some(values) = token_abilities else {
        return Ok(vec!["*".to_string()]);
    };

    let mut normalized = Vec::new();
    for value in values {
        let Some(ability) = non_empty(value) else {
            continue;
        };
        if ability.chars().count() > 120 {
            return Err(validation_error(
                "tokenAbilities",
                "Token abilities may not be greater than 120 characters.",
            ));
        }
        normalized.push(ability);
    }

    if normalized.is_empty() {
        Ok(vec!["*".to_string()])
    } else {
        Ok(normalized)
    }
}

fn normalize_optional_display_name(
    value: Option<String>,
    field: &'static str,
) -> Result<Option<String>, (StatusCode, Json<ApiErrorResponse>)> {
    let normalized = value.and_then(non_empty);
    if let Some(candidate) = normalized.as_deref() {
        if candidate.chars().count() > 120 {
            return Err(validation_error(
                field,
                "Value may not be greater than 120 characters.",
            ));
        }
    }

    Ok(normalized)
}

fn normalize_autopilot_handle_seed(
    value: Option<String>,
) -> Result<Option<String>, (StatusCode, Json<ApiErrorResponse>)> {
    let normalized = value.and_then(non_empty);
    let Some(handle) = normalized.as_ref() else {
        return Ok(None);
    };

    if handle.chars().count() > 64 {
        return Err(validation_error(
            "handle",
            "Handle may not be greater than 64 characters.",
        ));
    }

    let valid = handle
        .chars()
        .all(|character| character.is_ascii_alphanumeric() || matches!(character, ':' | '_' | '-'));
    if !valid {
        return Err(validation_error("handle", "Handle format is invalid."));
    }

    Ok(normalized)
}

fn normalize_optional_bounded_string(
    value: Option<String>,
    field: &'static str,
    max_chars: usize,
) -> Result<Option<String>, (StatusCode, Json<ApiErrorResponse>)> {
    let normalized = value.and_then(non_empty);
    if let Some(candidate) = normalized.as_deref() {
        if candidate.chars().count() > max_chars {
            return Err(validation_error(
                field,
                &format!("Value may not be greater than {max_chars} characters."),
            ));
        }
    }
    Ok(normalized)
}

fn normalize_optional_bounded_trimmed_string(
    value: Option<String>,
    field: &'static str,
    max_chars: usize,
) -> Result<Option<String>, (StatusCode, Json<ApiErrorResponse>)> {
    let Some(candidate) = value else {
        return Ok(None);
    };

    let trimmed = candidate.trim().to_string();
    if trimmed.chars().count() > max_chars {
        return Err(validation_error(
            field,
            &format!("Value may not be greater than {max_chars} characters."),
        ));
    }

    Ok(Some(trimmed))
}

fn normalize_autopilot_enum(
    value: Option<String>,
    field: &'static str,
    allowed: &[&str],
) -> Result<Option<String>, (StatusCode, Json<ApiErrorResponse>)> {
    let normalized = value.and_then(non_empty);
    let Some(candidate) = normalized.as_deref() else {
        return Ok(None);
    };

    if !allowed
        .iter()
        .any(|allowed_value| allowed_value == &candidate)
    {
        return Err(validation_error(
            field,
            &format!("Value must be one of: {}.", allowed.join(", ")),
        ));
    }

    Ok(normalized)
}

fn validate_optional_json_array(
    value: Option<serde_json::Value>,
    field: &'static str,
) -> Result<Option<serde_json::Value>, (StatusCode, Json<ApiErrorResponse>)> {
    match value {
        Some(value) if !value.is_array() => Err(validation_error(field, "Value must be an array.")),
        Some(value) => Ok(Some(value)),
        None => Ok(None),
    }
}

fn validate_optional_string_list_max(
    values: Option<Vec<String>>,
    field: &'static str,
    max_chars: usize,
) -> Result<Option<Vec<String>>, (StatusCode, Json<ApiErrorResponse>)> {
    let Some(values) = values else {
        return Ok(None);
    };

    for value in &values {
        if value.chars().count() > max_chars {
            return Err(validation_error(
                field,
                &format!("Array entries may not be greater than {max_chars} characters."),
            ));
        }
    }

    Ok(Some(values))
}

fn split_principles_text(value: Option<String>) -> Vec<String> {
    value
        .unwrap_or_default()
        .lines()
        .map(str::trim)
        .filter(|line| !line.is_empty())
        .map(ToString::to_string)
        .collect()
}

#[derive(Debug, Clone)]
struct CodingPolicyEvaluation {
    state: &'static str,
    decision: &'static str,
    reason_code: &'static str,
    denial_message: Option<String>,
    write_approved: bool,
    write_operations_mode: String,
    max_per_call_sats: Option<u64>,
    operation_cost_sats: u64,
}

fn validate_optional_json_object_or_array(
    value: Option<serde_json::Value>,
    field: &'static str,
) -> Result<Option<serde_json::Value>, (StatusCode, Json<ApiErrorResponse>)> {
    let Some(value) = value else {
        return Ok(None);
    };

    if value.is_object() || value.is_array() {
        return Ok(Some(value));
    }

    Err(validation_error(
        field,
        &format!("The {field} field must be an array."),
    ))
}

fn parse_optional_positive_u64(
    value: Option<serde_json::Value>,
    field: &'static str,
) -> Result<Option<u64>, (StatusCode, Json<ApiErrorResponse>)> {
    let Some(value) = value else {
        return Ok(None);
    };
    if value.is_null() {
        return Ok(None);
    }

    let parsed = positive_u64_from_value(&value).ok_or_else(|| {
        validation_error(field, &format!("The {field} field must be an integer."))
    })?;
    if parsed < 1 {
        return Err(validation_error(
            field,
            &format!("The {field} field must be at least 1."),
        ));
    }
    Ok(Some(parsed))
}

fn positive_u64_from_value(value: &serde_json::Value) -> Option<u64> {
    if let Some(number) = value.as_u64() {
        return Some(number);
    }
    let text = value.as_str()?.trim();
    if text.is_empty() {
        return None;
    }
    text.parse::<u64>().ok()
}

fn runtime_tools_principal_user_id(principal_id: &str) -> u64 {
    let digest = Sha256::digest(principal_id.as_bytes());
    let mut bytes = [0u8; 8];
    bytes.copy_from_slice(&digest[..8]);
    u64::from_be_bytes(bytes).max(1)
}

fn parse_coding_tool_invocation(
    request: &serde_json::Map<String, serde_json::Value>,
) -> Result<CodingToolInvocation, (StatusCode, Json<ApiErrorResponse>)> {
    let integration_id = normalized_json_string(request.get("integration_id"))
        .or_else(|| normalized_json_string(request.get("integrationId")))
        .ok_or_else(|| {
            validation_error(
                "request.integration_id",
                "The request.integration_id field is required.",
            )
        })?;

    let operation = normalized_json_string(request.get("operation"))
        .map(|value| value.to_lowercase())
        .ok_or_else(|| {
            validation_error(
                "request.operation",
                "The request.operation field is required.",
            )
        })?;
    if !matches!(
        operation.as_str(),
        "get_issue" | "get_pull_request" | "add_issue_comment"
    ) {
        return Err(validation_error(
            "request.operation",
            "The selected request.operation is invalid.",
        ));
    }

    let repository = normalized_json_string(request.get("repository")).ok_or_else(|| {
        validation_error(
            "request.repository",
            "The request.repository field is required.",
        )
    })?;
    if !repository.contains('/') || repository.starts_with('/') || repository.ends_with('/') {
        return Err(validation_error(
            "request.repository",
            "The request.repository field format is invalid.",
        ));
    }

    let issue_number = positive_u64_from_value(
        request
            .get("issue_number")
            .or_else(|| request.get("issueNumber"))
            .unwrap_or(&serde_json::Value::Null),
    );
    let pull_number = positive_u64_from_value(
        request
            .get("pull_number")
            .or_else(|| request.get("pullNumber"))
            .unwrap_or(&serde_json::Value::Null),
    );
    let body = normalized_json_string(request.get("body"));
    let tool_call_id = normalized_json_string(request.get("tool_call_id"))
        .or_else(|| normalized_json_string(request.get("toolCallId")));

    match operation.as_str() {
        "get_issue" => {
            if issue_number.is_none() {
                return Err(validation_error(
                    "request.issue_number",
                    "The request.issue_number field is required for get_issue.",
                ));
            }
        }
        "get_pull_request" => {
            if pull_number.is_none() {
                return Err(validation_error(
                    "request.pull_number",
                    "The request.pull_number field is required for get_pull_request.",
                ));
            }
        }
        "add_issue_comment" => {
            if issue_number.is_none() {
                return Err(validation_error(
                    "request.issue_number",
                    "The request.issue_number field is required for add_issue_comment.",
                ));
            }
            if body.is_none() {
                return Err(validation_error(
                    "request.body",
                    "The request.body field is required for add_issue_comment.",
                ));
            }
        }
        _ => {}
    }

    Ok(CodingToolInvocation {
        integration_id,
        operation,
        repository,
        issue_number,
        pull_number,
        body,
        tool_call_id,
    })
}

fn evaluate_coding_policy(
    invocation: &CodingToolInvocation,
    manifest: Option<&serde_json::Value>,
    policy: &serde_json::Value,
) -> CodingPolicyEvaluation {
    let manifest_capabilities = manifest
        .and_then(|manifest| manifest.get("capabilities"))
        .and_then(serde_json::Value::as_array)
        .map(|capabilities| {
            capabilities
                .iter()
                .filter_map(serde_json::Value::as_str)
                .map(|value| value.trim().to_lowercase())
                .filter(|value| !value.is_empty())
                .collect::<Vec<_>>()
        })
        .unwrap_or_default();

    let write_operations_mode = manifest
        .and_then(|manifest| manifest.get("policy"))
        .and_then(serde_json::Value::as_object)
        .and_then(|policy| policy.get("write_operations_mode"))
        .and_then(serde_json::Value::as_str)
        .map(|value| value.trim().to_lowercase())
        .filter(|value| !value.is_empty())
        .unwrap_or_else(|| "open".to_string());

    let write_approved = match policy {
        serde_json::Value::Object(policy_object) => policy_object
            .get("write_approved")
            .and_then(|value| {
                value.as_bool().or_else(|| {
                    value
                        .as_str()
                        .map(|text| matches!(text.trim(), "1" | "true" | "yes"))
                })
            })
            .unwrap_or(false),
        _ => false,
    };

    let max_per_call_sats = match policy {
        serde_json::Value::Object(policy_object) => policy_object
            .get("budget")
            .and_then(serde_json::Value::as_object)
            .and_then(|budget| budget.get("max_per_call_sats"))
            .and_then(positive_u64_from_value),
        _ => None,
    };

    let operation_cost_sats = match invocation.operation.as_str() {
        "add_issue_comment" => 50,
        "get_pull_request" => 10,
        _ => 5,
    };

    if !manifest_capabilities.is_empty()
        && !manifest_capabilities
            .iter()
            .any(|capability| capability == &invocation.operation)
    {
        return CodingPolicyEvaluation {
            state: "blocked",
            decision: "denied",
            reason_code: "policy_denied.capability_not_allowed",
            denial_message: Some(
                "Requested operation is not listed in manifest capabilities.".to_string(),
            ),
            write_approved,
            write_operations_mode,
            max_per_call_sats,
            operation_cost_sats,
        };
    }

    if invocation.operation == "add_issue_comment"
        && write_operations_mode == "enforce"
        && !write_approved
    {
        return CodingPolicyEvaluation {
            state: "blocked",
            decision: "denied",
            reason_code: "policy_denied.write_approval_required",
            denial_message: Some(
                "Write operation requires explicit policy.write_approved=true.".to_string(),
            ),
            write_approved,
            write_operations_mode,
            max_per_call_sats,
            operation_cost_sats,
        };
    }

    if max_per_call_sats
        .map(|max| operation_cost_sats > max)
        .unwrap_or(false)
    {
        return CodingPolicyEvaluation {
            state: "blocked",
            decision: "denied",
            reason_code: "policy_denied.max_per_call_budget_exceeded",
            denial_message: Some("Policy budget max_per_call_sats was exceeded.".to_string()),
            write_approved,
            write_operations_mode,
            max_per_call_sats,
            operation_cost_sats,
        };
    }

    CodingPolicyEvaluation {
        state: "succeeded",
        decision: "allowed",
        reason_code: "policy_allowed.default",
        denial_message: None,
        write_approved,
        write_operations_mode,
        max_per_call_sats,
        operation_cost_sats,
    }
}

fn build_coding_execution_result(
    invocation: &CodingToolInvocation,
    evaluation: &CodingPolicyEvaluation,
    replay_hash_hex: &str,
) -> serde_json::Value {
    if evaluation.decision != "allowed" {
        return serde_json::json!({
            "blocked": true,
            "operation": invocation.operation.clone(),
            "repository": invocation.repository.clone(),
        });
    }

    match invocation.operation.as_str() {
        "get_issue" => {
            let issue_number = invocation.issue_number.unwrap_or_default();
            serde_json::json!({
                "integration_id": invocation.integration_id.clone(),
                "operation": invocation.operation.clone(),
                "repository": invocation.repository.clone(),
                "issue_number": issue_number,
                "issue": {
                    "number": issue_number,
                    "title": format!("Issue #{issue_number}"),
                    "url": format!("https://github.com/{}/issues/{issue_number}", invocation.repository),
                },
            })
        }
        "get_pull_request" => {
            let pull_number = invocation.pull_number.unwrap_or_default();
            serde_json::json!({
                "integration_id": invocation.integration_id.clone(),
                "operation": invocation.operation.clone(),
                "repository": invocation.repository.clone(),
                "pull_number": pull_number,
                "pull_request": {
                    "number": pull_number,
                    "title": format!("Pull request #{pull_number}"),
                    "url": format!("https://github.com/{}/pull/{pull_number}", invocation.repository),
                },
            })
        }
        "add_issue_comment" => {
            let issue_number = invocation.issue_number.unwrap_or_default();
            serde_json::json!({
                "integration_id": invocation.integration_id.clone(),
                "operation": invocation.operation.clone(),
                "repository": invocation.repository.clone(),
                "issue_number": issue_number,
                "comment": {
                    "id": format!("comment_{}", &replay_hash_hex[..16]),
                    "body": invocation.body.clone().unwrap_or_default(),
                    "url": format!("https://github.com/{}/issues/{issue_number}#issuecomment-{}", invocation.repository, &replay_hash_hex[..12]),
                },
            })
        }
        _ => serde_json::json!({
            "blocked": true,
        }),
    }
}

fn runtime_tools_replay_hash_hex(seed: &serde_json::Value) -> String {
    let canonical = canonicalize_json(seed);
    let encoded = serde_json::to_vec(&canonical).unwrap_or_else(|_| b"{}".to_vec());
    sha256_hex(&encoded)
}

fn canonicalize_json(value: &serde_json::Value) -> serde_json::Value {
    match value {
        serde_json::Value::Object(object) => {
            let mut keys = object.keys().cloned().collect::<Vec<_>>();
            keys.sort();
            let mut normalized = serde_json::Map::new();
            for key in keys {
                if let Some(entry) = object.get(&key) {
                    normalized.insert(key, canonicalize_json(entry));
                }
            }
            serde_json::Value::Object(normalized)
        }
        serde_json::Value::Array(values) => {
            serde_json::Value::Array(values.iter().map(canonicalize_json).collect())
        }
        _ => value.clone(),
    }
}

fn mark_runtime_tools_replay(mut payload: serde_json::Value) -> serde_json::Value {
    if let Some(object) = payload.as_object_mut() {
        object.insert("idempotentReplay".to_string(), serde_json::json!(true));
    }
    payload
}

fn runtime_worker_snapshot_payload(
    worker: &RuntimeWorkerRecord,
    now: chrono::DateTime<Utc>,
) -> serde_json::Value {
    let (heartbeat_state, heartbeat_age_ms) = runtime_worker_heartbeat_state(worker, now);
    serde_json::json!({
        "worker_id": worker.worker_id,
        "status": worker.status,
        "latest_seq": worker.latest_seq,
        "workspace_ref": worker.workspace_ref,
        "codex_home_ref": worker.codex_home_ref,
        "adapter": worker.adapter,
        "metadata": worker.metadata,
        "started_at": worker.started_at.map(timestamp),
        "stopped_at": worker.stopped_at.map(timestamp),
        "last_heartbeat_at": worker.last_heartbeat_at.map(timestamp),
        "heartbeat_age_ms": heartbeat_age_ms,
        "heartbeat_stale_after_ms": worker.heartbeat_stale_after_ms,
        "heartbeat_state": heartbeat_state,
        "updated_at": timestamp(worker.updated_at),
        "khala_projection": {
            "status": "in_sync",
            "lag_events": 0,
            "last_runtime_seq": worker.latest_seq,
            "last_projected_at": timestamp(worker.updated_at),
        }
    })
}

fn runtime_worker_event_payload(event: &RuntimeWorkerEventRecord) -> serde_json::Value {
    serde_json::json!({
        "seq": event.seq,
        "event_type": event.event_type,
        "payload": event.payload,
        "occurred_at": timestamp(event.occurred_at),
    })
}

fn runtime_worker_heartbeat_state(
    worker: &RuntimeWorkerRecord,
    now: chrono::DateTime<Utc>,
) -> (&'static str, Option<u64>) {
    let age_ms = worker.last_heartbeat_at.map(|heartbeat| {
        now.signed_duration_since(heartbeat)
            .num_milliseconds()
            .max(0) as u64
    });
    match worker.status.as_str() {
        "failed" => ("failed", age_ms),
        "stopped" => ("stopped", age_ms),
        _ => match age_ms {
            None => ("missing", None),
            Some(age_ms) if age_ms > worker.heartbeat_stale_after_ms => ("stale", Some(age_ms)),
            Some(age_ms) => ("fresh", Some(age_ms)),
        },
    }
}

async fn ensure_runtime_worker_runnable(
    state: &AppState,
    owner_user_id: &str,
    worker_id: &str,
    auto_provision: bool,
) -> Result<(), (StatusCode, Json<ApiErrorResponse>)> {
    let mut workers = state.runtime_workers.workers.lock().await;
    if let Some(worker) = workers.get_mut(worker_id) {
        if worker.owner_user_id != owner_user_id {
            return Err(forbidden_error(
                "worker does not belong to authenticated principal",
            ));
        }
        if matches!(worker.status.as_str(), "stopping" | "stopped" | "failed") {
            return Err(error_response_with_status(
                StatusCode::CONFLICT,
                ApiErrorCode::Conflict,
                "worker is stopped; create or reattach to resume",
            ));
        }
        return Ok(());
    }

    if !auto_provision {
        return Err(not_found_error("Not found."));
    }

    let now = Utc::now();
    workers.insert(
        worker_id.to_string(),
        RuntimeWorkerRecord {
            worker_id: worker_id.to_string(),
            owner_user_id: owner_user_id.to_string(),
            status: "running".to_string(),
            latest_seq: 0,
            workspace_ref: None,
            codex_home_ref: None,
            adapter: "in_memory".to_string(),
            metadata: None,
            started_at: Some(now),
            stopped_at: None,
            last_heartbeat_at: Some(now),
            heartbeat_stale_after_ms: 120_000,
            updated_at: now,
        },
    );

    Ok(())
}

async fn append_runtime_worker_event(
    state: &AppState,
    worker_id: &str,
    event_type: &str,
    payload: serde_json::Value,
    occurred_at: chrono::DateTime<Utc>,
) -> Result<u64, (StatusCode, Json<ApiErrorResponse>)> {
    let seq = {
        let mut workers = state.runtime_workers.workers.lock().await;
        let worker = workers
            .get_mut(worker_id)
            .ok_or_else(|| not_found_error("Not found."))?;
        worker.latest_seq = worker.latest_seq.saturating_add(1);
        worker.updated_at = occurred_at;
        if event_type == "worker.stopped" {
            worker.status = "stopped".to_string();
            worker.stopped_at = Some(occurred_at);
        }
        if event_type == "worker.heartbeat" {
            worker.last_heartbeat_at = Some(occurred_at);
        }
        worker.latest_seq
    };

    let mut events = state.runtime_workers.events.lock().await;
    events
        .entry(worker_id.to_string())
        .or_default()
        .push(RuntimeWorkerEventRecord {
            seq,
            event_type: event_type.to_string(),
            payload,
            occurred_at,
        });

    Ok(seq)
}

fn validate_worker_handshake_payload(
    event_type: &str,
    payload: &serde_json::Value,
) -> Result<(), (StatusCode, Json<ApiErrorResponse>)> {
    if event_type != "worker.event" {
        return Ok(());
    }

    let method = payload
        .get("method")
        .and_then(serde_json::Value::as_str)
        .map(str::trim)
        .unwrap_or_default();
    if !matches!(method, "ios/handshake" | "desktop/handshake_ack") {
        return Ok(());
    }

    for field in ["source", "method", "handshake_id", "occurred_at"] {
        let present = payload
            .get(field)
            .and_then(serde_json::Value::as_str)
            .map(str::trim)
            .filter(|value| !value.is_empty())
            .is_some();
        if !present {
            return Err(validation_error(
                "event.payload",
                "Handshake payload is missing required fields.",
            ));
        }
    }
    let occurred_at = payload
        .get("occurred_at")
        .and_then(serde_json::Value::as_str)
        .unwrap_or_default();
    if parse_rfc3339_utc(occurred_at).is_err() {
        return Err(validation_error(
            "event.payload.occurred_at",
            "The occurred_at field must be a valid RFC3339 timestamp.",
        ));
    }

    if method == "ios/handshake"
        && payload
            .get("device_id")
            .and_then(serde_json::Value::as_str)
            .map(str::trim)
            .filter(|value| !value.is_empty())
            .is_none()
    {
        return Err(validation_error(
            "event.payload.device_id",
            "ios/handshake requires device_id.",
        ));
    }
    if method == "desktop/handshake_ack"
        && payload
            .get("desktop_session_id")
            .and_then(serde_json::Value::as_str)
            .map(str::trim)
            .filter(|value| !value.is_empty())
            .is_none()
    {
        return Err(validation_error(
            "event.payload.desktop_session_id",
            "desktop/handshake_ack requires desktop_session_id.",
        ));
    }

    Ok(())
}

fn parse_event_occurred_at(payload: &serde_json::Value) -> Option<chrono::DateTime<Utc>> {
    payload
        .get("occurred_at")
        .and_then(serde_json::Value::as_str)
        .and_then(|value| parse_rfc3339_utc(value).ok())
}

fn builtin_tool_specs() -> Vec<serde_json::Value> {
    vec![serde_json::json!({
        "tool_id": "github.primary",
        "version": 1,
        "tool_pack": "coding.v1",
        "state": "published",
        "tool_spec": {
            "tool_id": "github.primary",
            "version": 1,
            "tool_pack": "coding.v1",
            "name": "GitHub Primary",
            "execution_kind": "http",
            "integration_manifest": {
                "manifest_version": "coding.integration.v1",
                "integration_id": "github.primary",
                "provider": "github",
                "status": "active",
                "tool_pack": "coding.v1",
                "capabilities": ["get_issue", "get_pull_request", "add_issue_comment"],
            }
        },
        "created_at": "2026-02-22T00:00:00Z",
        "updated_at": "2026-02-22T00:00:00Z"
    })]
}

fn builtin_skill_specs() -> Vec<serde_json::Value> {
    vec![serde_json::json!({
        "skill_id": "github-coding",
        "version": 1,
        "state": "published",
        "skill_spec": {
            "skill_id": "github-coding",
            "version": 1,
            "name": "GitHub Coding",
            "description": "Default GitHub coding workflow skill",
            "allowed_tools": [{"tool_id": "github.primary", "version": 1}],
            "compatibility": {"runtime": "runtime"},
        },
        "created_at": "2026-02-22T00:00:00Z",
        "updated_at": "2026-02-22T00:00:00Z"
    })]
}

fn builtin_skill_spec(skill_id: &str, version: u64) -> Option<serde_json::Value> {
    builtin_skill_specs().into_iter().find(|item| {
        item.get("skill_id")
            .and_then(serde_json::Value::as_str)
            .map(|candidate| candidate == skill_id)
            .unwrap_or(false)
            && item
                .get("version")
                .and_then(serde_json::Value::as_u64)
                .map(|candidate| candidate == version)
                .unwrap_or(false)
    })
}

fn registry_key(id: &str, version: u64) -> String {
    format!("{}::{version}", id.trim().to_lowercase())
}

fn registry_item_key(item: &serde_json::Value, id_field: &str) -> String {
    let id = item
        .get(id_field)
        .and_then(serde_json::Value::as_str)
        .unwrap_or_default();
    let version = item
        .get("version")
        .and_then(serde_json::Value::as_u64)
        .unwrap_or(0);
    registry_key(id, version)
}

fn registry_sort_key(item: &serde_json::Value, id_field: &str) -> String {
    let id = item
        .get(id_field)
        .and_then(serde_json::Value::as_str)
        .unwrap_or_default()
        .to_lowercase();
    let version = item
        .get("version")
        .and_then(serde_json::Value::as_u64)
        .unwrap_or(0);
    format!("{id}:{version:020}")
}

fn normalize_registry_state(
    value: Option<String>,
    field: &'static str,
) -> Result<String, (StatusCode, Json<ApiErrorResponse>)> {
    let normalized = value
        .and_then(non_empty)
        .unwrap_or_else(|| "validated".to_string())
        .to_lowercase();
    if !matches!(
        normalized.as_str(),
        "draft" | "validated" | "published" | "deprecated"
    ) {
        return Err(validation_error(field, "The selected state is invalid."));
    }
    Ok(normalized)
}

fn validate_tool_spec_schema(
    tool_spec: &serde_json::Map<String, serde_json::Value>,
) -> Result<(String, u64, String), (StatusCode, Json<ApiErrorResponse>)> {
    let tool_id = tool_spec
        .get("tool_id")
        .and_then(serde_json::Value::as_str)
        .map(str::trim)
        .filter(|value| !value.is_empty())
        .map(ToString::to_string)
        .ok_or_else(|| {
            validation_error(
                "tool_spec.tool_id",
                "The tool_spec.tool_id field is required.",
            )
        })?;
    if tool_id.chars().count() > 160 {
        return Err(validation_error(
            "tool_spec.tool_id",
            "The tool_spec.tool_id field may not be greater than 160 characters.",
        ));
    }

    let version = tool_spec
        .get("version")
        .and_then(positive_u64_from_value)
        .ok_or_else(|| {
            validation_error(
                "tool_spec.version",
                "The tool_spec.version field must be an integer.",
            )
        })?;
    if version < 1 {
        return Err(validation_error(
            "tool_spec.version",
            "The tool_spec.version field must be at least 1.",
        ));
    }

    let tool_pack = tool_spec
        .get("tool_pack")
        .and_then(serde_json::Value::as_str)
        .map(str::trim)
        .filter(|value| !value.is_empty())
        .map(ToString::to_string)
        .ok_or_else(|| {
            validation_error(
                "tool_spec.tool_pack",
                "The tool_spec.tool_pack field is required.",
            )
        })?;
    if tool_pack != "coding.v1" {
        return Err(validation_error(
            "tool_spec.tool_pack",
            "Only coding.v1 tool_pack is currently supported.",
        ));
    }

    if let Some(integration_manifest) = tool_spec.get("integration_manifest") {
        if !integration_manifest.is_object() {
            return Err(validation_error(
                "tool_spec.integration_manifest",
                "The tool_spec.integration_manifest field must be an array.",
            ));
        }
        let manifest_version = integration_manifest
            .get("manifest_version")
            .and_then(serde_json::Value::as_str)
            .map(str::trim)
            .filter(|value| !value.is_empty());
        if manifest_version.is_none() {
            return Err(validation_error(
                "tool_spec.integration_manifest.manifest_version",
                "The tool_spec.integration_manifest.manifest_version field is required.",
            ));
        }
    }

    Ok((tool_id, version, tool_pack))
}

fn validate_skill_spec_schema(
    skill_spec: &serde_json::Map<String, serde_json::Value>,
) -> Result<(String, u64), (StatusCode, Json<ApiErrorResponse>)> {
    let skill_id = skill_spec
        .get("skill_id")
        .and_then(serde_json::Value::as_str)
        .map(str::trim)
        .filter(|value| !value.is_empty())
        .map(ToString::to_string)
        .ok_or_else(|| {
            validation_error(
                "skill_spec.skill_id",
                "The skill_spec.skill_id field is required.",
            )
        })?;
    if skill_id.chars().count() > 160 {
        return Err(validation_error(
            "skill_spec.skill_id",
            "The skill_spec.skill_id field may not be greater than 160 characters.",
        ));
    }

    let version = skill_spec
        .get("version")
        .and_then(positive_u64_from_value)
        .ok_or_else(|| {
            validation_error(
                "skill_spec.version",
                "The skill_spec.version field must be an integer.",
            )
        })?;
    if version < 1 {
        return Err(validation_error(
            "skill_spec.version",
            "The skill_spec.version field must be at least 1.",
        ));
    }

    if let Some(allowed_tools) = skill_spec.get("allowed_tools") {
        let entries = allowed_tools.as_array().ok_or_else(|| {
            validation_error(
                "skill_spec.allowed_tools",
                "The skill_spec.allowed_tools field must be an array.",
            )
        })?;
        for entry in entries {
            let entry_object = entry.as_object().ok_or_else(|| {
                validation_error(
                    "skill_spec.allowed_tools",
                    "Each skill_spec.allowed_tools entry must be an object.",
                )
            })?;
            let tool_id = entry_object
                .get("tool_id")
                .and_then(serde_json::Value::as_str)
                .map(str::trim)
                .filter(|value| !value.is_empty());
            if tool_id.is_none() {
                return Err(validation_error(
                    "skill_spec.allowed_tools",
                    "Each allowed tool entry requires tool_id.",
                ));
            }
            let tool_version = entry_object
                .get("version")
                .and_then(positive_u64_from_value)
                .filter(|value| *value >= 1);
            if tool_version.is_none() {
                return Err(validation_error(
                    "skill_spec.allowed_tools",
                    "Each allowed tool entry requires version >= 1.",
                ));
            }
        }
    }

    Ok((skill_id, version))
}

fn normalize_autopilot_profile_update(
    payload: UpdateAutopilotProfilePayload,
) -> Result<UpsertAutopilotProfileInput, (StatusCode, Json<ApiErrorResponse>)> {
    let owner_display_name =
        normalize_optional_display_name(payload.owner_display_name, "profile.ownerDisplayName")?;
    let persona_summary = payload.persona_summary.and_then(non_empty);
    let autopilot_voice =
        normalize_optional_bounded_string(payload.autopilot_voice, "profile.autopilotVoice", 64)?;
    let principles = validate_optional_json_array(payload.principles, "profile.principles")?;
    let preferences = validate_optional_json_array(payload.preferences, "profile.preferences")?;
    let onboarding_answers =
        validate_optional_json_array(payload.onboarding_answers, "profile.onboardingAnswers")?;

    if matches!(payload.schema_version, Some(0)) {
        return Err(validation_error(
            "profile.schemaVersion",
            "Schema version must be greater than or equal to 1.",
        ));
    }

    Ok(UpsertAutopilotProfileInput {
        owner_display_name,
        persona_summary,
        autopilot_voice,
        principles,
        preferences,
        onboarding_answers,
        schema_version: payload.schema_version,
    })
}

fn normalize_autopilot_policy_update(
    payload: UpdateAutopilotPolicyPayload,
) -> Result<UpsertAutopilotPolicyInput, (StatusCode, Json<ApiErrorResponse>)> {
    let model_provider =
        normalize_optional_bounded_string(payload.model_provider, "policy.modelProvider", 64)?;
    let model = normalize_optional_bounded_string(payload.model, "policy.model", 128)?;
    let tool_allowlist =
        validate_optional_string_list_max(payload.tool_allowlist, "policy.toolAllowlist", 128)?;
    let tool_denylist =
        validate_optional_string_list_max(payload.tool_denylist, "policy.toolDenylist", 128)?;
    let l402_allowed_hosts = validate_optional_string_list_max(
        payload.l402_allowed_hosts,
        "policy.l402AllowedHosts",
        255,
    )?;
    let data_policy = validate_optional_json_array(payload.data_policy, "policy.dataPolicy")?;

    if matches!(payload.l402_max_spend_msats_per_call, Some(0)) {
        return Err(validation_error(
            "policy.l402MaxSpendMsatsPerCall",
            "Value must be greater than or equal to 1.",
        ));
    }
    if matches!(payload.l402_max_spend_msats_per_day, Some(0)) {
        return Err(validation_error(
            "policy.l402MaxSpendMsatsPerDay",
            "Value must be greater than or equal to 1.",
        ));
    }

    Ok(UpsertAutopilotPolicyInput {
        model_provider,
        model,
        tool_allowlist,
        tool_denylist,
        l402_require_approval: payload.l402_require_approval,
        l402_max_spend_msats_per_call: payload.l402_max_spend_msats_per_call,
        l402_max_spend_msats_per_day: payload.l402_max_spend_msats_per_day,
        l402_allowed_hosts,
        data_policy,
    })
}

fn normalize_autopilot_reference(
    autopilot: String,
) -> Result<String, (StatusCode, Json<ApiErrorResponse>)> {
    let reference = autopilot.trim().to_string();
    if reference.is_empty() {
        return Err(validation_error(
            "autopilot",
            "Autopilot reference is required.",
        ));
    }
    Ok(reference)
}

fn autopilot_update_field_count(
    has_display_name: bool,
    has_status: bool,
    has_visibility: bool,
    has_avatar: bool,
    has_tagline: bool,
    has_profile_update: bool,
    has_policy_update: bool,
) -> usize {
    let mut count = 0usize;
    if has_display_name {
        count += 1;
    }
    if has_status {
        count += 1;
    }
    if has_visibility {
        count += 1;
    }
    if has_avatar {
        count += 1;
    }
    if has_tagline {
        count += 1;
    }
    if has_profile_update {
        count += 1;
    }
    if has_policy_update {
        count += 1;
    }
    count
}

fn autopilot_aggregate_payload(aggregate: &AutopilotAggregate) -> serde_json::Value {
    serde_json::json!({
        "id": aggregate.autopilot.id.clone(),
        "handle": aggregate.autopilot.handle.clone(),
        "displayName": aggregate.autopilot.display_name.clone(),
        "status": aggregate.autopilot.status.clone(),
        "visibility": aggregate.autopilot.visibility.clone(),
        "ownerUserId": aggregate.autopilot.owner_user_id.clone(),
        "avatar": aggregate.autopilot.avatar.clone(),
        "tagline": aggregate.autopilot.tagline.clone(),
        "configVersion": aggregate.autopilot.config_version,
        "profile": {
            "ownerDisplayName": aggregate.profile.owner_display_name.clone(),
            "personaSummary": aggregate.profile.persona_summary.clone(),
            "autopilotVoice": aggregate.profile.autopilot_voice.clone(),
            "principles": aggregate.profile.principles.clone().unwrap_or_else(|| serde_json::Value::Array(Vec::new())),
            "preferences": aggregate.profile.preferences.clone().unwrap_or_else(|| serde_json::Value::Array(Vec::new())),
            "onboardingAnswers": if aggregate.profile.onboarding_answers.is_array() {
                aggregate.profile.onboarding_answers.clone()
            } else {
                serde_json::Value::Array(Vec::new())
            },
            "schemaVersion": aggregate.profile.schema_version,
        },
        "policy": {
            "modelProvider": aggregate.policy.model_provider.clone(),
            "model": aggregate.policy.model.clone(),
            "toolAllowlist": aggregate.policy.tool_allowlist.clone(),
            "toolDenylist": aggregate.policy.tool_denylist.clone(),
            "l402RequireApproval": aggregate.policy.l402_require_approval,
            "l402MaxSpendMsatsPerCall": aggregate.policy.l402_max_spend_msats_per_call,
            "l402MaxSpendMsatsPerDay": aggregate.policy.l402_max_spend_msats_per_day,
            "l402AllowedHosts": aggregate.policy.l402_allowed_hosts.clone(),
            "dataPolicy": aggregate.policy.data_policy.clone().unwrap_or_else(|| serde_json::Value::Array(Vec::new())),
        },
        "createdAt": timestamp(aggregate.autopilot.created_at),
        "updatedAt": timestamp(aggregate.autopilot.updated_at),
    })
}

fn autopilot_thread_payload(thread: &AutopilotThreadProjection) -> serde_json::Value {
    serde_json::json!({
        "id": thread.id,
        "autopilotId": thread.autopilot_id,
        "title": thread.title,
        "createdAt": timestamp(thread.created_at),
        "updatedAt": timestamp(thread.updated_at),
    })
}

fn autopilot_prompt_context(aggregate: &AutopilotAggregate) -> Option<String> {
    let mut lines = vec![
        format!("autopilot_id={}", aggregate.autopilot.id),
        format!(
            "config_version={}",
            aggregate.autopilot.config_version.max(1)
        ),
        format!("handle={}", aggregate.autopilot.handle),
    ];

    if let Some(display_name) = non_empty(aggregate.autopilot.display_name.clone()) {
        lines.push(format!("display_name={display_name}"));
    }
    if let Some(owner_display_name) = non_empty(aggregate.profile.owner_display_name.clone()) {
        lines.push(format!("owner_display_name={owner_display_name}"));
    }
    if let Some(tagline) = aggregate.autopilot.tagline.clone().and_then(non_empty) {
        lines.push(format!("tagline={tagline}"));
    }
    if let Some(persona_summary) = aggregate
        .profile
        .persona_summary
        .clone()
        .and_then(non_empty)
    {
        lines.push(format!("persona_summary={persona_summary}"));
    }
    if let Some(autopilot_voice) = aggregate
        .profile
        .autopilot_voice
        .clone()
        .and_then(non_empty)
    {
        lines.push(format!("autopilot_voice={autopilot_voice}"));
    }

    let principles = value_string_array(aggregate.profile.principles.as_ref());
    if !principles.is_empty() {
        lines.push(format!("principles={}", principles.join(" | ")));
    }

    if let Some(preferences) = aggregate
        .profile
        .preferences
        .as_ref()
        .and_then(serde_json::Value::as_object)
    {
        if let Some(user_preferences) = preferences
            .get("user")
            .and_then(serde_json::Value::as_object)
        {
            if let Some(address_as) = normalized_json_string(user_preferences.get("addressAs")) {
                lines.push(format!("preferred_address={address_as}"));
            }
            if let Some(time_zone) = normalized_json_string(user_preferences.get("timeZone")) {
                lines.push(format!("time_zone={time_zone}"));
            }
        }

        if let Some(character_preferences) = preferences
            .get("character")
            .and_then(serde_json::Value::as_object)
        {
            let boundaries = character_preferences
                .get("boundaries")
                .and_then(serde_json::Value::as_array)
                .map(|values| {
                    values
                        .iter()
                        .filter_map(|value| {
                            non_empty(value.as_str().unwrap_or_default().to_string())
                        })
                        .collect::<Vec<_>>()
                })
                .unwrap_or_default();
            if !boundaries.is_empty() {
                lines.push(format!("boundaries={}", boundaries.join(" | ")));
            }
        }
    }

    if let Some(onboarding) = aggregate
        .profile
        .onboarding_answers
        .as_object()
        .and_then(|object| object.get("bootstrapState"))
        .and_then(serde_json::Value::as_object)
    {
        let status = normalized_json_string(onboarding.get("status"));
        let stage = normalized_json_string(onboarding.get("stage"));
        if status.is_some() || stage.is_some() {
            let label = format!(
                "{}{}",
                status.unwrap_or_else(|| "unknown".to_string()),
                stage.map(|value| format!(" @ {value}")).unwrap_or_default()
            );
            lines.push(format!("onboarding={label}"));
        }
    }

    if !aggregate.policy.tool_allowlist.is_empty() {
        lines.push(format!(
            "tool_allowlist={}",
            aggregate.policy.tool_allowlist.join(",")
        ));
    }
    if !aggregate.policy.tool_denylist.is_empty() {
        lines.push(format!(
            "tool_denylist={}",
            aggregate.policy.tool_denylist.join(",")
        ));
    }
    lines.push(format!(
        "l402_require_approval={}",
        if aggregate.policy.l402_require_approval {
            "true"
        } else {
            "false"
        }
    ));
    if let Some(max_spend_per_call) = aggregate.policy.l402_max_spend_msats_per_call {
        lines.push(format!(
            "l402_max_spend_msats_per_call={max_spend_per_call}"
        ));
    }
    if let Some(max_spend_per_day) = aggregate.policy.l402_max_spend_msats_per_day {
        lines.push(format!("l402_max_spend_msats_per_day={max_spend_per_day}"));
    }
    if !aggregate.policy.l402_allowed_hosts.is_empty() {
        lines.push(format!(
            "l402_allowed_hosts={}",
            aggregate.policy.l402_allowed_hosts.join(",")
        ));
    }

    let context = lines.join("\n").trim().to_string();
    if context.is_empty() {
        return None;
    }

    Some(context.chars().take(3200).collect())
}

fn autopilot_tool_resolution_audit(
    aggregate: &AutopilotAggregate,
    session_authenticated: bool,
) -> serde_json::Value {
    if !session_authenticated {
        let available_tools = tool_name_list_from_static(AUTOPILOT_ALL_TOOLS);
        let guest_allowlist = tool_name_list_from_static(AUTOPILOT_GUEST_ALLOWED_TOOLS);
        let exposed_tools = guest_allowlist
            .iter()
            .filter(|name| available_tools.contains(*name))
            .cloned()
            .collect::<Vec<_>>();
        let removed_by_auth_gate = available_tools
            .iter()
            .filter(|name| !exposed_tools.contains(*name))
            .cloned()
            .collect::<Vec<_>>();
        return serde_json::json!({
            "policyApplied": false,
            "authRestricted": true,
            "sessionAuthenticated": false,
            "autopilotId": serde_json::Value::Null,
            "availableTools": available_tools,
            "exposedTools": exposed_tools,
            "allowlist": guest_allowlist,
            "denylist": [],
            "removedByAllowlist": [],
            "removedByDenylist": [],
            "removedByAuthGate": removed_by_auth_gate,
        });
    }

    let available_tools = tool_name_list_from_static(AUTOPILOT_AUTHENTICATED_TOOLS);
    let allowlist = tool_name_list(&aggregate.policy.tool_allowlist);
    let denylist = tool_name_list(&aggregate.policy.tool_denylist);
    let (exposed_tools, removed_by_allowlist, removed_by_denylist) =
        resolve_tool_names(&available_tools, &allowlist, &denylist);

    serde_json::json!({
        "policyApplied": true,
        "authRestricted": false,
        "sessionAuthenticated": true,
        "autopilotId": aggregate.autopilot.id.clone(),
        "availableTools": available_tools,
        "exposedTools": exposed_tools,
        "allowlist": allowlist,
        "denylist": denylist,
        "removedByAllowlist": removed_by_allowlist,
        "removedByDenylist": removed_by_denylist,
        "removedByAuthGate": [],
    })
}

fn autopilot_runtime_binding_worker_ref(aggregate: &AutopilotAggregate) -> Option<String> {
    let binding = aggregate
        .runtime_bindings
        .iter()
        .find(|binding| binding.is_primary)
        .or_else(|| aggregate.runtime_bindings.first())?;
    binding.runtime_ref.clone().and_then(non_empty)
}

fn autopilot_runtime_binding_payload(aggregate: &AutopilotAggregate) -> serde_json::Value {
    let Some(binding) = aggregate
        .runtime_bindings
        .iter()
        .find(|binding| binding.is_primary)
        .or_else(|| aggregate.runtime_bindings.first())
    else {
        return serde_json::Value::Null;
    };

    serde_json::json!({
        "id": binding.id,
        "runtimeType": binding.runtime_type,
        "runtimeRef": binding.runtime_ref,
        "isPrimary": binding.is_primary,
        "driverHint": runtime_driver_hint(&binding.runtime_type),
        "lastSeenAt": binding.last_seen_at.map(timestamp),
        "meta": binding.meta,
        "createdAt": timestamp(binding.created_at),
        "updatedAt": timestamp(binding.updated_at),
    })
}

fn runtime_driver_hint(runtime_type: &str) -> Option<&'static str> {
    match runtime_type.trim().to_ascii_lowercase().as_str() {
        "elixir" | "runtime" => Some("elixir"),
        "legacy" | "laravel" | "openagents.com" => Some("legacy"),
        _ => None,
    }
}

fn resolve_tool_names(
    available_tool_names: &[String],
    allowlist: &[String],
    denylist: &[String],
) -> (Vec<String>, Vec<String>, Vec<String>) {
    let mut candidate = Vec::new();
    let mut removed_by_allowlist = Vec::new();
    for name in available_tool_names {
        if !allowlist.is_empty() && !allowlist.contains(name) {
            removed_by_allowlist.push(name.clone());
            continue;
        }
        candidate.push(name.clone());
    }

    let mut exposed = Vec::new();
    let mut removed_by_denylist = Vec::new();
    for name in candidate {
        if denylist.contains(&name) {
            removed_by_denylist.push(name);
            continue;
        }
        exposed.push(name);
    }

    (exposed, removed_by_allowlist, removed_by_denylist)
}

fn tool_name_list_from_static(values: &[&str]) -> Vec<String> {
    let mut names = Vec::new();
    for value in values {
        if let Some(normalized) = normalize_tool_name(value) {
            if !names.contains(&normalized) {
                names.push(normalized);
            }
        }
    }
    names
}

fn tool_name_list(values: &[String]) -> Vec<String> {
    let mut names = Vec::new();
    for value in values {
        if let Some(normalized) = normalize_tool_name(value) {
            if !names.contains(&normalized) {
                names.push(normalized);
            }
        }
    }
    names
}

fn normalize_tool_name(value: &str) -> Option<String> {
    let normalized = value.trim().to_ascii_lowercase();
    non_empty(normalized)
}

fn value_string_array(value: Option<&serde_json::Value>) -> Vec<String> {
    value
        .and_then(serde_json::Value::as_array)
        .map(|entries| {
            entries
                .iter()
                .filter_map(|entry| entry.as_str().and_then(|raw| non_empty(raw.to_string())))
                .collect::<Vec<_>>()
        })
        .unwrap_or_default()
}

fn user_handle_from_email(email: &str) -> String {
    let local = email.split('@').next().unwrap_or_default();
    let mut output = String::with_capacity(local.len().min(64));
    let mut previous_dash = false;
    for character in local.chars() {
        let normalized = character.to_ascii_lowercase();
        if normalized.is_ascii_alphanumeric() {
            output.push(normalized);
            previous_dash = false;
            continue;
        }

        if !previous_dash {
            output.push('-');
            previous_dash = true;
        }
    }

    let trimmed = output.trim_matches('-');
    if trimmed.is_empty() {
        "user".to_string()
    } else {
        trimmed.chars().take(64).collect()
    }
}

fn thread_title(thread_id: &str, message_count: u32) -> String {
    if message_count == 0 {
        return "New Chat".to_string();
    }

    let normalized = thread_id.trim();
    if normalized.is_empty() {
        "Chat".to_string()
    } else {
        format!("Thread {normalized}")
    }
}

fn parse_rfc3339_utc(value: &str) -> Result<chrono::DateTime<Utc>, chrono::ParseError> {
    chrono::DateTime::parse_from_rfc3339(value).map(|parsed| parsed.with_timezone(&Utc))
}

fn resolve_session_revocation_target(
    payload: &RevokeSessionsRequest,
) -> Result<SessionRevocationTarget, (StatusCode, Json<ApiErrorResponse>)> {
    let session_id = payload.session_id.clone().and_then(non_empty);
    let device_id = payload.device_id.clone().and_then(non_empty);
    let revoke_all = payload.revoke_all_sessions.unwrap_or(false);

    let mut count = 0u8;
    if session_id.is_some() {
        count += 1;
    }
    if device_id.is_some() {
        count += 1;
    }
    if revoke_all {
        count += 1;
    }

    if count != 1 {
        return Err(validation_error(
            "target",
            "Provide exactly one revocation target: session_id, device_id, or revoke_all_sessions=true.",
        ));
    }

    if let Some(value) = session_id {
        return Ok(SessionRevocationTarget::SessionId(value));
    }
    if let Some(value) = device_id {
        return Ok(SessionRevocationTarget::DeviceId(value));
    }

    Ok(SessionRevocationTarget::AllSessions)
}

fn revocation_reason_label(reason: SessionRevocationReason) -> &'static str {
    reason.as_str()
}

fn timestamp(value: chrono::DateTime<Utc>) -> String {
    value.to_rfc3339_opts(SecondsFormat::Secs, true)
}

fn header_value(raw: &str) -> Result<HeaderValue, (StatusCode, Json<ApiErrorResponse>)> {
    HeaderValue::from_str(raw).map_err(|_| {
        error_response_with_status(
            StatusCode::INTERNAL_SERVER_ERROR,
            ApiErrorCode::InternalError,
            "Failed to build response headers.".to_string(),
        )
    })
}

#[cfg(test)]
mod tests {
    use std::net::SocketAddr;
    use std::path::PathBuf;
    use std::sync::Arc;

    use anyhow::Result;
    use axum::body::{Body, Bytes};
    use axum::extract::State;
    use axum::http::HeaderMap;
    use axum::http::header::{
        ACCEPT_ENCODING, CACHE_CONTROL, CONTENT_ENCODING, CONTENT_TYPE, ETAG, IF_NONE_MATCH,
        SET_COOKIE,
    };
    use axum::http::{HeaderValue, Request, StatusCode};
    use axum::routing::{get, post};
    use axum::{Json, Router};
    use base64::Engine as _;
    use chrono::{Duration, Utc};
    use hmac::Mac;
    use http_body_util::BodyExt;
    use serde_json::{Value, json};
    use tempfile::tempdir;
    use tokio::net::TcpListener;
    use tokio::sync::Mutex;
    use tokio::task::JoinHandle;
    use tower::ServiceExt;

    use crate::build_router;
    use crate::build_router_with_observability;
    use crate::config::Config;
    use crate::domain_store::{
        AutopilotAggregate, AutopilotPolicyRecord, AutopilotProfileRecord, AutopilotRecord,
        AutopilotRuntimeBindingRecord, CreateAutopilotInput, CreateL402PaywallInput, DomainStore,
        RecordL402GatewayEventInput, RecordL402ReceiptInput, UpsertGoogleIntegrationInput,
        UpsertResendIntegrationInput, UpsertUserSparkWalletInput,
    };
    use crate::observability::{Observability, RecordingAuditSink};
    use crate::{
        CACHE_IMMUTABLE_ONE_YEAR, CACHE_MANIFEST, CACHE_SHORT_LIVED, MAINTENANCE_CACHE_CONTROL,
    };

    fn test_config(static_dir: PathBuf) -> Config {
        Config::for_tests(static_dir)
    }

    fn workos_required_config(static_dir: PathBuf) -> Config {
        let mut config = test_config(static_dir);
        config.auth_provider_mode = "workos".to_string();
        config.workos_client_id = None;
        config.workos_api_key = None;
        config
    }

    fn compat_enforced_config(static_dir: PathBuf) -> Config {
        let mut config = test_config(static_dir);
        config.compat_control_enforced = true;
        config.compat_control_protocol_version = "openagents.control.v1".to_string();
        config.compat_control_min_client_build_id = "20260221T120000Z".to_string();
        config.compat_control_max_client_build_id = Some("20260221T180000Z".to_string());
        config.compat_control_min_schema_version = 1;
        config.compat_control_max_schema_version = 1;
        config
    }

    fn maintenance_enabled_config(static_dir: PathBuf) -> Config {
        let mut config = test_config(static_dir);
        config.maintenance_mode_enabled = true;
        config.maintenance_bypass_token = Some("maintenance-token".to_string());
        config.maintenance_bypass_cookie_name = "oa_maintenance_bypass".to_string();
        config.maintenance_bypass_cookie_ttl_seconds = 300;
        config.maintenance_allowed_paths = vec!["/healthz".to_string(), "/readyz".to_string()];
        config
    }

    fn test_app_state(config: Config) -> super::AppState {
        let auth = super::AuthService::from_config(&config);
        let route_split = super::RouteSplitService::from_config(&config);
        let runtime_routing = super::RuntimeRoutingService::from_config(&config);
        let khala_token_issuer = super::KhalaTokenIssuer::from_config(&config);
        let sync_token_issuer = super::SyncTokenIssuer::from_config(&config);
        let codex_thread_store = super::CodexThreadStore::from_config(&config);
        let domain_store = super::DomainStore::from_config(&config);
        let runtime_revocation_client = super::RuntimeRevocationClient::from_config(&config);
        super::AppState {
            config: Arc::new(config),
            auth,
            observability: Observability::default(),
            route_split,
            runtime_routing,
            khala_token_issuer,
            sync_token_issuer,
            codex_thread_store,
            _domain_store: domain_store,
            runtime_revocation_client,
            throttle_state: super::ThrottleState::default(),
            codex_control_receipts: super::CodexControlReceiptState::default(),
            runtime_tool_receipts: super::RuntimeToolReceiptState::default(),
            runtime_skill_registry: super::RuntimeSkillRegistryState::default(),
            runtime_workers: super::RuntimeWorkerState::default(),
            lightning_ops_control_plane: super::LightningOpsControlPlaneState::default(),
            runtime_internal_nonces: super::RuntimeInternalNonceState::default(),
            google_oauth_states: super::GoogleOauthStateStore::default(),
            started_at: std::time::SystemTime::now(),
        }
    }

    fn runtime_internal_signed_headers(
        body: &str,
        secret: &str,
        key_id: &str,
        nonce: &str,
        timestamp: i64,
    ) -> Result<HeaderMap> {
        let body_hash = super::sha256_hex(body.as_bytes());
        let signing_payload = format!("{timestamp}\n{nonce}\n{body_hash}");
        let mut mac = super::HmacSha256::new_from_slice(secret.as_bytes())?;
        mac.update(signing_payload.as_bytes());
        let signature = super::sha256_bytes_hex(&mac.finalize().into_bytes());

        let mut headers = HeaderMap::new();
        headers.insert(
            super::RUNTIME_INTERNAL_KEY_ID_HEADER,
            HeaderValue::from_str(key_id)?,
        );
        headers.insert(
            super::RUNTIME_INTERNAL_TIMESTAMP_HEADER,
            HeaderValue::from_str(&timestamp.to_string())?,
        );
        headers.insert(
            super::RUNTIME_INTERNAL_NONCE_HEADER,
            HeaderValue::from_str(nonce)?,
        );
        headers.insert(
            super::RUNTIME_INTERNAL_BODY_HASH_HEADER,
            HeaderValue::from_str(&body_hash)?,
        );
        headers.insert(
            super::RUNTIME_INTERNAL_SIGNATURE_HEADER,
            HeaderValue::from_str(&signature)?,
        );
        Ok(headers)
    }

    fn runtime_internal_signed_request(
        path: &str,
        body: &str,
        headers: &HeaderMap,
    ) -> Result<Request<Body>> {
        let mut builder = Request::builder()
            .method("POST")
            .uri(path)
            .header("content-type", "application/json");
        for (name, value) in headers {
            builder = builder.header(name, value);
        }
        Ok(builder.body(Body::from(body.to_string()))?)
    }

    fn sample_autopilot_aggregate() -> AutopilotAggregate {
        let now = Utc::now();
        AutopilotAggregate {
            autopilot: AutopilotRecord {
                id: "ap_test_1".to_string(),
                owner_user_id: "usr_test_1".to_string(),
                handle: "test-pilot".to_string(),
                display_name: "Test Pilot".to_string(),
                avatar: None,
                status: "active".to_string(),
                visibility: "private".to_string(),
                tagline: Some("Pragmatic and concise".to_string()),
                config_version: 3,
                deleted_at: None,
                created_at: now,
                updated_at: now,
            },
            profile: AutopilotProfileRecord {
                autopilot_id: "ap_test_1".to_string(),
                owner_display_name: "Chris".to_string(),
                persona_summary: Some("Pragmatic and concise".to_string()),
                autopilot_voice: Some("calm and direct".to_string()),
                principles: Some(json!(["be concise", "be direct"])),
                preferences: Some(json!({
                    "user": {
                        "addressAs": "Chris",
                        "timeZone": "UTC"
                    },
                    "character": {
                        "boundaries": ["No fluff", "No hype"]
                    }
                })),
                onboarding_answers: json!({
                    "bootstrapState": {
                        "status": "ready",
                        "stage": "profile"
                    }
                }),
                schema_version: 1,
                created_at: now,
                updated_at: now,
            },
            policy: AutopilotPolicyRecord {
                autopilot_id: "ap_test_1".to_string(),
                model_provider: None,
                model: None,
                tool_allowlist: vec![
                    "openagents_api".to_string(),
                    "lightning_l402_fetch".to_string(),
                ],
                tool_denylist: vec!["lightning_l402_fetch".to_string()],
                l402_require_approval: true,
                l402_max_spend_msats_per_call: Some(100_000),
                l402_max_spend_msats_per_day: Some(500_000),
                l402_allowed_hosts: vec!["sats4ai.com".to_string()],
                data_policy: Some(json!(["redact_secrets"])),
                created_at: now,
                updated_at: now,
            },
            runtime_bindings: vec![
                AutopilotRuntimeBindingRecord {
                    id: "arb_primary".to_string(),
                    autopilot_id: "ap_test_1".to_string(),
                    runtime_type: "runtime".to_string(),
                    runtime_ref: Some("desktopw:autopilot".to_string()),
                    is_primary: true,
                    last_seen_at: Some(now),
                    meta: Some(json!({"region":"us-central1"})),
                    created_at: now,
                    updated_at: now,
                },
                AutopilotRuntimeBindingRecord {
                    id: "arb_secondary".to_string(),
                    autopilot_id: "ap_test_1".to_string(),
                    runtime_type: "legacy".to_string(),
                    runtime_ref: Some("legacy:autopilot".to_string()),
                    is_primary: false,
                    last_seen_at: None,
                    meta: None,
                    created_at: now,
                    updated_at: now,
                },
            ],
        }
    }

    async fn read_json(response: axum::response::Response) -> Result<Value> {
        let bytes = response.into_body().collect().await?.to_bytes();
        let value = serde_json::from_slice::<Value>(&bytes)?;
        Ok(value)
    }

    async fn read_text(response: axum::response::Response) -> Result<String> {
        let bytes = response.into_body().collect().await?.to_bytes();
        Ok(String::from_utf8(bytes.to_vec())?)
    }

    fn sse_event_types(wire: &str) -> Vec<String> {
        let mut events = Vec::new();
        for line in wire.lines() {
            let Some(payload) = line.strip_prefix("data:") else {
                continue;
            };
            let payload = payload.trim();
            if payload == "[DONE]" {
                continue;
            }
            let Ok(parsed) = serde_json::from_str::<Value>(payload) else {
                continue;
            };
            if let Some(kind) = parsed.get("type").and_then(Value::as_str) {
                events.push(kind.to_string());
            }
        }
        events
    }

    fn sse_done_count(wire: &str) -> usize {
        wire.lines()
            .filter(|line| line.trim() == "data: [DONE]")
            .count()
    }

    fn legacy_stream_request(
        path: &str,
        access_token: Option<&str>,
        body: &str,
    ) -> Result<Request<Body>> {
        let mut builder = Request::builder()
            .method("POST")
            .uri(path)
            .header("content-type", "application/json")
            .header("x-oa-client-build-id", "20260221T130000Z")
            .header("x-oa-protocol-version", "openagents.control.v1")
            .header("x-oa-schema-version", "1");
        if let Some(token) = access_token {
            builder = builder.header("authorization", format!("Bearer {token}"));
        }
        Ok(builder.body(Body::from(body.to_string()))?)
    }

    fn cookie_value(response: &axum::response::Response) -> Option<String> {
        let header = response.headers().get(SET_COOKIE)?;
        let raw = header.to_str().ok()?;
        raw.split(';').next().map(|value| value.to_string())
    }

    fn all_set_cookie_values(response: &axum::response::Response) -> Vec<String> {
        response
            .headers()
            .get_all(SET_COOKIE)
            .iter()
            .filter_map(|value| value.to_str().ok())
            .map(ToString::to_string)
            .collect()
    }

    fn cookie_from_set_cookie_header(set_cookie: &str) -> Option<String> {
        set_cookie.split(';').next().map(|value| value.to_string())
    }

    fn cookie_value_for_name(response: &axum::response::Response, name: &str) -> Option<String> {
        all_set_cookie_values(response)
            .into_iter()
            .filter_map(|set_cookie| cookie_from_set_cookie_header(&set_cookie))
            .find_map(|cookie| {
                let mut parts = cookie.splitn(2, '=');
                let key = parts.next().unwrap_or_default();
                let value = parts.next().unwrap_or_default();
                if key == name && !value.is_empty() {
                    Some(value.to_string())
                } else {
                    None
                }
            })
    }

    fn signed_test_login_url(
        signing_key: &str,
        email: &str,
        expires: i64,
        name: Option<&str>,
    ) -> String {
        let mut unsigned = format!("/internal/test-login?email={email}&expires={expires}");
        if let Some(value) = name {
            unsigned.push_str("&name=");
            unsigned.push_str(value);
        }

        let mut mac =
            super::HmacSha256::new_from_slice(signing_key.as_bytes()).expect("valid signing key");
        mac.update(unsigned.as_bytes());
        let signature = super::sha256_bytes_hex(&mac.finalize().into_bytes());
        format!("{unsigned}&signature={signature}")
    }

    async fn start_runtime_revocation_stub(
        captured: Arc<Mutex<Vec<Value>>>,
    ) -> Result<(SocketAddr, JoinHandle<()>)> {
        let app = Router::new()
            .route(
                "/internal/v1/sync/sessions/revoke",
                post(
                    |State(captured): State<Arc<Mutex<Vec<Value>>>>,
                     headers: HeaderMap,
                     Json(payload): Json<Value>| async move {
                        let signature = headers
                            .get("x-oa-runtime-signature")
                            .and_then(|value| value.to_str().ok())
                            .unwrap_or_default()
                            .to_string();

                        captured.lock().await.push(json!({
                            "signature": signature,
                            "payload": payload,
                        }));

                        (StatusCode::OK, Json(json!({"data": {"ok": true}})))
                    },
                ),
            )
            .with_state(captured);

        let listener = TcpListener::bind("127.0.0.1:0").await?;
        let addr = listener.local_addr()?;

        let handle = tokio::spawn(async move {
            axum::serve(listener, app.into_make_service())
                .await
                .expect("runtime revocation stub server failed");
        });

        Ok((addr, handle))
    }

    async fn start_runtime_comms_delivery_stub(
        statuses: Arc<Mutex<Vec<u16>>>,
        captured: Arc<Mutex<Vec<Value>>>,
    ) -> Result<(SocketAddr, JoinHandle<()>)> {
        #[derive(Clone)]
        struct StubState {
            statuses: Arc<Mutex<Vec<u16>>>,
            captured: Arc<Mutex<Vec<Value>>>,
        }

        let stub_state = StubState { statuses, captured };
        let app = Router::new()
            .route(
                "/internal/v1/comms/delivery-events",
                post(
                    |State(stub_state): State<StubState>, Json(payload): Json<Value>| async move {
                        stub_state.captured.lock().await.push(payload);
                        let status_code = {
                            let mut statuses = stub_state.statuses.lock().await;
                            if statuses.is_empty() {
                                202
                            } else {
                                statuses.remove(0)
                            }
                        };
                        if status_code < 300 {
                            (
                                StatusCode::from_u16(status_code).unwrap_or(StatusCode::ACCEPTED),
                                Json(json!({
                                    "eventId": "evt_runtime_projection",
                                    "status": "accepted",
                                    "idempotentReplay": false
                                })),
                            )
                        } else {
                            (
                                StatusCode::from_u16(status_code)
                                    .unwrap_or(StatusCode::INTERNAL_SERVER_ERROR),
                                Json(json!({
                                    "error": "temporary"
                                })),
                            )
                        }
                    },
                ),
            )
            .with_state(stub_state);

        let listener = TcpListener::bind("127.0.0.1:0").await?;
        let addr = listener.local_addr()?;
        let handle = tokio::spawn(async move {
            axum::serve(listener, app.into_make_service())
                .await
                .expect("runtime comms delivery stub server failed");
        });

        Ok((addr, handle))
    }

    fn signed_resend_webhook_headers(
        payload: &str,
        webhook_secret: &str,
        svix_id: &str,
        svix_timestamp: i64,
    ) -> HeaderMap {
        let secret_bytes = super::resolve_resend_webhook_secret_bytes(webhook_secret);
        let signed_content = format!("{svix_id}.{svix_timestamp}.{payload}");
        let mut mac =
            super::HmacSha256::new_from_slice(secret_bytes.as_slice()).expect("valid hmac key");
        mac.update(signed_content.as_bytes());
        let signature =
            base64::engine::general_purpose::STANDARD.encode(mac.finalize().into_bytes());

        let mut headers = HeaderMap::new();
        headers.insert(
            "svix-id",
            HeaderValue::from_str(svix_id).expect("svix id header"),
        );
        headers.insert(
            "svix-timestamp",
            HeaderValue::from_str(&svix_timestamp.to_string()).expect("svix timestamp header"),
        );
        headers.insert(
            "svix-signature",
            HeaderValue::from_str(&format!("v1,{signature}")).expect("svix signature header"),
        );
        headers
    }

    async fn wait_for_webhook_status(
        state: &super::AppState,
        idempotency_key: &str,
        expected_status: &str,
    ) -> Result<()> {
        for _ in 0..100 {
            let current = state
                ._domain_store
                .webhook_event_by_idempotency_key(idempotency_key)
                .await?;
            if current
                .as_ref()
                .map(|event| event.status.as_str() == expected_status)
                .unwrap_or(false)
            {
                return Ok(());
            }
            tokio::time::sleep(std::time::Duration::from_millis(10)).await;
        }

        anyhow::bail!("timed out waiting for webhook status {expected_status}");
    }

    async fn start_google_oauth_token_stub(
        captured_bodies: Arc<Mutex<Vec<String>>>,
    ) -> Result<(SocketAddr, JoinHandle<()>)> {
        let app = Router::new()
            .route(
                "/oauth2/token",
                post(
                    |State(captured_bodies): State<Arc<Mutex<Vec<String>>>>, body: String| async move {
                        captured_bodies.lock().await.push(body);
                        (
                            StatusCode::OK,
                            Json(json!({
                                "refresh_token": "refresh_token_1234567890",
                                "access_token": "access_token_abcdef",
                                "scope": "https://www.googleapis.com/auth/gmail.readonly",
                                "token_type": "Bearer",
                                "expires_in": 3600,
                            })),
                        )
                    },
                ),
            )
            .with_state(captured_bodies);

        let listener = TcpListener::bind("127.0.0.1:0").await?;
        let addr = listener.local_addr()?;

        let handle = tokio::spawn(async move {
            axum::serve(listener, app.into_make_service())
                .await
                .expect("google oauth token stub server failed");
        });

        Ok((addr, handle))
    }

    async fn start_gmail_inbox_stub(
        token_calls: Arc<Mutex<Vec<String>>>,
        send_calls: Arc<Mutex<Vec<Value>>>,
    ) -> Result<(SocketAddr, JoinHandle<()>)> {
        #[derive(Clone)]
        struct GmailStubState {
            token_calls: Arc<Mutex<Vec<String>>>,
            send_calls: Arc<Mutex<Vec<Value>>>,
        }

        let state = GmailStubState {
            token_calls,
            send_calls,
        };
        let app = Router::new()
            .route(
                "/oauth2/token",
                post(
                    |State(state): State<GmailStubState>, body: String| async move {
                        state.token_calls.lock().await.push(body);
                        (
                            StatusCode::OK,
                            Json(json!({
                                "access_token": "fresh_access_token",
                                "token_type": "Bearer",
                                "scope": "https://www.googleapis.com/auth/gmail.readonly https://www.googleapis.com/auth/gmail.send",
                                "expires_in": 3600
                            })),
                        )
                    },
                ),
            )
            .route(
                "/gmail/v1/users/me/threads",
                get(|headers: HeaderMap| async move {
                    let auth = headers
                        .get("authorization")
                        .and_then(|value| value.to_str().ok())
                        .unwrap_or_default()
                        .to_string();
                    if auth.contains("stale_access_token") {
                        return (
                            StatusCode::UNAUTHORIZED,
                            Json(json!({"error": {"message": "expired"}})),
                        );
                    }
                    (
                        StatusCode::OK,
                        Json(json!({
                            "threads": [
                                { "id": "thread_1" }
                            ]
                        })),
                    )
                }),
            )
            .route(
                "/gmail/v1/users/me/threads/:thread_id",
                get(
                    |axum::extract::Path(thread_id): axum::extract::Path<String>,
                     headers: HeaderMap| async move {
                        let auth = headers
                            .get("authorization")
                            .and_then(|value| value.to_str().ok())
                            .unwrap_or_default()
                            .to_string();
                        if auth.contains("stale_access_token") {
                            return (
                                StatusCode::UNAUTHORIZED,
                                Json(json!({"error": {"message": "expired"}})),
                            );
                        }

                        let body = base64::engine::general_purpose::URL_SAFE_NO_PAD
                            .encode("Can we move tomorrow's walkthrough to next week?");
                        (
                            StatusCode::OK,
                            Json(json!({
                                "id": thread_id,
                                "snippet": "Can we move tomorrow's call to next week?",
                                "messages": [
                                    {
                                        "id": "gmail_msg_1",
                                        "snippet": "Can we move tomorrow's call to next week?",
                                        "internalDate": "1765584000000",
                                        "payload": {
                                            "headers": [
                                                {"name": "Subject", "value": "Can we reschedule the walkthrough?"},
                                                {"name": "From", "value": "alex@acme.com"},
                                                {"name": "To", "value": "you@openagents.com"}
                                            ],
                                            "body": {"data": body}
                                        }
                                    }
                                ]
                            })),
                        )
                    },
                ),
            )
            .route(
                "/gmail/v1/users/me/messages/send",
                post(
                    |State(state): State<GmailStubState>, Json(payload): Json<Value>| async move {
                        state.send_calls.lock().await.push(payload);
                        (
                            StatusCode::OK,
                            Json(json!({
                                "id": "gmail_msg_sent_1",
                                "threadId": "thread_1"
                            })),
                        )
                    },
                ),
            )
            .with_state(state);

        let listener = TcpListener::bind("127.0.0.1:0").await?;
        let addr = listener.local_addr()?;
        let handle = tokio::spawn(async move {
            axum::serve(listener, app.into_make_service())
                .await
                .expect("gmail inbox stub server failed");
        });

        Ok((addr, handle))
    }

    async fn authenticate_token(app: Router, email: &str) -> Result<String> {
        let send_request = Request::builder()
            .method("POST")
            .uri("/api/auth/email")
            .header("content-type", "application/json")
            .body(Body::from(json!({ "email": email }).to_string()))?;
        let send_response = app.clone().oneshot(send_request).await?;
        let cookie = cookie_value(&send_response).unwrap_or_default();

        let verify_request = Request::builder()
            .method("POST")
            .uri("/api/auth/verify")
            .header("content-type", "application/json")
            .header("x-client", "autopilot-ios")
            .header("cookie", cookie)
            .body(Body::from(r#"{"code":"123456"}"#))?;
        let verify_response = app.oneshot(verify_request).await?;
        let verify_body = read_json(verify_response).await?;

        Ok(verify_body["token"]
            .as_str()
            .unwrap_or_default()
            .to_string())
    }

    async fn authenticated_user_id(app: Router, token: &str) -> Result<String> {
        let request = Request::builder()
            .method("GET")
            .uri("/api/auth/session")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let response = app.oneshot(request).await?;
        let body = read_json(response).await?;
        Ok(body["data"]["user"]["id"]
            .as_str()
            .unwrap_or_default()
            .to_string())
    }

    struct L402Fixture {
        token: String,
        autopilot_id: String,
        autopilot_handle: String,
        paid_receipt_event_id: u64,
    }

    async fn seed_local_test_token(config: &Config, email: &str) -> Result<String> {
        let auth = super::AuthService::from_config(config);
        let verify = auth
            .local_test_sign_in(email.to_string(), None, Some("autopilot-ios"), None)
            .await?;
        Ok(verify.access_token)
    }

    async fn seed_l402_fixture(config: &Config, email: &str) -> Result<L402Fixture> {
        let auth = super::AuthService::from_config(config);
        let verify = auth
            .local_test_sign_in(email.to_string(), None, Some("autopilot-ios"), None)
            .await?;
        let user_id = verify.user.id.clone();
        let token = verify.access_token.clone();

        let store = super::DomainStore::from_config(config);
        let autopilot = store
            .create_autopilot(CreateAutopilotInput {
                owner_user_id: user_id.clone(),
                owner_display_name: "Owner".to_string(),
                display_name: "Payments Bot".to_string(),
                handle_seed: None,
                avatar: None,
                status: None,
                visibility: None,
                tagline: None,
            })
            .await
            .expect("create autopilot");

        store
            .upsert_user_spark_wallet(UpsertUserSparkWalletInput {
                user_id: user_id.clone(),
                wallet_id: "wallet_123".to_string(),
                mnemonic: "mnemonic words".to_string(),
                spark_address: Some("spark:abc".to_string()),
                lightning_address: Some("ln@openagents.com".to_string()),
                identity_pubkey: Some("pubkey_1".to_string()),
                last_balance_sats: Some(4200),
                status: Some("active".to_string()),
                provider: Some("spark_executor".to_string()),
                last_error: None,
                meta: None,
                last_synced_at: Some(Utc::now()),
            })
            .await
            .expect("seed wallet");

        let paid_receipt = store
            .record_l402_receipt(RecordL402ReceiptInput {
                user_id: user_id.clone(),
                thread_id: "thread_1".to_string(),
                run_id: "run_1".to_string(),
                autopilot_id: Some(autopilot.autopilot.id.clone()),
                thread_title: Some("Conversation 1".to_string()),
                run_status: Some("completed".to_string()),
                run_started_at: Some(Utc::now()),
                run_completed_at: Some(Utc::now()),
                payload: json!({
                    "status": "paid",
                    "host": "sats4ai.com",
                    "scope": "fetch",
                    "paid": true,
                    "amountMsats": 2100,
                    "cacheHit": false,
                    "approvalRequired": false,
                }),
                created_at: Some(Utc::now()),
            })
            .await
            .expect("seed paid receipt");

        store
            .record_l402_receipt(RecordL402ReceiptInput {
                user_id: user_id.clone(),
                thread_id: "thread_2".to_string(),
                run_id: "run_2".to_string(),
                autopilot_id: Some(autopilot.autopilot.id.clone()),
                thread_title: Some("Conversation 2".to_string()),
                run_status: Some("completed".to_string()),
                run_started_at: Some(Utc::now()),
                run_completed_at: Some(Utc::now()),
                payload: json!({
                    "status": "cached",
                    "host": "sats4ai.com",
                    "scope": "fetch",
                    "paid": false,
                    "cacheStatus": "hit",
                    "cacheHit": true,
                }),
                created_at: Some(Utc::now()),
            })
            .await
            .expect("seed cached receipt");

        store
            .record_l402_receipt(RecordL402ReceiptInput {
                user_id: user_id.clone(),
                thread_id: "thread_3".to_string(),
                run_id: "run_3".to_string(),
                autopilot_id: None,
                thread_title: Some("Conversation 3".to_string()),
                run_status: Some("failed".to_string()),
                run_started_at: Some(Utc::now()),
                run_completed_at: Some(Utc::now()),
                payload: json!({
                    "status": "blocked",
                    "paid": false,
                    "denyCode": "policy_denied",
                }),
                created_at: Some(Utc::now()),
            })
            .await
            .expect("seed blocked receipt");

        store
            .record_l402_gateway_event(RecordL402GatewayEventInput {
                user_id: user_id.clone(),
                autopilot_id: Some(autopilot.autopilot.id.clone()),
                event_type: "l402_gateway_event".to_string(),
                payload: json!({"status":"ok"}),
                created_at: Some(Utc::now()),
            })
            .await
            .expect("seed gateway event");

        store
            .record_l402_gateway_event(RecordL402GatewayEventInput {
                user_id: user_id.clone(),
                autopilot_id: None,
                event_type: "unrelated_event".to_string(),
                payload: json!({"ignored":true}),
                created_at: Some(Utc::now()),
            })
            .await
            .expect("seed non-l402 event");

        Ok(L402Fixture {
            token,
            autopilot_id: autopilot.autopilot.id,
            autopilot_handle: autopilot.autopilot.handle,
            paid_receipt_event_id: paid_receipt.id,
        })
    }

    #[tokio::test]
    async fn healthz_route_returns_ok() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let request = Request::builder().uri("/healthz").body(Body::empty())?;
        let response = app.oneshot(request).await?;

        assert_eq!(response.status(), StatusCode::OK);
        let body = read_json(response).await?;
        assert_eq!(body["status"], "ok");
        assert_eq!(body["service"], "openagents-control-service");
        assert_eq!(body["auth_provider"], "mock");
        Ok(())
    }

    #[tokio::test]
    async fn api_preflight_options_returns_cors_headers_without_auth() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let request = Request::builder()
            .method("OPTIONS")
            .uri("/api/settings/profile")
            .header("origin", "https://console.openagents.com")
            .header("access-control-request-method", "PATCH")
            .header(
                "access-control-request-headers",
                "authorization,content-type",
            )
            .body(Body::empty())?;
        let response = app.oneshot(request).await?;

        assert_eq!(response.status(), StatusCode::NO_CONTENT);
        assert_eq!(
            response
                .headers()
                .get("access-control-allow-origin")
                .and_then(|value| value.to_str().ok()),
            Some("https://console.openagents.com")
        );
        let allow_methods = response
            .headers()
            .get("access-control-allow-methods")
            .and_then(|value| value.to_str().ok())
            .unwrap_or_default();
        assert!(allow_methods.contains("OPTIONS"));
        assert!(allow_methods.contains("PATCH"));
        assert_eq!(
            response
                .headers()
                .get(CACHE_CONTROL)
                .and_then(|value| value.to_str().ok()),
            Some(super::CACHE_API_NO_STORE)
        );

        Ok(())
    }

    #[tokio::test]
    async fn auth_email_route_enforces_throttle_limit() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        for _ in 0..super::THROTTLE_AUTH_EMAIL_LIMIT {
            let request = Request::builder()
                .method("POST")
                .uri("/api/auth/email")
                .header("content-type", "application/json")
                .header("x-forwarded-for", "203.0.113.10")
                .body(Body::from(r#"{"email":"throttle@openagents.com"}"#))?;
            let response = app.clone().oneshot(request).await?;
            assert_eq!(response.status(), StatusCode::OK);
        }

        let exceeded = Request::builder()
            .method("POST")
            .uri("/api/auth/email")
            .header("content-type", "application/json")
            .header("x-forwarded-for", "203.0.113.10")
            .body(Body::from(r#"{"email":"throttle@openagents.com"}"#))?;
        let response = app.oneshot(exceeded).await?;
        assert_eq!(response.status(), StatusCode::TOO_MANY_REQUESTS);
        let body = read_json(response).await?;
        assert_eq!(body["error"]["code"], "rate_limited");

        Ok(())
    }

    #[tokio::test]
    async fn auth_email_throttle_is_scoped_per_client_key() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        for _ in 0..super::THROTTLE_AUTH_EMAIL_LIMIT {
            let request = Request::builder()
                .method("POST")
                .uri("/api/auth/email")
                .header("content-type", "application/json")
                .header("x-forwarded-for", "203.0.113.10")
                .body(Body::from(r#"{"email":"throttle-a@openagents.com"}"#))?;
            let response = app.clone().oneshot(request).await?;
            assert_eq!(response.status(), StatusCode::OK);
        }

        let second_key_request = Request::builder()
            .method("POST")
            .uri("/api/auth/email")
            .header("content-type", "application/json")
            .header("x-forwarded-for", "198.51.100.22")
            .body(Body::from(r#"{"email":"throttle-b@openagents.com"}"#))?;
        let second_key_response = app.clone().oneshot(second_key_request).await?;
        assert_eq!(second_key_response.status(), StatusCode::OK);

        let exceeded_primary = Request::builder()
            .method("POST")
            .uri("/api/auth/email")
            .header("content-type", "application/json")
            .header("x-forwarded-for", "203.0.113.10")
            .body(Body::from(r#"{"email":"throttle-a@openagents.com"}"#))?;
        let exceeded_response = app.oneshot(exceeded_primary).await?;
        assert_eq!(exceeded_response.status(), StatusCode::TOO_MANY_REQUESTS);

        Ok(())
    }

    #[tokio::test]
    async fn thread_message_route_enforces_throttle_limit() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token = authenticate_token(app.clone(), "thread-throttle@openagents.com").await?;

        for index in 0..super::THROTTLE_THREAD_MESSAGE_LIMIT {
            let request = Request::builder()
                .method("POST")
                .uri("/api/runtime/threads/thread-1/messages")
                .header("content-type", "application/json")
                .header("authorization", format!("Bearer {token}"))
                .header("x-forwarded-for", "198.51.100.22")
                .body(Body::from(format!(r#"{{"text":"message-{index}"}}"#)))?;
            let response = app.clone().oneshot(request).await?;
            assert_eq!(response.status(), StatusCode::OK);
        }

        let exceeded = Request::builder()
            .method("POST")
            .uri("/api/runtime/threads/thread-1/messages")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .header("x-forwarded-for", "198.51.100.22")
            .body(Body::from(r#"{"text":"over-limit"}"#))?;
        let response = app.oneshot(exceeded).await?;
        assert_eq!(response.status(), StatusCode::TOO_MANY_REQUESTS);
        let body = read_json(response).await?;
        assert_eq!(body["error"]["code"], "rate_limited");

        Ok(())
    }

    #[tokio::test]
    async fn route_split_override_requires_admin_email() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;

        let mut config = test_config(static_dir.path().to_path_buf());
        config.admin_emails = vec!["admin@openagents.com".to_string()];
        let app = build_router(config);
        let token = authenticate_token(app.clone(), "not-admin@openagents.com").await?;

        let request = Request::builder()
            .method("POST")
            .uri("/api/v1/control/route-split/override")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(r#"{"target":"legacy"}"#))?;
        let response = app.oneshot(request).await?;
        assert_eq!(response.status(), StatusCode::FORBIDDEN);
        let body = read_json(response).await?;
        assert_eq!(body["error"]["code"], "forbidden");

        Ok(())
    }

    #[tokio::test]
    async fn route_split_htmx_override_requires_domain() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let app = build_router(test_config(static_dir.path().to_path_buf()));
        let token = authenticate_token(app.clone(), "routes@openagents.com").await?;

        let request = Request::builder()
            .method("POST")
            .uri("/api/v1/control/route-split/override")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(r#"{"target":"htmx_full_page"}"#))?;
        let response = app.oneshot(request).await?;
        assert_eq!(response.status(), StatusCode::UNPROCESSABLE_ENTITY);

        let body = read_json(response).await?;
        assert_eq!(body["error"]["code"], json!("invalid_request"));
        assert!(
            body["error"]["message"]
                .as_str()
                .unwrap_or_default()
                .contains("Domain is required")
        );

        Ok(())
    }

    #[tokio::test]
    async fn runtime_internal_signature_validation_rejects_nonce_replay() -> Result<()> {
        let mut config = test_config(std::env::temp_dir());
        config.runtime_internal_shared_secret = Some("runtime-internal-secret".to_string());
        config.runtime_internal_key_id = "runtime-internal-v1".to_string();
        config.runtime_internal_signature_ttl_seconds = 60;
        let state = test_app_state(config);

        let body = br#"{"provider":"resend","integration_id":"int_runtime"}"#;
        let timestamp = chrono::Utc::now().timestamp().to_string();
        let nonce = "nonce-runtime-internal-1";
        let body_hash = super::sha256_hex(body);
        let signing_payload = format!("{timestamp}\n{nonce}\n{body_hash}");

        let mut mac =
            super::HmacSha256::new_from_slice(b"runtime-internal-secret").expect("hmac key");
        mac.update(signing_payload.as_bytes());
        let signature = super::sha256_bytes_hex(&mac.finalize().into_bytes());

        let mut headers = HeaderMap::new();
        headers.insert(
            super::RUNTIME_INTERNAL_KEY_ID_HEADER,
            HeaderValue::from_static("runtime-internal-v1"),
        );
        headers.insert(
            super::RUNTIME_INTERNAL_TIMESTAMP_HEADER,
            HeaderValue::from_str(&timestamp)?,
        );
        headers.insert(
            super::RUNTIME_INTERNAL_NONCE_HEADER,
            HeaderValue::from_static(nonce),
        );
        headers.insert(
            super::RUNTIME_INTERNAL_BODY_HASH_HEADER,
            HeaderValue::from_str(&body_hash)?,
        );
        headers.insert(
            super::RUNTIME_INTERNAL_SIGNATURE_HEADER,
            HeaderValue::from_str(&signature)?,
        );

        let first = super::verify_runtime_internal_headers(&state, &headers, body).await;
        assert!(first.is_ok());

        let replay = super::verify_runtime_internal_headers(&state, &headers, body)
            .await
            .expect_err("expected nonce replay rejection");
        assert_eq!(replay.0, StatusCode::UNAUTHORIZED);
        assert_eq!(replay.1.0.error.code, "nonce_replay");
        assert_eq!(replay.1.0.error.message, "nonce replay detected");

        Ok(())
    }

    #[tokio::test]
    async fn runtime_internal_secret_fetch_returns_scoped_secret_for_signed_request() -> Result<()>
    {
        let static_dir = tempdir()?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.runtime_internal_shared_secret = Some("runtime-internal-secret".to_string());
        config.runtime_internal_key_id = "runtime-internal-v1".to_string();
        config.runtime_internal_signature_ttl_seconds = 60;
        config.runtime_internal_secret_cache_ttl_ms = 45_000;
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));

        let store = DomainStore::from_config(&config);
        store
            .upsert_resend_integration(UpsertResendIntegrationInput {
                user_id: "usr_runtime_secret".to_string(),
                api_key: "re_live_1234567890".to_string(),
                sender_email: None,
                sender_name: None,
            })
            .await?;

        let app = build_router(config.clone());
        let body = r#"{"user_id":"usr_runtime_secret","provider":"resend","integration_id":"resend.primary","run_id":"run_123","tool_call_id":"tool_123","org_id":"org_abc"}"#;
        let headers = runtime_internal_signed_headers(
            body,
            "runtime-internal-secret",
            "runtime-internal-v1",
            "nonce-runtime-secret-1",
            Utc::now().timestamp(),
        )?;
        let request = runtime_internal_signed_request(
            &config.runtime_internal_secret_fetch_path,
            body,
            &headers,
        )?;
        let response = app.oneshot(request).await?;
        assert_eq!(response.status(), StatusCode::OK);
        let payload = read_json(response).await?;
        assert_eq!(payload["data"]["provider"], "resend");
        assert_eq!(payload["data"]["secret"], "re_live_1234567890");
        assert_eq!(payload["data"]["cache_ttl_ms"], 45_000);
        assert_eq!(payload["data"]["scope"]["user_id"], "usr_runtime_secret");
        assert_eq!(payload["data"]["scope"]["provider"], "resend");
        assert_eq!(payload["data"]["scope"]["integration_id"], "resend.primary");
        assert_eq!(payload["data"]["scope"]["run_id"], "run_123");
        assert_eq!(payload["data"]["scope"]["tool_call_id"], "tool_123");
        assert_eq!(payload["data"]["scope"]["org_id"], "org_abc");
        assert!(payload["data"]["fetched_at"].as_str().is_some());

        Ok(())
    }

    #[tokio::test]
    async fn runtime_internal_secret_fetch_rejects_invalid_signature_code() -> Result<()> {
        let static_dir = tempdir()?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.runtime_internal_shared_secret = Some("runtime-internal-secret".to_string());
        config.runtime_internal_key_id = "runtime-internal-v1".to_string();
        config.runtime_internal_signature_ttl_seconds = 60;

        let app = build_router(config.clone());
        let body = r#"{"user_id":"usr_runtime_secret","provider":"resend","integration_id":"resend.primary","run_id":"run_123","tool_call_id":"tool_123"}"#;
        let mut headers = runtime_internal_signed_headers(
            body,
            "runtime-internal-secret",
            "runtime-internal-v1",
            "nonce-runtime-secret-invalid",
            Utc::now().timestamp(),
        )?;
        headers.insert(
            super::RUNTIME_INTERNAL_SIGNATURE_HEADER,
            HeaderValue::from_static("invalid-signature"),
        );
        let request = runtime_internal_signed_request(
            &config.runtime_internal_secret_fetch_path,
            body,
            &headers,
        )?;
        let response = app.oneshot(request).await?;
        assert_eq!(response.status(), StatusCode::UNAUTHORIZED);
        let payload = read_json(response).await?;
        assert_eq!(payload["error"]["code"], "invalid_signature");

        Ok(())
    }

    #[tokio::test]
    async fn runtime_internal_secret_fetch_rejects_nonce_replay() -> Result<()> {
        let static_dir = tempdir()?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.runtime_internal_shared_secret = Some("runtime-internal-secret".to_string());
        config.runtime_internal_key_id = "runtime-internal-v1".to_string();
        config.runtime_internal_signature_ttl_seconds = 60;
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));

        let store = DomainStore::from_config(&config);
        store
            .upsert_resend_integration(UpsertResendIntegrationInput {
                user_id: "usr_runtime_secret".to_string(),
                api_key: "re_live_1234567890".to_string(),
                sender_email: None,
                sender_name: None,
            })
            .await?;

        let app = build_router(config.clone());
        let body = r#"{"user_id":"usr_runtime_secret","provider":"resend","integration_id":"resend.primary","run_id":"run_123","tool_call_id":"tool_123"}"#;
        let headers = runtime_internal_signed_headers(
            body,
            "runtime-internal-secret",
            "runtime-internal-v1",
            "nonce-runtime-secret-replay",
            Utc::now().timestamp(),
        )?;

        let first_request = runtime_internal_signed_request(
            &config.runtime_internal_secret_fetch_path,
            body,
            &headers,
        )?;
        let first_response = app.clone().oneshot(first_request).await?;
        assert_eq!(first_response.status(), StatusCode::OK);

        let second_request = runtime_internal_signed_request(
            &config.runtime_internal_secret_fetch_path,
            body,
            &headers,
        )?;
        let second_response = app.oneshot(second_request).await?;
        assert_eq!(second_response.status(), StatusCode::UNAUTHORIZED);
        let second_body = read_json(second_response).await?;
        assert_eq!(second_body["error"]["code"], "nonce_replay");

        Ok(())
    }

    #[tokio::test]
    async fn runtime_internal_secret_fetch_returns_not_found_after_revoke() -> Result<()> {
        let static_dir = tempdir()?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.runtime_internal_shared_secret = Some("runtime-internal-secret".to_string());
        config.runtime_internal_key_id = "runtime-internal-v1".to_string();
        config.runtime_internal_signature_ttl_seconds = 60;
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));

        let store = DomainStore::from_config(&config);
        store
            .upsert_resend_integration(UpsertResendIntegrationInput {
                user_id: "usr_runtime_secret".to_string(),
                api_key: "re_live_1234567890".to_string(),
                sender_email: None,
                sender_name: None,
            })
            .await?;

        let body = r#"{"user_id":"usr_runtime_secret","provider":"resend","integration_id":"resend.primary","run_id":"run_123","tool_call_id":"tool_123"}"#;
        let before_revoke_headers = runtime_internal_signed_headers(
            body,
            "runtime-internal-secret",
            "runtime-internal-v1",
            "nonce-runtime-secret-before-revoke",
            Utc::now().timestamp(),
        )?;
        let app_before_revoke = build_router(config.clone());
        let first_request = runtime_internal_signed_request(
            &config.runtime_internal_secret_fetch_path,
            body,
            &before_revoke_headers,
        )?;
        let first_response = app_before_revoke.oneshot(first_request).await?;
        assert_eq!(first_response.status(), StatusCode::OK);

        let revoked = store
            .revoke_integration("usr_runtime_secret", "resend")
            .await?;
        assert!(revoked.is_some());

        let app_after_revoke = build_router(config.clone());
        let after_revoke_headers = runtime_internal_signed_headers(
            body,
            "runtime-internal-secret",
            "runtime-internal-v1",
            "nonce-runtime-secret-after-revoke",
            Utc::now().timestamp(),
        )?;
        let second_request = runtime_internal_signed_request(
            &config.runtime_internal_secret_fetch_path,
            body,
            &after_revoke_headers,
        )?;
        let second_response = app_after_revoke.oneshot(second_request).await?;
        assert_eq!(second_response.status(), StatusCode::NOT_FOUND);
        let second_body = read_json(second_response).await?;
        assert_eq!(second_body["error"]["code"], "secret_not_found");

        Ok(())
    }

    #[tokio::test]
    async fn readiness_route_is_not_ready_when_static_dir_missing() -> Result<()> {
        let base = tempdir()?;
        let missing_dir = base.path().join("missing-assets");
        let app = build_router(test_config(missing_dir));

        let request = Request::builder().uri("/readyz").body(Body::empty())?;
        let response = app.oneshot(request).await?;

        assert_eq!(response.status(), StatusCode::SERVICE_UNAVAILABLE);
        let body = read_json(response).await?;
        assert_eq!(body["status"], "not_ready");
        Ok(())
    }

    #[tokio::test]
    async fn readiness_route_is_ready_when_static_dir_exists() -> Result<()> {
        let static_dir = tempdir()?;
        let app = build_router(test_config(static_dir.path().to_path_buf()));

        let request = Request::builder().uri("/readyz").body(Body::empty())?;
        let response = app.oneshot(request).await?;

        assert_eq!(response.status(), StatusCode::OK);
        let body = read_json(response).await?;
        assert_eq!(body["status"], "ready");
        Ok(())
    }

    #[tokio::test]
    async fn maintenance_mode_blocks_non_allowed_routes_with_503() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let app = build_router(maintenance_enabled_config(static_dir.path().to_path_buf()));

        let request = Request::builder().uri("/").body(Body::empty())?;
        let response = app.oneshot(request).await?;
        assert_eq!(response.status(), StatusCode::SERVICE_UNAVAILABLE);
        assert_eq!(
            response
                .headers()
                .get(CACHE_CONTROL)
                .and_then(|value| value.to_str().ok()),
            Some(MAINTENANCE_CACHE_CONTROL)
        );

        let body = response.into_body().collect().await?.to_bytes();
        let html = String::from_utf8_lossy(&body);
        assert!(html.contains("Maintenance in progress"));
        Ok(())
    }

    #[tokio::test]
    async fn maintenance_mode_allows_health_and_readiness_routes() -> Result<()> {
        let static_dir = tempdir()?;
        let app = build_router(maintenance_enabled_config(static_dir.path().to_path_buf()));

        let health = Request::builder().uri("/healthz").body(Body::empty())?;
        let health_response = app.clone().oneshot(health).await?;
        assert_eq!(health_response.status(), StatusCode::OK);

        let ready = Request::builder().uri("/readyz").body(Body::empty())?;
        let ready_response = app.oneshot(ready).await?;
        assert_eq!(ready_response.status(), StatusCode::OK);
        Ok(())
    }

    #[tokio::test]
    async fn maintenance_mode_valid_bypass_sets_cookie_and_redirects() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let app = build_router(maintenance_enabled_config(static_dir.path().to_path_buf()));

        let request = Request::builder()
            .uri("/workspace?maintenance_bypass=maintenance-token")
            .body(Body::empty())?;
        let response = app.clone().oneshot(request).await?;
        assert_eq!(response.status(), StatusCode::TEMPORARY_REDIRECT);
        assert_eq!(
            response
                .headers()
                .get("location")
                .and_then(|value| value.to_str().ok()),
            Some("/workspace")
        );

        let set_cookie = response
            .headers()
            .get(SET_COOKIE)
            .and_then(|value| value.to_str().ok())
            .unwrap_or_default()
            .to_string();
        assert!(set_cookie.contains("oa_maintenance_bypass="));
        assert!(set_cookie.contains("Secure"));
        assert!(set_cookie.contains("HttpOnly"));
        assert!(set_cookie.contains("Max-Age=300"));

        let cookie = set_cookie.split(';').next().unwrap_or_default().to_string();
        assert!(!cookie.contains("maintenance-token"));

        let follow_request = Request::builder()
            .uri("/workspace")
            .header("cookie", cookie)
            .body(Body::empty())?;
        let follow_response = app.oneshot(follow_request).await?;
        assert_eq!(follow_response.status(), StatusCode::OK);
        Ok(())
    }

    #[tokio::test]
    async fn maintenance_mode_invalid_bypass_token_does_not_grant_access() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let app = build_router(maintenance_enabled_config(static_dir.path().to_path_buf()));

        let request = Request::builder()
            .uri("/?maintenance_bypass=bad-token")
            .body(Body::empty())?;
        let response = app.oneshot(request).await?;
        assert_eq!(response.status(), StatusCode::SERVICE_UNAVAILABLE);
        assert!(response.headers().get(SET_COOKIE).is_none());
        Ok(())
    }

    #[tokio::test]
    async fn maintenance_cookie_validation_enforces_signature_and_ttl() -> Result<()> {
        let token = "maintenance-token";
        let now = chrono::Utc::now().timestamp().max(0) as u64;

        let valid = super::maintenance_bypass_cookie_payload(token, now + 300).unwrap_or_default();
        assert!(super::maintenance_cookie_is_valid(&valid, token));

        let expired = super::maintenance_bypass_cookie_payload(token, now.saturating_sub(1))
            .unwrap_or_default();
        assert!(!super::maintenance_cookie_is_valid(&expired, token));
        assert!(!super::maintenance_cookie_is_valid("invalid", token));
        Ok(())
    }

    #[tokio::test]
    async fn maintenance_allowed_paths_can_include_control_endpoints() -> Result<()> {
        let static_dir = tempdir()?;
        let mut config = maintenance_enabled_config(static_dir.path().to_path_buf());
        config
            .maintenance_allowed_paths
            .push("/api/v1/control/status".to_string());
        let app = build_router(config);

        let request = Request::builder()
            .uri("/api/v1/control/status")
            .body(Body::empty())?;
        let response = app.oneshot(request).await?;
        assert_eq!(response.status(), StatusCode::UNAUTHORIZED);
        Ok(())
    }

    #[tokio::test]
    async fn static_hashed_asset_uses_immutable_cache_header() -> Result<()> {
        let static_dir = tempdir()?;
        let assets_dir = static_dir.path().join("assets");
        std::fs::create_dir_all(&assets_dir)?;
        std::fs::write(
            assets_dir.join("app-0a1b2c3d4e5f.js"),
            "console.log('openagents');",
        )?;
        let app = build_router(test_config(static_dir.path().to_path_buf()));

        let request = Request::builder()
            .uri("/assets/app-0a1b2c3d4e5f.js")
            .body(Body::empty())?;
        let response = app.oneshot(request).await?;

        assert_eq!(response.status(), StatusCode::OK);
        assert_eq!(
            response
                .headers()
                .get(CACHE_CONTROL)
                .and_then(|value| value.to_str().ok()),
            Some(CACHE_IMMUTABLE_ONE_YEAR)
        );
        let content_type = response
            .headers()
            .get(CONTENT_TYPE)
            .and_then(|value| value.to_str().ok())
            .unwrap_or_default();
        assert!(content_type.starts_with("text/javascript"));
        assert_eq!(
            response
                .headers()
                .get(super::HEADER_X_CONTENT_TYPE_OPTIONS)
                .and_then(|value| value.to_str().ok()),
            Some(super::X_CONTENT_TYPE_OPTIONS_NOSNIFF)
        );

        Ok(())
    }

    #[tokio::test]
    async fn static_asset_prefers_brotli_then_gzip_when_variants_exist() -> Result<()> {
        let static_dir = tempdir()?;
        let assets_dir = static_dir.path().join("assets");
        std::fs::create_dir_all(&assets_dir)?;
        let asset_path = assets_dir.join("app-0a1b2c3d4e5f.js");
        std::fs::write(&asset_path, "console.log('openagents');")?;

        let mut br_path = asset_path.as_os_str().to_os_string();
        br_path.push(".br");
        std::fs::write(std::path::PathBuf::from(br_path), "brotli-bytes")?;

        let mut gz_path = asset_path.as_os_str().to_os_string();
        gz_path.push(".gz");
        std::fs::write(std::path::PathBuf::from(gz_path), "gzip-bytes")?;

        let app = build_router(test_config(static_dir.path().to_path_buf()));

        let br_request = Request::builder()
            .uri("/assets/app-0a1b2c3d4e5f.js")
            .header(ACCEPT_ENCODING, "br, gzip")
            .body(Body::empty())?;
        let br_response = app.clone().oneshot(br_request).await?;
        assert_eq!(br_response.status(), StatusCode::OK);
        assert_eq!(
            br_response
                .headers()
                .get(CONTENT_ENCODING)
                .and_then(|value| value.to_str().ok()),
            Some("br")
        );
        let br_body = br_response.into_body().collect().await?.to_bytes();
        assert_eq!(br_body.as_ref(), b"brotli-bytes");

        let gz_request = Request::builder()
            .uri("/assets/app-0a1b2c3d4e5f.js")
            .header(ACCEPT_ENCODING, "gzip")
            .body(Body::empty())?;
        let gz_response = app.oneshot(gz_request).await?;
        assert_eq!(gz_response.status(), StatusCode::OK);
        assert_eq!(
            gz_response
                .headers()
                .get(CONTENT_ENCODING)
                .and_then(|value| value.to_str().ok()),
            Some("gzip")
        );
        let gz_body = gz_response.into_body().collect().await?.to_bytes();
        assert_eq!(gz_body.as_ref(), b"gzip-bytes");

        Ok(())
    }

    #[tokio::test]
    async fn file_like_root_wasm_path_resolves_to_assets_fallback() -> Result<()> {
        let static_dir = tempdir()?;
        let assets_dir = static_dir.path().join("assets");
        std::fs::create_dir_all(&assets_dir)?;
        let wasm_bytes = vec![0x00, 0x61, 0x73, 0x6d];
        std::fs::write(
            assets_dir.join("openagents_web_shell_bg.wasm"),
            wasm_bytes.clone(),
        )?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let app = build_router(test_config(static_dir.path().to_path_buf()));

        let request = Request::builder()
            .uri("/openagents_web_shell_bg.wasm")
            .body(Body::empty())?;
        let response = app.oneshot(request).await?;
        assert_eq!(response.status(), StatusCode::OK);
        assert_eq!(
            response
                .headers()
                .get(CACHE_CONTROL)
                .and_then(|value| value.to_str().ok()),
            Some(CACHE_SHORT_LIVED)
        );
        let content_type = response
            .headers()
            .get(CONTENT_TYPE)
            .and_then(|value| value.to_str().ok())
            .unwrap_or_default();
        assert!(content_type.starts_with("application/wasm"));

        let body = response.into_body().collect().await?.to_bytes();
        assert_eq!(body.as_ref(), wasm_bytes.as_slice());

        Ok(())
    }

    #[tokio::test]
    async fn file_like_missing_path_returns_not_found_instead_of_html_shell() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let app = build_router(test_config(static_dir.path().to_path_buf()));

        let request = Request::builder()
            .uri("/missing-module.wasm")
            .body(Body::empty())?;
        let response = app.oneshot(request).await?;
        assert_eq!(response.status(), StatusCode::NOT_FOUND);
        let body = read_json(response).await?;
        assert_eq!(body["error"]["code"], "not_found");

        Ok(())
    }

    #[tokio::test]
    async fn static_asset_supports_etag_conditional_get() -> Result<()> {
        let static_dir = tempdir()?;
        let assets_dir = static_dir.path().join("assets");
        std::fs::create_dir_all(&assets_dir)?;
        std::fs::write(
            assets_dir.join("app-0a1b2c3d4e5f.js"),
            "console.log('openagents');",
        )?;
        let app = build_router(test_config(static_dir.path().to_path_buf()));

        let first_request = Request::builder()
            .uri("/assets/app-0a1b2c3d4e5f.js")
            .body(Body::empty())?;
        let first_response = app.clone().oneshot(first_request).await?;
        assert_eq!(first_response.status(), StatusCode::OK);
        let etag = first_response
            .headers()
            .get(ETAG)
            .and_then(|value| value.to_str().ok())
            .unwrap_or_default()
            .to_string();
        assert!(!etag.is_empty());

        let conditional_request = Request::builder()
            .uri("/assets/app-0a1b2c3d4e5f.js")
            .header(IF_NONE_MATCH, etag.clone())
            .body(Body::empty())?;
        let conditional_response = app.oneshot(conditional_request).await?;
        assert_eq!(conditional_response.status(), StatusCode::NOT_MODIFIED);
        assert_eq!(
            conditional_response
                .headers()
                .get(ETAG)
                .and_then(|value| value.to_str().ok()),
            Some(etag.as_str())
        );
        assert_eq!(
            conditional_response
                .headers()
                .get(CACHE_CONTROL)
                .and_then(|value| value.to_str().ok()),
            Some(CACHE_IMMUTABLE_ONE_YEAR)
        );
        let body = conditional_response.into_body().collect().await?.to_bytes();
        assert_eq!(body.len(), 0);

        Ok(())
    }

    #[tokio::test]
    async fn pinned_htmx_asset_is_served_with_cache_compression_and_etag() -> Result<()> {
        let static_dir = tempdir()?;
        let assets_dir = static_dir.path().join("assets");
        std::fs::create_dir_all(&assets_dir)?;

        let asset_name = "htmx-2_0_8-22283ef6.js";
        let asset_path = assets_dir.join(asset_name);
        std::fs::write(&asset_path, "window.htmxVersion='2.0.8';")?;

        let mut br_path = asset_path.as_os_str().to_os_string();
        br_path.push(".br");
        std::fs::write(std::path::PathBuf::from(br_path), "htmx-br-bytes")?;

        let mut gz_path = asset_path.as_os_str().to_os_string();
        gz_path.push(".gz");
        std::fs::write(std::path::PathBuf::from(gz_path), "htmx-gzip-bytes")?;

        let app = build_router(test_config(static_dir.path().to_path_buf()));

        let first_request = Request::builder()
            .uri(format!("/assets/{asset_name}"))
            .header(ACCEPT_ENCODING, "br, gzip")
            .body(Body::empty())?;
        let first_response = app.clone().oneshot(first_request).await?;
        assert_eq!(first_response.status(), StatusCode::OK);
        assert_eq!(
            first_response
                .headers()
                .get(CACHE_CONTROL)
                .and_then(|value| value.to_str().ok()),
            Some(CACHE_IMMUTABLE_ONE_YEAR)
        );
        assert_eq!(
            first_response
                .headers()
                .get(CONTENT_ENCODING)
                .and_then(|value| value.to_str().ok()),
            Some("br")
        );
        let content_type = first_response
            .headers()
            .get(CONTENT_TYPE)
            .and_then(|value| value.to_str().ok())
            .unwrap_or_default();
        assert!(content_type.starts_with("text/javascript"));
        let etag = first_response
            .headers()
            .get(ETAG)
            .and_then(|value| value.to_str().ok())
            .unwrap_or_default()
            .to_string();
        assert!(!etag.is_empty());
        let first_body = first_response.into_body().collect().await?.to_bytes();
        assert_eq!(first_body.as_ref(), b"htmx-br-bytes");

        let conditional_request = Request::builder()
            .uri(format!("/assets/{asset_name}"))
            .header(ACCEPT_ENCODING, "br, gzip")
            .header(IF_NONE_MATCH, etag.clone())
            .body(Body::empty())?;
        let conditional_response = app.oneshot(conditional_request).await?;
        assert_eq!(conditional_response.status(), StatusCode::NOT_MODIFIED);
        assert_eq!(
            conditional_response
                .headers()
                .get(ETAG)
                .and_then(|value| value.to_str().ok()),
            Some(etag.as_str())
        );
        assert_eq!(
            conditional_response
                .headers()
                .get(CACHE_CONTROL)
                .and_then(|value| value.to_str().ok()),
            Some(CACHE_IMMUTABLE_ONE_YEAR)
        );
        let body = conditional_response.into_body().collect().await?.to_bytes();
        assert_eq!(body.len(), 0);

        Ok(())
    }

    #[tokio::test]
    async fn manifest_uses_no_store_cache_header() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("manifest.json"),
            r#"{"app":"assets/app-0a1b2c3d4e5f.js"}"#,
        )?;
        let app = build_router(test_config(static_dir.path().to_path_buf()));

        let request = Request::builder()
            .uri("/manifest.json")
            .body(Body::empty())?;
        let response = app.oneshot(request).await?;

        assert_eq!(response.status(), StatusCode::OK);
        assert_eq!(
            response
                .headers()
                .get(CACHE_CONTROL)
                .and_then(|value| value.to_str().ok()),
            Some(CACHE_MANIFEST)
        );

        Ok(())
    }

    #[tokio::test]
    async fn service_worker_script_uses_no_store_cache_header() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("sw.js"),
            "self.addEventListener('install', () => {});",
        )?;
        let app = build_router(test_config(static_dir.path().to_path_buf()));

        let request = Request::builder().uri("/sw.js").body(Body::empty())?;
        let response = app.oneshot(request).await?;

        assert_eq!(response.status(), StatusCode::OK);
        assert_eq!(
            response
                .headers()
                .get(CACHE_CONTROL)
                .and_then(|value| value.to_str().ok()),
            Some(CACHE_MANIFEST)
        );

        Ok(())
    }

    #[tokio::test]
    async fn openapi_route_serves_generated_minified_json() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        let request = Request::builder()
            .uri(super::ROUTE_OPENAPI_JSON)
            .body(Body::empty())?;
        let response = app.oneshot(request).await?;

        assert_eq!(response.status(), StatusCode::OK);
        assert_eq!(
            response
                .headers()
                .get(CACHE_CONTROL)
                .and_then(|value| value.to_str().ok()),
            Some(CACHE_MANIFEST)
        );
        let content_type = response
            .headers()
            .get(CONTENT_TYPE)
            .and_then(|value| value.to_str().ok())
            .unwrap_or_default();
        assert!(content_type.starts_with("application/json"));

        let body = response.into_body().collect().await?.to_bytes();
        let body_text = String::from_utf8(body.to_vec())?;
        assert!(body_text.starts_with("{\"openapi\":\"3.0.2\""));
        assert!(!body_text.contains('\n'));

        let parsed = serde_json::from_str::<Value>(&body_text)?;
        assert_eq!(parsed["openapi"], "3.0.2");
        assert!(parsed["paths"]["/api/auth/email"].is_object());
        assert!(parsed["components"]["securitySchemes"]["bearerAuth"].is_object());

        Ok(())
    }

    #[tokio::test]
    async fn openapi_route_supports_etag_conditional_get() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        let first_request = Request::builder()
            .uri(super::ROUTE_OPENAPI_JSON)
            .body(Body::empty())?;
        let first_response = app.clone().oneshot(first_request).await?;
        assert_eq!(first_response.status(), StatusCode::OK);
        let etag = first_response
            .headers()
            .get(ETAG)
            .and_then(|value| value.to_str().ok())
            .unwrap_or_default()
            .to_string();
        assert!(!etag.is_empty());

        let conditional_request = Request::builder()
            .uri(super::ROUTE_OPENAPI_JSON)
            .header(IF_NONE_MATCH, etag.clone())
            .body(Body::empty())?;
        let conditional_response = app.oneshot(conditional_request).await?;
        assert_eq!(conditional_response.status(), StatusCode::NOT_MODIFIED);
        assert_eq!(
            conditional_response
                .headers()
                .get(ETAG)
                .and_then(|value| value.to_str().ok()),
            Some(etag.as_str())
        );
        assert_eq!(
            conditional_response
                .headers()
                .get(CACHE_CONTROL)
                .and_then(|value| value.to_str().ok()),
            Some(CACHE_MANIFEST)
        );

        Ok(())
    }

    #[tokio::test]
    async fn api_list_routes_default_to_no_store_cache_header() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        let request = Request::builder()
            .method("GET")
            .uri("/api/shouts")
            .header("origin", "https://console.openagents.com")
            .body(Body::empty())?;
        let response = app.oneshot(request).await?;

        assert_eq!(response.status(), StatusCode::OK);
        assert_eq!(
            response
                .headers()
                .get(CACHE_CONTROL)
                .and_then(|value| value.to_str().ok()),
            Some(super::CACHE_API_NO_STORE)
        );
        assert_eq!(
            response
                .headers()
                .get("access-control-allow-origin")
                .and_then(|value| value.to_str().ok()),
            Some("https://console.openagents.com")
        );

        Ok(())
    }

    #[tokio::test]
    async fn smoke_stream_requires_secret_header() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        let missing_request = Request::builder()
            .uri(super::ROUTE_SMOKE_STREAM)
            .body(Body::empty())?;
        let missing_response = app.clone().oneshot(missing_request).await?;
        assert_eq!(missing_response.status(), StatusCode::UNAUTHORIZED);

        let wrong_request = Request::builder()
            .uri(super::ROUTE_SMOKE_STREAM)
            .header(super::HEADER_OA_SMOKE_SECRET, "wrong")
            .body(Body::empty())?;
        let wrong_response = app.oneshot(wrong_request).await?;
        assert_eq!(wrong_response.status(), StatusCode::UNAUTHORIZED);

        Ok(())
    }

    #[tokio::test]
    async fn smoke_stream_returns_khala_ws_contract_metadata() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        let request = Request::builder()
            .uri(super::ROUTE_SMOKE_STREAM)
            .header(super::HEADER_OA_SMOKE_SECRET, "secret")
            .body(Body::empty())?;
        let response = app.oneshot(request).await?;

        assert_eq!(response.status(), StatusCode::OK);
        assert_eq!(
            response
                .headers()
                .get(super::HEADER_OA_SMOKE)
                .and_then(|value| value.to_str().ok()),
            Some("1")
        );
        assert_eq!(
            response
                .headers()
                .get(CACHE_CONTROL)
                .and_then(|value| value.to_str().ok()),
            Some("no-store")
        );

        let body = read_json(response).await?;
        assert_eq!(body["data"]["status"], "ok");
        assert_eq!(body["data"]["stream_protocol"], "khala_ws");
        assert_eq!(body["data"]["delivery"]["transport"], "khala_ws");
        assert_eq!(body["data"]["delivery"]["sseEnabled"], false);
        assert_eq!(
            body["data"]["delivery"]["syncTokenRoute"],
            super::ROUTE_SYNC_TOKEN
        );

        Ok(())
    }

    #[tokio::test]
    async fn static_asset_rejects_path_traversal_segments() -> Result<()> {
        let static_dir = tempdir()?;
        let app = build_router(test_config(static_dir.path().to_path_buf()));

        let request = Request::builder()
            .uri("/assets/../manifest.json")
            .body(Body::empty())?;
        let response = app.oneshot(request).await?;

        assert_eq!(response.status(), StatusCode::NOT_FOUND);
        let body = read_json(response).await?;
        assert_eq!(body["error"]["code"], "not_found");
        Ok(())
    }

    #[tokio::test]
    async fn compatibility_gate_rejects_missing_client_version_headers() -> Result<()> {
        let static_dir = tempdir()?;
        let app = build_router(compat_enforced_config(static_dir.path().to_path_buf()));

        let request = Request::builder()
            .uri("/api/v1/control/status")
            .body(Body::empty())?;
        let response = app.oneshot(request).await?;

        assert_eq!(response.status(), StatusCode::UPGRADE_REQUIRED);
        assert_eq!(
            response
                .headers()
                .get(super::HEADER_OA_COMPAT_CODE)
                .and_then(|value| value.to_str().ok()),
            Some("invalid_client_build")
        );
        assert_eq!(
            response
                .headers()
                .get(super::HEADER_OA_COMPAT_UPGRADE_REQUIRED)
                .and_then(|value| value.to_str().ok()),
            Some("true")
        );
        let body = read_json(response).await?;
        assert_eq!(body["error"]["code"], "invalid_client_build");
        assert_eq!(body["compatibility"]["upgrade_required"], true);
        Ok(())
    }

    #[tokio::test]
    async fn compatibility_gate_rejects_client_below_minimum_build() -> Result<()> {
        let static_dir = tempdir()?;
        let app = build_router(compat_enforced_config(static_dir.path().to_path_buf()));

        let request = Request::builder()
            .uri("/api/v1/control/status")
            .header("x-oa-client-build-id", "20260221T110000Z")
            .header("x-oa-protocol-version", "openagents.control.v1")
            .header("x-oa-schema-version", "1")
            .body(Body::empty())?;
        let response = app.oneshot(request).await?;

        assert_eq!(response.status(), StatusCode::UPGRADE_REQUIRED);
        let body = read_json(response).await?;
        assert_eq!(body["error"]["code"], "upgrade_required");
        assert_eq!(
            body["compatibility"]["min_client_build_id"],
            "20260221T120000Z"
        );
        Ok(())
    }

    #[tokio::test]
    async fn compatibility_gate_allows_supported_client_version() -> Result<()> {
        let static_dir = tempdir()?;
        let app = build_router(compat_enforced_config(static_dir.path().to_path_buf()));

        let request = Request::builder()
            .uri("/api/v1/control/status")
            .header("x-oa-client-build-id", "20260221T130000Z")
            .header("x-oa-protocol-version", "openagents.control.v1")
            .header("x-oa-schema-version", "1")
            .body(Body::empty())?;
        let response = app.oneshot(request).await?;

        assert_eq!(response.status(), StatusCode::UNAUTHORIZED);
        Ok(())
    }

    #[tokio::test]
    async fn compatibility_gate_rejects_legacy_chat_stream_missing_headers() -> Result<()> {
        let static_dir = tempdir()?;
        let app = build_router(compat_enforced_config(static_dir.path().to_path_buf()));

        let request = Request::builder()
            .method("POST")
            .uri("/api/chat/stream")
            .header("content-type", "application/json")
            .body(Body::from(
                r#"{"messages":[{"role":"user","content":"compat please"}]}"#,
            ))?;
        let response = app.oneshot(request).await?;

        assert_eq!(response.status(), StatusCode::UPGRADE_REQUIRED);
        assert_eq!(
            response
                .headers()
                .get(super::HEADER_OA_COMPAT_CODE)
                .and_then(|value| value.to_str().ok()),
            Some("invalid_client_build")
        );
        let body = read_json(response).await?;
        assert_eq!(body["error"]["code"], "invalid_client_build");
        assert_eq!(body["compatibility"]["upgrade_required"], true);
        Ok(())
    }

    #[tokio::test]
    async fn compatibility_gate_rejects_legacy_chat_stream_protocol_mismatch() -> Result<()> {
        let static_dir = tempdir()?;
        let app = build_router(compat_enforced_config(static_dir.path().to_path_buf()));

        let request = Request::builder()
            .method("POST")
            .uri("/api/chats/thread-compat/stream")
            .header("content-type", "application/json")
            .header("x-oa-client-build-id", "20260221T130000Z")
            .header("x-oa-protocol-version", "openagents.control.v0")
            .header("x-oa-schema-version", "1")
            .body(Body::from(
                r#"{"messages":[{"role":"user","content":"compat protocol"}]}"#,
            ))?;
        let response = app.oneshot(request).await?;

        assert_eq!(response.status(), StatusCode::UPGRADE_REQUIRED);
        let body = read_json(response).await?;
        assert_eq!(body["error"]["code"], "unsupported_protocol_version");
        assert_eq!(
            body["compatibility"]["protocol_version"],
            "openagents.control.v1"
        );
        Ok(())
    }

    #[tokio::test]
    async fn compatibility_gate_rejects_legacy_chat_stream_schema_mismatch() -> Result<()> {
        let static_dir = tempdir()?;
        let app = build_router(compat_enforced_config(static_dir.path().to_path_buf()));

        let request = Request::builder()
            .method("POST")
            .uri("/api/chat/stream")
            .header("content-type", "application/json")
            .header("x-oa-client-build-id", "20260221T130000Z")
            .header("x-oa-protocol-version", "openagents.control.v1")
            .header("x-oa-schema-version", "99")
            .body(Body::from(
                r#"{"messages":[{"role":"user","content":"compat schema"}]}"#,
            ))?;
        let response = app.oneshot(request).await?;

        assert_eq!(response.status(), StatusCode::UPGRADE_REQUIRED);
        let body = read_json(response).await?;
        assert_eq!(body["error"]["code"], "unsupported_schema_version");
        assert_eq!(body["compatibility"]["min_schema_version"], 1);
        assert_eq!(body["compatibility"]["max_schema_version"], 1);
        Ok(())
    }

    #[tokio::test]
    async fn compatibility_gate_allows_legacy_chat_stream_supported_client() -> Result<()> {
        let static_dir = tempdir()?;
        let app = build_router(compat_enforced_config(static_dir.path().to_path_buf()));

        let request = Request::builder()
            .method("POST")
            .uri("/api/chat/stream")
            .header("content-type", "application/json")
            .header("x-oa-client-build-id", "20260221T130000Z")
            .header("x-oa-protocol-version", "openagents.control.v1")
            .header("x-oa-schema-version", "1")
            .body(Body::from(
                r#"{"messages":[{"role":"user","content":"compat accepted"}]}"#,
            ))?;
        let response = app.oneshot(request).await?;

        assert_eq!(response.status(), StatusCode::UNAUTHORIZED);
        let body = read_json(response).await?;
        assert_eq!(body["error"]["code"], "unauthorized");
        Ok(())
    }

    #[tokio::test]
    async fn compatibility_gate_skips_auth_bootstrap_routes() -> Result<()> {
        let static_dir = tempdir()?;
        let app = build_router(compat_enforced_config(static_dir.path().to_path_buf()));

        let request = Request::builder()
            .method("POST")
            .uri("/api/auth/email")
            .header("content-type", "application/json")
            .body(Body::from(r#"{"email":"compat-skip@openagents.com"}"#))?;
        let response = app.oneshot(request).await?;

        assert_eq!(response.status(), StatusCode::OK);
        Ok(())
    }

    #[tokio::test]
    async fn compatibility_rejections_emit_audit_with_surface_and_build() -> Result<()> {
        let static_dir = tempdir()?;
        let sink = RecordingAuditSink::default();
        let app = build_router_with_observability(
            compat_enforced_config(static_dir.path().to_path_buf()),
            Observability::new(Arc::new(sink.clone())),
        );

        let request = Request::builder()
            .uri("/api/v1/control/status")
            .header("x-client", "autopilot-ios")
            .header("x-oa-client-build-id", "20260221T110000Z")
            .header("x-oa-protocol-version", "openagents.control.v1")
            .header("x-oa-schema-version", "1")
            .body(Body::empty())?;

        let response = app.oneshot(request).await?;
        assert_eq!(response.status(), StatusCode::UPGRADE_REQUIRED);

        let events = sink.events();
        let compat_event = events
            .iter()
            .find(|event| event.event_name == "compatibility.rejected")
            .expect("missing compatibility rejection audit event");

        assert_eq!(
            compat_event.attributes.get("surface").map(String::as_str),
            Some("control_api")
        );
        assert_eq!(
            compat_event.attributes.get("client").map(String::as_str),
            Some("autopilot-ios")
        );
        assert_eq!(
            compat_event
                .attributes
                .get("client_build_id")
                .map(String::as_str),
            Some("20260221T110000Z")
        );

        Ok(())
    }

    #[tokio::test]
    async fn auth_email_and_verify_flow_returns_session_tokens() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        let send_request = Request::builder()
            .method("POST")
            .uri("/api/auth/email")
            .header("content-type", "application/json")
            .body(Body::from(r#"{"email":"test@example.com"}"#))?;

        let send_response = app.clone().oneshot(send_request).await?;
        assert_eq!(send_response.status(), StatusCode::OK);
        let cookie = cookie_value(&send_response).unwrap_or_default();

        let verify_request = Request::builder()
            .method("POST")
            .uri("/api/auth/verify")
            .header("content-type", "application/json")
            .header("x-client", "autopilot-ios")
            .header("cookie", cookie)
            .body(Body::from(r#"{"code":"123456"}"#))?;

        let verify_response = app.clone().oneshot(verify_request).await?;
        assert_eq!(verify_response.status(), StatusCode::OK);
        let verify_body = read_json(verify_response).await?;

        assert_eq!(verify_body["status"], "authenticated");
        assert_eq!(verify_body["tokenType"], "Bearer");
        assert_eq!(verify_body["tokenName"], "mobile:autopilot-ios");

        let token = verify_body["token"]
            .as_str()
            .unwrap_or_default()
            .to_string();
        assert!(!token.is_empty());

        let session_request = Request::builder()
            .uri("/api/auth/session")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;

        let session_response = app.oneshot(session_request).await?;
        assert_eq!(session_response.status(), StatusCode::OK);

        Ok(())
    }

    #[tokio::test]
    async fn auth_verify_requires_pending_challenge_cookie() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        let request = Request::builder()
            .method("POST")
            .uri("/api/auth/verify")
            .header("content-type", "application/json")
            .body(Body::from(r#"{"code":"123456"}"#))?;

        let response = app.oneshot(request).await?;
        assert_eq!(response.status(), StatusCode::UNPROCESSABLE_ENTITY);
        let body = read_json(response).await?;
        assert_eq!(body["error"]["code"], "invalid_request");
        Ok(())
    }

    #[tokio::test]
    async fn auth_email_rejects_when_workos_is_not_configured() -> Result<()> {
        let app = build_router(workos_required_config(std::env::temp_dir()));

        let request = Request::builder()
            .method("POST")
            .uri("/api/auth/email")
            .header("content-type", "application/json")
            .body(Body::from(r#"{"email":"workos-required@example.com"}"#))?;

        let response = app.oneshot(request).await?;
        assert_eq!(response.status(), StatusCode::SERVICE_UNAVAILABLE);

        let body = read_json(response).await?;
        assert_eq!(body["error"]["code"], "service_unavailable");

        let message = body["error"]["message"].as_str().unwrap_or_default();
        assert!(message.contains("WorkOS identity provider is required"));

        Ok(())
    }

    #[tokio::test]
    async fn auth_register_is_not_found_when_disabled() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        let request = Request::builder()
            .method("POST")
            .uri("/api/auth/register")
            .header("content-type", "application/json")
            .body(Body::from(
                r#"{"email":"staging-user-1@staging.openagents.com"}"#,
            ))?;

        let response = app.oneshot(request).await?;
        assert_eq!(response.status(), StatusCode::NOT_FOUND);
        Ok(())
    }

    #[tokio::test]
    async fn auth_register_creates_user_and_returns_pat_when_enabled() -> Result<()> {
        let mut config = test_config(std::env::temp_dir());
        config.auth_api_signup_enabled = true;
        let app = build_router(config);

        let create_request = Request::builder()
            .method("POST")
            .uri("/api/auth/register")
            .header("content-type", "application/json")
            .body(Body::from(
                r#"{"email":"staging-user-1@staging.openagents.com","name":"Staging User 1","tokenName":"staging-e2e"}"#,
            ))?;
        let create_response = app.clone().oneshot(create_request).await?;
        assert_eq!(create_response.status(), StatusCode::CREATED);
        let create_body = read_json(create_response).await?;
        assert_eq!(create_body["data"]["created"], true);
        assert_eq!(
            create_body["data"]["user"]["email"],
            "staging-user-1@staging.openagents.com"
        );
        assert_eq!(create_body["data"]["tokenName"], "staging-e2e");

        let token = create_body["data"]["token"]
            .as_str()
            .unwrap_or_default()
            .to_string();
        assert!(!token.is_empty());

        let second_request = Request::builder()
            .method("POST")
            .uri("/api/auth/register")
            .header("content-type", "application/json")
            .body(Body::from(
                r#"{"email":"staging-user-1@staging.openagents.com","name":"Updated Name"}"#,
            ))?;
        let second_response = app.oneshot(second_request).await?;
        assert_eq!(second_response.status(), StatusCode::OK);
        let second_body = read_json(second_response).await?;
        assert_eq!(second_body["data"]["created"], false);
        assert_eq!(second_body["data"]["user"]["name"], "Updated Name");

        Ok(())
    }

    #[tokio::test]
    async fn auth_register_enforces_allowed_domains_and_can_create_autopilot() -> Result<()> {
        let mut config = test_config(std::env::temp_dir());
        config.auth_api_signup_enabled = true;
        config.auth_api_signup_allowed_domains = vec!["staging.openagents.com".to_string()];
        let app = build_router(config);

        let blocked_request = Request::builder()
            .method("POST")
            .uri("/api/auth/register")
            .header("content-type", "application/json")
            .body(Body::from(r#"{"email":"blocked@example.com"}"#))?;
        let blocked_response = app.clone().oneshot(blocked_request).await?;
        assert_eq!(blocked_response.status(), StatusCode::UNPROCESSABLE_ENTITY);
        let blocked_body = read_json(blocked_response).await?;
        assert_eq!(blocked_body["error"]["code"], "invalid_request");

        let allowed_request = Request::builder()
            .method("POST")
            .uri("/api/auth/register")
            .header("content-type", "application/json")
            .body(Body::from(
                r#"{"email":"creator@staging.openagents.com","createAutopilot":true,"autopilotDisplayName":"Creator Agent"}"#,
            ))?;
        let allowed_response = app.oneshot(allowed_request).await?;
        assert_eq!(allowed_response.status(), StatusCode::CREATED);
        let allowed_body = read_json(allowed_response).await?;
        assert_eq!(
            allowed_body["data"]["autopilot"]["displayName"],
            "Creator Agent"
        );
        assert!(allowed_body["data"]["autopilot"]["id"].as_str().is_some());

        Ok(())
    }

    #[tokio::test]
    async fn login_page_redirects_home_when_already_authenticated() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        let send_request = Request::builder()
            .method("POST")
            .uri("/api/auth/email")
            .header("content-type", "application/json")
            .body(Body::from(r#"{"email":"already-authed@example.com"}"#))?;
        let send_response = app.clone().oneshot(send_request).await?;
        let challenge_cookie = cookie_value(&send_response).unwrap_or_default();

        let verify_request = Request::builder()
            .method("POST")
            .uri("/api/auth/verify")
            .header("content-type", "application/json")
            .header("cookie", challenge_cookie)
            .body(Body::from(r#"{"code":"123456"}"#))?;
        let verify_response = app.clone().oneshot(verify_request).await?;
        let verify_body = read_json(verify_response).await?;
        let access_token = verify_body["token"]
            .as_str()
            .unwrap_or_default()
            .to_string();

        let login_request = Request::builder()
            .uri("/login")
            .header("authorization", format!("Bearer {access_token}"))
            .body(Body::empty())?;
        let login_response = app.oneshot(login_request).await?;
        assert_eq!(login_response.status(), StatusCode::TEMPORARY_REDIRECT);
        assert_eq!(
            login_response
                .headers()
                .get("location")
                .and_then(|value| value.to_str().ok()),
            Some("/")
        );

        Ok(())
    }

    #[tokio::test]
    async fn web_login_email_and_verify_routes_set_auth_cookies() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        let send_request = Request::builder()
            .method("POST")
            .uri("/login/email")
            .header("content-type", "application/x-www-form-urlencoded")
            .body(Body::from("email=web-login%40openagents.com"))?;
        let send_response = app.clone().oneshot(send_request).await?;
        assert_eq!(send_response.status(), StatusCode::TEMPORARY_REDIRECT);
        assert_eq!(
            send_response
                .headers()
                .get("location")
                .and_then(|value| value.to_str().ok()),
            Some("/login?status=code-sent")
        );
        let challenge_cookie = cookie_value_for_name(&send_response, super::CHALLENGE_COOKIE_NAME)
            .expect("missing challenge cookie");

        let verify_request = Request::builder()
            .method("POST")
            .uri("/login/verify")
            .header("content-type", "application/x-www-form-urlencoded")
            .header(
                "cookie",
                format!("{}={challenge_cookie}", super::CHALLENGE_COOKIE_NAME),
            )
            .body(Body::from("code=123456"))?;
        let verify_response = app.clone().oneshot(verify_request).await?;
        assert_eq!(verify_response.status(), StatusCode::TEMPORARY_REDIRECT);
        assert_eq!(
            verify_response
                .headers()
                .get("location")
                .and_then(|value| value.to_str().ok()),
            Some("/")
        );

        let set_cookies = all_set_cookie_values(&verify_response);
        assert!(
            set_cookies
                .iter()
                .any(|value| value.starts_with(&format!("{}=", super::AUTH_ACCESS_COOKIE_NAME)))
        );
        assert!(
            set_cookies
                .iter()
                .any(|value| value.starts_with(&format!("{}=", super::AUTH_REFRESH_COOKIE_NAME)))
        );
        assert!(
            set_cookies
                .iter()
                .any(|value| value.starts_with(&format!("{}=;", super::CHALLENGE_COOKIE_NAME)))
        );

        let access_cookie = cookie_value_for_name(&verify_response, super::AUTH_ACCESS_COOKIE_NAME)
            .expect("missing access cookie");
        let login_request = Request::builder()
            .uri("/login")
            .header(
                "cookie",
                format!("{}={access_cookie}", super::AUTH_ACCESS_COOKIE_NAME),
            )
            .body(Body::empty())?;
        let login_response = app.oneshot(login_request).await?;
        assert_eq!(login_response.status(), StatusCode::TEMPORARY_REDIRECT);
        assert_eq!(
            login_response
                .headers()
                .get("location")
                .and_then(|value| value.to_str().ok()),
            Some("/")
        );

        Ok(())
    }

    #[tokio::test]
    async fn web_login_email_hx_request_returns_notice_fragment() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        let send_request = Request::builder()
            .method("POST")
            .uri("/login/email")
            .header("content-type", "application/x-www-form-urlencoded")
            .header("hx-request", "true")
            .body(Body::from("email=web-login-hx%40openagents.com"))?;
        let send_response = app.clone().oneshot(send_request).await?;
        assert_eq!(send_response.status(), StatusCode::OK);
        assert_eq!(
            send_response
                .headers()
                .get(CONTENT_TYPE)
                .and_then(|value| value.to_str().ok()),
            Some("text/html; charset=utf-8")
        );
        let challenge_cookie = cookie_value_for_name(&send_response, super::CHALLENGE_COOKIE_NAME)
            .expect("missing challenge cookie");
        assert!(!challenge_cookie.is_empty());
        let body = read_text(send_response).await?;
        assert!(body.contains("id=\"login-status\""));
        assert!(body.contains("A verification code was sent."));

        Ok(())
    }

    #[tokio::test]
    async fn web_login_verify_hx_request_returns_hx_redirect_and_auth_cookies() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        let send_request = Request::builder()
            .method("POST")
            .uri("/login/email")
            .header("content-type", "application/x-www-form-urlencoded")
            .body(Body::from("email=web-login-hx-verify%40openagents.com"))?;
        let send_response = app.clone().oneshot(send_request).await?;
        let challenge_cookie = cookie_value_for_name(&send_response, super::CHALLENGE_COOKIE_NAME)
            .expect("missing challenge cookie");

        let verify_request = Request::builder()
            .method("POST")
            .uri("/login/verify")
            .header("content-type", "application/x-www-form-urlencoded")
            .header("hx-request", "true")
            .header(
                "cookie",
                format!("{}={challenge_cookie}", super::CHALLENGE_COOKIE_NAME),
            )
            .body(Body::from("code=123456"))?;
        let verify_response = app.clone().oneshot(verify_request).await?;
        assert_eq!(verify_response.status(), StatusCode::OK);
        assert_eq!(
            verify_response
                .headers()
                .get("HX-Redirect")
                .and_then(|value| value.to_str().ok()),
            Some("/")
        );

        let set_cookies = all_set_cookie_values(&verify_response);
        assert!(
            set_cookies
                .iter()
                .any(|value| value.starts_with(&format!("{}=", super::AUTH_ACCESS_COOKIE_NAME)))
        );
        assert!(
            set_cookies
                .iter()
                .any(|value| value.starts_with(&format!("{}=", super::AUTH_REFRESH_COOKIE_NAME)))
        );
        assert!(
            set_cookies
                .iter()
                .any(|value| value.starts_with(&format!("{}=;", super::CHALLENGE_COOKIE_NAME)))
        );

        Ok(())
    }

    #[tokio::test]
    async fn web_login_verify_hx_request_invalid_code_returns_error_fragment() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        let send_request = Request::builder()
            .method("POST")
            .uri("/login/email")
            .header("content-type", "application/x-www-form-urlencoded")
            .body(Body::from("email=web-login-hx-invalid%40openagents.com"))?;
        let send_response = app.clone().oneshot(send_request).await?;
        let challenge_cookie = cookie_value_for_name(&send_response, super::CHALLENGE_COOKIE_NAME)
            .expect("missing challenge cookie");

        let verify_request = Request::builder()
            .method("POST")
            .uri("/login/verify")
            .header("content-type", "application/x-www-form-urlencoded")
            .header("hx-request", "true")
            .header(
                "cookie",
                format!("{}={challenge_cookie}", super::CHALLENGE_COOKIE_NAME),
            )
            .body(Body::from("code=000000"))?;
        let verify_response = app.oneshot(verify_request).await?;
        assert_eq!(verify_response.status(), StatusCode::UNPROCESSABLE_ENTITY);
        let body = read_text(verify_response).await?;
        assert!(body.contains("id=\"login-status\""));
        assert!(body.contains("Invalid sign-in code. Try again."));

        Ok(())
    }

    #[tokio::test]
    async fn web_auth_cookies_include_secure_same_site_and_host_scope() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        let send_request = Request::builder()
            .method("POST")
            .uri("/login/email")
            .header("content-type", "application/x-www-form-urlencoded")
            .body(Body::from("email=cookie-scope%40openagents.com"))?;
        let send_response = app.clone().oneshot(send_request).await?;
        assert_eq!(send_response.status(), StatusCode::TEMPORARY_REDIRECT);

        let challenge_cookie_header = all_set_cookie_values(&send_response)
            .into_iter()
            .find(|value| value.starts_with(&format!("{}=", super::CHALLENGE_COOKIE_NAME)))
            .expect("missing challenge set-cookie header");
        for required in ["HttpOnly", "Secure", "SameSite=Lax"] {
            assert!(
                challenge_cookie_header.contains(required),
                "challenge cookie missing attribute: {required}"
            );
        }
        assert!(
            !challenge_cookie_header.contains("Domain="),
            "challenge cookie should remain host-scoped"
        );

        let challenge_cookie_value =
            cookie_value_for_name(&send_response, super::CHALLENGE_COOKIE_NAME)
                .expect("missing challenge cookie value");
        let verify_request = Request::builder()
            .method("POST")
            .uri("/login/verify")
            .header("content-type", "application/x-www-form-urlencoded")
            .header(
                "cookie",
                format!("{}={challenge_cookie_value}", super::CHALLENGE_COOKIE_NAME),
            )
            .body(Body::from("code=123456"))?;
        let verify_response = app.oneshot(verify_request).await?;
        assert_eq!(verify_response.status(), StatusCode::TEMPORARY_REDIRECT);

        let verify_cookies = all_set_cookie_values(&verify_response);
        for name in [
            super::AUTH_ACCESS_COOKIE_NAME,
            super::AUTH_REFRESH_COOKIE_NAME,
        ] {
            let cookie = verify_cookies
                .iter()
                .find(|value| value.starts_with(&format!("{name}=")))
                .expect("missing auth set-cookie header");
            for required in ["HttpOnly", "Secure", "SameSite=Lax"] {
                assert!(
                    cookie.contains(required),
                    "cookie {name} missing attribute: {required}"
                );
            }
            assert!(
                !cookie.contains("Domain="),
                "cookie {name} should remain host-scoped"
            );
        }

        Ok(())
    }

    #[tokio::test]
    async fn web_logout_clears_auth_cookies_and_redirects() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        let send_request = Request::builder()
            .method("POST")
            .uri("/login/email")
            .header("content-type", "application/x-www-form-urlencoded")
            .body(Body::from("email=logout-user%40openagents.com"))?;
        let send_response = app.clone().oneshot(send_request).await?;
        let challenge_cookie = cookie_value_for_name(&send_response, super::CHALLENGE_COOKIE_NAME)
            .expect("missing challenge cookie");

        let verify_request = Request::builder()
            .method("POST")
            .uri("/login/verify")
            .header("content-type", "application/x-www-form-urlencoded")
            .header(
                "cookie",
                format!("{}={challenge_cookie}", super::CHALLENGE_COOKIE_NAME),
            )
            .body(Body::from("code=123456"))?;
        let verify_response = app.clone().oneshot(verify_request).await?;
        let access_cookie = cookie_value_for_name(&verify_response, super::AUTH_ACCESS_COOKIE_NAME)
            .expect("missing access cookie");
        let refresh_cookie =
            cookie_value_for_name(&verify_response, super::AUTH_REFRESH_COOKIE_NAME)
                .expect("missing refresh cookie");

        let logout_request = Request::builder()
            .method("POST")
            .uri("/logout")
            .header(
                "cookie",
                format!(
                    "{}={access_cookie}; {}={refresh_cookie}",
                    super::AUTH_ACCESS_COOKIE_NAME,
                    super::AUTH_REFRESH_COOKIE_NAME
                ),
            )
            .body(Body::empty())?;
        let logout_response = app.oneshot(logout_request).await?;
        assert_eq!(logout_response.status(), StatusCode::TEMPORARY_REDIRECT);
        assert_eq!(
            logout_response
                .headers()
                .get("location")
                .and_then(|value| value.to_str().ok()),
            Some("/")
        );

        let set_cookies = all_set_cookie_values(&logout_response);
        assert!(
            set_cookies
                .iter()
                .any(|value| value.starts_with(&format!("{}=;", super::AUTH_ACCESS_COOKIE_NAME)))
        );
        assert!(
            set_cookies
                .iter()
                .any(|value| value.starts_with(&format!("{}=;", super::AUTH_REFRESH_COOKIE_NAME)))
        );

        Ok(())
    }

    #[tokio::test]
    async fn web_logout_hx_request_returns_hx_redirect_and_clears_cookies() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        let send_request = Request::builder()
            .method("POST")
            .uri("/login/email")
            .header("content-type", "application/x-www-form-urlencoded")
            .body(Body::from("email=logout-hx-user%40openagents.com"))?;
        let send_response = app.clone().oneshot(send_request).await?;
        let challenge_cookie = cookie_value_for_name(&send_response, super::CHALLENGE_COOKIE_NAME)
            .expect("missing challenge cookie");

        let verify_request = Request::builder()
            .method("POST")
            .uri("/login/verify")
            .header("content-type", "application/x-www-form-urlencoded")
            .header(
                "cookie",
                format!("{}={challenge_cookie}", super::CHALLENGE_COOKIE_NAME),
            )
            .body(Body::from("code=123456"))?;
        let verify_response = app.clone().oneshot(verify_request).await?;
        let access_cookie = cookie_value_for_name(&verify_response, super::AUTH_ACCESS_COOKIE_NAME)
            .expect("missing access cookie");
        let refresh_cookie =
            cookie_value_for_name(&verify_response, super::AUTH_REFRESH_COOKIE_NAME)
                .expect("missing refresh cookie");

        let logout_request = Request::builder()
            .method("POST")
            .uri("/logout")
            .header("hx-request", "true")
            .header(
                "cookie",
                format!(
                    "{}={access_cookie}; {}={refresh_cookie}",
                    super::AUTH_ACCESS_COOKIE_NAME,
                    super::AUTH_REFRESH_COOKIE_NAME
                ),
            )
            .body(Body::empty())?;
        let logout_response = app.oneshot(logout_request).await?;
        assert_eq!(logout_response.status(), StatusCode::OK);
        assert_eq!(
            logout_response
                .headers()
                .get("HX-Redirect")
                .and_then(|value| value.to_str().ok()),
            Some("/")
        );

        let set_cookies = all_set_cookie_values(&logout_response);
        assert!(
            set_cookies
                .iter()
                .any(|value| value.starts_with(&format!("{}=;", super::AUTH_ACCESS_COOKIE_NAME)))
        );
        assert!(
            set_cookies
                .iter()
                .any(|value| value.starts_with(&format!("{}=;", super::AUTH_REFRESH_COOKIE_NAME)))
        );

        Ok(())
    }

    #[tokio::test]
    async fn web_settings_profile_requires_auth_and_renders_settings_panel() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        let unauth_request = Request::builder()
            .method("GET")
            .uri("/settings/profile")
            .body(Body::empty())?;
        let unauth_response = app.clone().oneshot(unauth_request).await?;
        assert_eq!(unauth_response.status(), StatusCode::TEMPORARY_REDIRECT);
        assert_eq!(
            unauth_response
                .headers()
                .get("location")
                .and_then(|value| value.to_str().ok()),
            Some("/login")
        );

        let unauth_hx_request = Request::builder()
            .method("GET")
            .uri("/settings/profile")
            .header("hx-request", "true")
            .header("hx-target", "oa-main-shell")
            .body(Body::empty())?;
        let unauth_hx_response = app.clone().oneshot(unauth_hx_request).await?;
        assert_eq!(unauth_hx_response.status(), StatusCode::OK);
        assert_eq!(
            unauth_hx_response
                .headers()
                .get("HX-Redirect")
                .and_then(|value| value.to_str().ok()),
            Some("/login")
        );

        let token = authenticate_token(app.clone(), "settings-web@openagents.com").await?;
        let auth_request = Request::builder()
            .method("GET")
            .uri("/settings/profile")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let auth_response = app.oneshot(auth_request).await?;
        assert_eq!(auth_response.status(), StatusCode::OK);
        let body = read_text(auth_response).await?;
        assert!(body.contains("id=\"settings-main-panel\""));
        assert!(body.contains("Save profile"));
        assert!(body.contains("Connect or rotate Resend"));

        Ok(())
    }

    #[tokio::test]
    async fn web_settings_profile_update_supports_hx_and_redirect_modes() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token = authenticate_token(app.clone(), "settings-profile-form@openagents.com").await?;

        let hx_update_request = Request::builder()
            .method("POST")
            .uri("/settings/profile/update")
            .header("content-type", "application/x-www-form-urlencoded")
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from("name=Updated+Name"))?;
        let hx_update_response = app.clone().oneshot(hx_update_request).await?;
        assert_eq!(hx_update_response.status(), StatusCode::OK);
        let hx_body = read_text(hx_update_response).await?;
        assert!(hx_body.contains("id=\"settings-status\""));
        assert!(hx_body.contains("Profile updated."));

        let show_request = Request::builder()
            .method("GET")
            .uri("/settings/profile")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let show_response = app.clone().oneshot(show_request).await?;
        assert_eq!(show_response.status(), StatusCode::OK);
        let show_body = read_text(show_response).await?;
        assert!(show_body.contains("value=\"Updated Name\""));

        let redirect_update_request = Request::builder()
            .method("POST")
            .uri("/settings/profile/update")
            .header("content-type", "application/x-www-form-urlencoded")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from("name=Updated+Again"))?;
        let redirect_update_response = app.oneshot(redirect_update_request).await?;
        assert_eq!(
            redirect_update_response.status(),
            StatusCode::TEMPORARY_REDIRECT
        );
        assert_eq!(
            redirect_update_response
                .headers()
                .get("location")
                .and_then(|value| value.to_str().ok()),
            Some("/settings/profile?status=profile-updated")
        );

        Ok(())
    }

    #[tokio::test]
    async fn web_settings_resend_forms_support_hx_lifecycle() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token = authenticate_token(app.clone(), "settings-resend-form@openagents.com").await?;

        let connect_request = Request::builder()
            .method("POST")
            .uri("/settings/integrations/resend/upsert")
            .header("content-type", "application/x-www-form-urlencoded")
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                "resend_api_key=re_live_1234567890&sender_email=bot%40openagents.com&sender_name=OpenAgents",
            ))?;
        let connect_response = app.clone().oneshot(connect_request).await?;
        assert_eq!(connect_response.status(), StatusCode::OK);
        let connect_body = read_text(connect_response).await?;
        assert!(connect_body.contains("Resend connected."));

        let test_request = Request::builder()
            .method("POST")
            .uri("/settings/integrations/resend/test-request")
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let test_response = app.clone().oneshot(test_request).await?;
        assert_eq!(test_response.status(), StatusCode::OK);
        let test_body = read_text(test_response).await?;
        assert!(test_body.contains("Resend test event queued."));

        let disconnect_request = Request::builder()
            .method("POST")
            .uri("/settings/integrations/resend/disconnect")
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let disconnect_response = app.oneshot(disconnect_request).await?;
        assert_eq!(disconnect_response.status(), StatusCode::OK);
        let disconnect_body = read_text(disconnect_response).await?;
        assert!(disconnect_body.contains("Resend disconnected."));

        Ok(())
    }

    #[tokio::test]
    async fn web_settings_google_connect_unconfigured_returns_web_friendly_failure() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token = authenticate_token(app.clone(), "settings-google-form@openagents.com").await?;

        let non_hx_request = Request::builder()
            .method("GET")
            .uri("/settings/integrations/google/connect")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let non_hx_response = app.clone().oneshot(non_hx_request).await?;
        assert_eq!(non_hx_response.status(), StatusCode::TEMPORARY_REDIRECT);
        assert_eq!(
            non_hx_response
                .headers()
                .get("location")
                .and_then(|value| value.to_str().ok()),
            Some("/settings/profile?status=settings-action-failed")
        );

        let hx_request = Request::builder()
            .method("GET")
            .uri("/settings/integrations/google/connect")
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let hx_response = app.oneshot(hx_request).await?;
        assert_eq!(hx_response.status(), StatusCode::UNPROCESSABLE_ENTITY);
        let hx_body = read_text(hx_response).await?;
        assert!(hx_body.contains("Settings action failed."));

        Ok(())
    }

    #[tokio::test]
    async fn web_l402_and_billing_routes_render_l402_surface_for_authenticated_user() -> Result<()>
    {
        let static_dir = tempdir()?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));

        let fixture = seed_l402_fixture(&config, "web-l402-reader@openagents.com").await?;
        let app = build_router(config);

        let l402_request = Request::builder()
            .method("GET")
            .uri("/l402")
            .header("authorization", format!("Bearer {}", fixture.token))
            .body(Body::empty())?;
        let l402_response = app.clone().oneshot(l402_request).await?;
        assert_eq!(l402_response.status(), StatusCode::OK);
        let l402_body = read_text(l402_response).await?;
        assert!(l402_body.contains("id=\"l402-main-panel\""));
        assert!(l402_body.contains("Billing + L402"));
        assert!(l402_body.contains("sats4ai.com"));
        assert!(l402_body.contains("Recent transactions"));

        let billing_request = Request::builder()
            .method("GET")
            .uri("/billing")
            .header("authorization", format!("Bearer {}", fixture.token))
            .body(Body::empty())?;
        let billing_response = app.clone().oneshot(billing_request).await?;
        assert_eq!(billing_response.status(), StatusCode::OK);
        let billing_body = read_text(billing_response).await?;
        assert!(billing_body.contains("id=\"l402-main-panel\""));
        assert!(billing_body.contains("Paywalls"));

        let unauth_request = Request::builder()
            .method("GET")
            .uri("/l402")
            .body(Body::empty())?;
        let unauth_response = app.oneshot(unauth_request).await?;
        assert_eq!(unauth_response.status(), StatusCode::TEMPORARY_REDIRECT);
        assert_eq!(
            unauth_response
                .headers()
                .get("location")
                .and_then(|value| value.to_str().ok()),
            Some("/login")
        );

        Ok(())
    }

    #[tokio::test]
    async fn web_l402_paywall_mutations_require_admin_and_support_htmx_flows() -> Result<()> {
        let static_dir = tempdir()?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));
        let config_for_lookup = config.clone();

        let admin_token = seed_local_test_token(&config, "routes@openagents.com").await?;
        let member_token = seed_local_test_token(&config, "member-web-l402@openagents.com").await?;
        let app = build_router(config);

        let forbidden_create_request = Request::builder()
            .method("POST")
            .uri("/l402/paywalls/web/create")
            .header("content-type", "application/x-www-form-urlencoded")
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {member_token}"))
            .body(Body::from(
                "name=Default&host_regexp=sats4ai%5C.com&path_regexp=%5E%2Fapi%2F.*&price_msats=1000&upstream=https%3A%2F%2Fupstream.openagents.com&enabled=on",
            ))?;
        let forbidden_create_response = app.clone().oneshot(forbidden_create_request).await?;
        assert_eq!(forbidden_create_response.status(), StatusCode::FORBIDDEN);
        let forbidden_create_body = read_text(forbidden_create_response).await?;
        assert!(forbidden_create_body.contains("Admin role required for this action."));

        let create_request = Request::builder()
            .method("POST")
            .uri("/l402/paywalls/web/create")
            .header("content-type", "application/x-www-form-urlencoded")
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {admin_token}"))
            .body(Body::from(
                "name=Default&host_regexp=sats4ai%5C.com&path_regexp=%5E%2Fapi%2F.*&price_msats=1000&upstream=https%3A%2F%2Fupstream.openagents.com&enabled=on",
            ))?;
        let create_response = app.clone().oneshot(create_request).await?;
        assert_eq!(create_response.status(), StatusCode::OK);
        let create_body = read_text(create_response).await?;
        assert!(create_body.contains("L402 paywall created."));

        let auth = super::AuthService::from_config(&config_for_lookup);
        let admin_bundle = auth
            .session_from_access_token(&admin_token)
            .await
            .expect("admin session");
        let store_after_create = super::DomainStore::from_config(&config_for_lookup);
        let created_paywalls = store_after_create
            .list_l402_paywalls_for_owner(&admin_bundle.user.id, false)
            .await
            .expect("created paywalls");
        assert_eq!(created_paywalls.len(), 1);
        let paywall_id = created_paywalls[0].id.clone();
        assert!(created_paywalls[0].enabled);

        let toggle_request = Request::builder()
            .method("POST")
            .uri(format!("/l402/paywalls/web/{paywall_id}/toggle"))
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {admin_token}"))
            .body(Body::empty())?;
        let toggle_response = app.clone().oneshot(toggle_request).await?;
        assert_eq!(toggle_response.status(), StatusCode::OK);
        let toggle_body = read_text(toggle_response).await?;
        assert!(toggle_body.contains("L402 paywall updated."));

        let store_after_toggle = super::DomainStore::from_config(&config_for_lookup);
        let toggled_paywalls = store_after_toggle
            .list_l402_paywalls_for_owner(&admin_bundle.user.id, false)
            .await
            .expect("toggled paywalls");
        assert_eq!(toggled_paywalls.len(), 1);
        assert!(!toggled_paywalls[0].enabled);

        let delete_request = Request::builder()
            .method("POST")
            .uri(format!("/l402/paywalls/web/{paywall_id}/delete"))
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {admin_token}"))
            .body(Body::empty())?;
        let delete_response = app.clone().oneshot(delete_request).await?;
        assert_eq!(delete_response.status(), StatusCode::OK);
        let delete_body = read_text(delete_response).await?;
        assert!(delete_body.contains("L402 paywall deleted."));

        let store_after_delete = super::DomainStore::from_config(&config_for_lookup);
        let deleted_paywalls = store_after_delete
            .list_l402_paywalls_for_owner(&admin_bundle.user.id, true)
            .await
            .expect("deleted paywalls");
        let deleted = deleted_paywalls
            .iter()
            .find(|row| row.id == paywall_id)
            .expect("deleted paywall present");
        assert!(deleted.deleted_at.is_some());

        Ok(())
    }

    #[tokio::test]
    async fn web_admin_page_shows_forbidden_state_for_members_and_controls_for_admins() -> Result<()>
    {
        let static_dir = tempdir()?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));

        let admin_token = seed_local_test_token(&config, "routes@openagents.com").await?;
        let member_token =
            seed_local_test_token(&config, "member-web-admin@openagents.com").await?;
        let app = build_router(config);

        let member_request = Request::builder()
            .method("GET")
            .uri("/admin")
            .header("authorization", format!("Bearer {member_token}"))
            .body(Body::empty())?;
        let member_response = app.clone().oneshot(member_request).await?;
        assert_eq!(member_response.status(), StatusCode::OK);
        let member_body = read_text(member_response).await?;
        assert!(member_body.contains("Admin role required for control-plane actions."));
        assert!(member_body.contains("Control actions are blocked for non-admin accounts."));

        let admin_request = Request::builder()
            .method("GET")
            .uri("/admin")
            .header("authorization", format!("Bearer {admin_token}"))
            .body(Body::empty())?;
        let admin_response = app.oneshot(admin_request).await?;
        assert_eq!(admin_response.status(), StatusCode::OK);
        let admin_body = read_text(admin_response).await?;
        assert!(admin_body.contains("Route Split Status"));
        assert!(admin_body.contains("Runtime Routing Status"));
        assert!(admin_body.contains("/admin/route-split/evaluate"));
        assert!(admin_body.contains("/admin/lightning-ops/query"));

        Ok(())
    }

    #[tokio::test]
    async fn web_admin_route_split_and_runtime_override_render_htmx_result_fragments() -> Result<()>
    {
        let static_dir = tempdir()?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));

        let admin_token = seed_local_test_token(&config, "routes@openagents.com").await?;
        let member_token =
            seed_local_test_token(&config, "member-web-admin-gate@openagents.com").await?;
        let app = build_router(config);

        let forbidden_request = Request::builder()
            .method("POST")
            .uri("/admin/route-split/evaluate")
            .header("content-type", "application/x-www-form-urlencoded")
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {member_token}"))
            .body(Body::from("path=%2Fchat"))?;
        let forbidden_response = app.clone().oneshot(forbidden_request).await?;
        assert_eq!(forbidden_response.status(), StatusCode::FORBIDDEN);
        let forbidden_body = read_text(forbidden_response).await?;
        assert!(forbidden_body.contains("Admin role required."));

        let evaluate_request = Request::builder()
            .method("POST")
            .uri("/admin/route-split/evaluate")
            .header("content-type", "application/x-www-form-urlencoded")
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {admin_token}"))
            .body(Body::from("path=%2Fchat%2Fthread_123&cohort_key=user%3A1"))?;
        let evaluate_response = app.clone().oneshot(evaluate_request).await?;
        assert_eq!(evaluate_response.status(), StatusCode::OK);
        let evaluate_body = read_text(evaluate_response).await?;
        assert!(evaluate_body.contains("id=\"admin-result\""));
        assert!(evaluate_body.contains("&quot;action&quot;: &quot;route_split.evaluate&quot;"));

        let invalid_override_request = Request::builder()
            .method("POST")
            .uri("/admin/runtime-routing/override")
            .header("content-type", "application/x-www-form-urlencoded")
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {admin_token}"))
            .body(Body::from("scope_type=user&scope_id=usr_1&driver=invalid"))?;
        let invalid_override_response = app.clone().oneshot(invalid_override_request).await?;
        assert_eq!(
            invalid_override_response.status(),
            StatusCode::UNPROCESSABLE_ENTITY
        );
        let invalid_override_body = read_text(invalid_override_response).await?;
        assert!(invalid_override_body.contains("id=\"admin-result\""));
        assert!(invalid_override_body.contains("invalid_driver"));

        let override_request = Request::builder()
            .method("POST")
            .uri("/admin/runtime-routing/override")
            .header("content-type", "application/x-www-form-urlencoded")
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {admin_token}"))
            .body(Body::from(
                "scope_type=user&scope_id=usr_1&driver=legacy&is_active=on&reason=manual",
            ))?;
        let override_response = app.oneshot(override_request).await?;
        assert_eq!(override_response.status(), StatusCode::OK);
        let override_body = read_text(override_response).await?;
        assert!(override_body.contains("id=\"admin-result\""));
        assert!(override_body.contains("&quot;action&quot;: &quot;runtime_routing.override&quot;"));

        Ok(())
    }

    #[tokio::test]
    async fn web_admin_lightning_ops_forms_render_query_and_validation_results() -> Result<()> {
        let static_dir = tempdir()?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));

        let admin_token = seed_local_test_token(&config, "routes@openagents.com").await?;
        let app = build_router(config);

        let invalid_args_request = Request::builder()
            .method("POST")
            .uri("/admin/lightning-ops/query")
            .header("content-type", "application/x-www-form-urlencoded")
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {admin_token}"))
            .body(Body::from(
                "function_name=lightning%2Fops%3AlistPaywallControlPlaneState&args_json=not-json",
            ))?;
        let invalid_args_response = app.clone().oneshot(invalid_args_request).await?;
        assert_eq!(
            invalid_args_response.status(),
            StatusCode::UNPROCESSABLE_ENTITY
        );
        let invalid_args_body = read_text(invalid_args_response).await?;
        assert!(invalid_args_body.contains("id=\"admin-result\""));
        assert!(invalid_args_body.contains("invalid_args_json"));

        let query_request = Request::builder()
            .method("POST")
            .uri("/admin/lightning-ops/query")
            .header("content-type", "application/x-www-form-urlencoded")
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {admin_token}"))
            .body(Body::from(
                "function_name=lightning%2Fops%3AlistPaywallControlPlaneState&args_json=%7B%22secret%22%3A%22ops-secret-test%22%7D",
            ))?;
        let query_response = app.oneshot(query_request).await?;
        assert_eq!(query_response.status(), StatusCode::OK);
        let query_body = read_text(query_response).await?;
        assert!(query_body.contains("id=\"admin-result\""));
        assert!(query_body.contains("&quot;ok&quot;: true"));

        Ok(())
    }

    #[tokio::test]
    async fn htmx_dual_mode_contract_matrix_for_web_mutation_endpoints() -> Result<()> {
        let static_dir = tempdir()?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));
        config.codex_thread_store_path = Some(static_dir.path().join("thread-store.json"));

        let admin_token = seed_local_test_token(&config, "routes@openagents.com").await?;
        let app = build_router(config);

        let chat_new_hx_request = Request::builder()
            .method("POST")
            .uri("/chat/new")
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {admin_token}"))
            .body(Body::empty())?;
        let chat_new_hx_response = app.clone().oneshot(chat_new_hx_request).await?;
        assert_eq!(chat_new_hx_response.status(), StatusCode::OK);
        assert_eq!(
            chat_new_hx_response
                .headers()
                .get(CONTENT_TYPE)
                .and_then(|value| value.to_str().ok()),
            Some("text/html; charset=utf-8")
        );
        let chat_new_hx_body = read_text(chat_new_hx_response).await?;
        assert!(chat_new_hx_body.contains("id=\"chat-thread-content-panel\""));
        assert!(!chat_new_hx_body.contains("<html"));

        let chat_new_non_hx_request = Request::builder()
            .method("POST")
            .uri("/chat/new")
            .header("authorization", format!("Bearer {admin_token}"))
            .body(Body::empty())?;
        let chat_new_non_hx_response = app.clone().oneshot(chat_new_non_hx_request).await?;
        assert_eq!(
            chat_new_non_hx_response.status(),
            StatusCode::TEMPORARY_REDIRECT
        );
        let chat_location = chat_new_non_hx_response
            .headers()
            .get("location")
            .and_then(|value| value.to_str().ok())
            .unwrap_or_default()
            .to_string();
        assert!(chat_location.starts_with("/chat/thread_"));
        let thread_id = chat_location
            .trim_start_matches("/chat/")
            .split('?')
            .next()
            .unwrap_or_default()
            .to_string();
        assert!(!thread_id.is_empty());

        let chat_send_hx_request = Request::builder()
            .method("POST")
            .uri(format!("/chat/{thread_id}/send"))
            .header("content-type", "application/x-www-form-urlencoded")
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {admin_token}"))
            .body(Body::from("text=contract+matrix"))?;
        let chat_send_hx_response = app.clone().oneshot(chat_send_hx_request).await?;
        assert_eq!(chat_send_hx_response.status(), StatusCode::OK);
        assert_eq!(
            chat_send_hx_response
                .headers()
                .get("HX-Trigger")
                .and_then(|value| value.to_str().ok()),
            Some("chat-message-sent")
        );
        let chat_send_hx_body = read_text(chat_send_hx_response).await?;
        assert!(chat_send_hx_body.contains("id=\"chat-status\""));
        assert!(!chat_send_hx_body.contains("<html"));

        let chat_send_non_hx_request = Request::builder()
            .method("POST")
            .uri(format!("/chat/{thread_id}/send"))
            .header("content-type", "application/x-www-form-urlencoded")
            .header("authorization", format!("Bearer {admin_token}"))
            .body(Body::from("text=contract+matrix+nonhx"))?;
        let chat_send_non_hx_response = app.clone().oneshot(chat_send_non_hx_request).await?;
        assert_eq!(
            chat_send_non_hx_response.status(),
            StatusCode::TEMPORARY_REDIRECT
        );
        let expected_chat_location = format!("/chat/{thread_id}?status=message-sent");
        assert_eq!(
            chat_send_non_hx_response
                .headers()
                .get("location")
                .and_then(|value| value.to_str().ok()),
            Some(expected_chat_location.as_str())
        );

        let feed_hx_request = Request::builder()
            .method("POST")
            .uri("/feed/shout")
            .header("content-type", "application/x-www-form-urlencoded")
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {admin_token}"))
            .body(Body::from("zone=dev&body=dual+mode"))?;
        let feed_hx_response = app.clone().oneshot(feed_hx_request).await?;
        assert_eq!(feed_hx_response.status(), StatusCode::OK);
        assert_eq!(
            feed_hx_response
                .headers()
                .get("HX-Trigger")
                .and_then(|value| value.to_str().ok()),
            Some("feed-shout-posted")
        );
        let feed_hx_body = read_text(feed_hx_response).await?;
        assert!(feed_hx_body.contains("id=\"feed-status\""));
        assert!(!feed_hx_body.contains("<html"));

        let feed_non_hx_request = Request::builder()
            .method("POST")
            .uri("/feed/shout")
            .header("content-type", "application/x-www-form-urlencoded")
            .header("authorization", format!("Bearer {admin_token}"))
            .body(Body::from("zone=dev&body=dual+mode+nonhx"))?;
        let feed_non_hx_response = app.clone().oneshot(feed_non_hx_request).await?;
        assert_eq!(
            feed_non_hx_response.status(),
            StatusCode::TEMPORARY_REDIRECT
        );
        assert_eq!(
            feed_non_hx_response
                .headers()
                .get("location")
                .and_then(|value| value.to_str().ok()),
            Some("/feed?zone=dev&status=shout-posted")
        );

        let settings_hx_request = Request::builder()
            .method("POST")
            .uri("/settings/profile/update")
            .header("content-type", "application/x-www-form-urlencoded")
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {admin_token}"))
            .body(Body::from("name=Dual+Mode+Tester"))?;
        let settings_hx_response = app.clone().oneshot(settings_hx_request).await?;
        assert_eq!(settings_hx_response.status(), StatusCode::OK);
        let settings_hx_body = read_text(settings_hx_response).await?;
        assert!(settings_hx_body.contains("id=\"settings-status\""));
        assert!(!settings_hx_body.contains("<html"));

        let settings_non_hx_request = Request::builder()
            .method("POST")
            .uri("/settings/profile/update")
            .header("content-type", "application/x-www-form-urlencoded")
            .header("authorization", format!("Bearer {admin_token}"))
            .body(Body::from("name=Dual+Mode+Tester+NonHX"))?;
        let settings_non_hx_response = app.clone().oneshot(settings_non_hx_request).await?;
        assert_eq!(
            settings_non_hx_response.status(),
            StatusCode::TEMPORARY_REDIRECT
        );
        assert_eq!(
            settings_non_hx_response
                .headers()
                .get("location")
                .and_then(|value| value.to_str().ok()),
            Some("/settings/profile?status=profile-updated")
        );

        let l402_hx_request = Request::builder()
            .method("POST")
            .uri("/l402/paywalls/web/create")
            .header("content-type", "application/x-www-form-urlencoded")
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {admin_token}"))
            .body(Body::from(
                "name=Dual%20Mode&host_regexp=sats4ai%5C.com&path_regexp=%5E%2Fapi%2F.*&price_msats=1000&upstream=https%3A%2F%2Fupstream.openagents.com&enabled=on",
            ))?;
        let l402_hx_response = app.clone().oneshot(l402_hx_request).await?;
        assert_eq!(l402_hx_response.status(), StatusCode::OK);
        let l402_hx_body = read_text(l402_hx_response).await?;
        assert!(l402_hx_body.contains("id=\"billing-status\""));
        assert!(!l402_hx_body.contains("<html"));

        let l402_non_hx_request = Request::builder()
            .method("POST")
            .uri("/l402/paywalls/web/create")
            .header("content-type", "application/x-www-form-urlencoded")
            .header("authorization", format!("Bearer {admin_token}"))
            .body(Body::from(
                "name=Dual%20Mode%20NonHX&host_regexp=sats4ai%5C.com&path_regexp=%5E%2Fapi%2F.*&price_msats=1000&upstream=https%3A%2F%2Fupstream.openagents.com&enabled=on",
            ))?;
        let l402_non_hx_response = app.clone().oneshot(l402_non_hx_request).await?;
        assert_eq!(
            l402_non_hx_response.status(),
            StatusCode::TEMPORARY_REDIRECT
        );
        assert_eq!(
            l402_non_hx_response
                .headers()
                .get("location")
                .and_then(|value| value.to_str().ok()),
            Some("/l402?status=l402-paywall-created")
        );

        let admin_hx_request = Request::builder()
            .method("POST")
            .uri("/admin/route-split/evaluate")
            .header("content-type", "application/x-www-form-urlencoded")
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {admin_token}"))
            .body(Body::from("path=%2Fchat%2Fthread_1"))?;
        let admin_hx_response = app.clone().oneshot(admin_hx_request).await?;
        assert_eq!(admin_hx_response.status(), StatusCode::OK);
        let admin_hx_body = read_text(admin_hx_response).await?;
        assert!(admin_hx_body.contains("id=\"admin-result\""));
        assert!(!admin_hx_body.contains("<html"));

        let admin_non_hx_request = Request::builder()
            .method("POST")
            .uri("/admin/route-split/evaluate")
            .header("content-type", "application/x-www-form-urlencoded")
            .header("authorization", format!("Bearer {admin_token}"))
            .body(Body::from("path=%2Fchat%2Fthread_1"))?;
        let admin_non_hx_response = app.oneshot(admin_non_hx_request).await?;
        assert_eq!(
            admin_non_hx_response.status(),
            StatusCode::TEMPORARY_REDIRECT
        );
        assert_eq!(
            admin_non_hx_response
                .headers()
                .get("location")
                .and_then(|value| value.to_str().ok()),
            Some("/admin?status=admin-action-completed")
        );

        Ok(())
    }

    #[tokio::test]
    async fn web_chat_new_thread_hx_returns_partial_fragment_and_push_url() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.codex_thread_store_path = Some(static_dir.path().join("thread-store.json"));
        let token = seed_local_test_token(&config, "chat-hx-new@openagents.com").await?;
        let app = build_router(config);

        let request = Request::builder()
            .method("POST")
            .uri("/chat/new")
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let response = app.oneshot(request).await?;
        assert_eq!(response.status(), StatusCode::OK);
        let push_url = response
            .headers()
            .get("HX-Push-Url")
            .and_then(|value| value.to_str().ok())
            .unwrap_or_default()
            .to_string();
        assert!(push_url.starts_with("/chat/thread_"));

        let body = read_text(response).await?;
        assert!(body.contains("id=\"chat-thread-content-panel\""));
        assert!(body.contains("id=\"chat-thread-list-panel\""));
        assert!(body.contains("hx-swap-oob=\"outerHTML\""));
        assert!(body.contains("Thread created."));
        assert!(!body.contains("<html"));
        assert!(!body.contains("<body"));

        Ok(())
    }

    #[tokio::test]
    async fn web_chat_thread_select_hx_updates_partial_and_non_hx_redirects() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.codex_thread_store_path = Some(static_dir.path().join("thread-store.json"));
        let token = seed_local_test_token(&config, "chat-hx-select@openagents.com").await?;
        let app = build_router(config);

        let first_create = Request::builder()
            .method("POST")
            .uri("/chat/new")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let first_create_response = app.clone().oneshot(first_create).await?;
        assert_eq!(
            first_create_response.status(),
            StatusCode::TEMPORARY_REDIRECT
        );
        let first_location = first_create_response
            .headers()
            .get("location")
            .and_then(|value| value.to_str().ok())
            .unwrap_or_default()
            .to_string();
        let first_thread_id = first_location
            .trim_start_matches("/chat/")
            .split('?')
            .next()
            .unwrap_or_default()
            .to_string();
        assert!(first_thread_id.starts_with("thread_"));

        let second_create = Request::builder()
            .method("POST")
            .uri("/chat/new")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let second_create_response = app.clone().oneshot(second_create).await?;
        assert_eq!(
            second_create_response.status(),
            StatusCode::TEMPORARY_REDIRECT
        );
        let second_location = second_create_response
            .headers()
            .get("location")
            .and_then(|value| value.to_str().ok())
            .unwrap_or_default()
            .to_string();
        let second_thread_id = second_location
            .trim_start_matches("/chat/")
            .split('?')
            .next()
            .unwrap_or_default()
            .to_string();
        assert!(second_thread_id.starts_with("thread_"));
        assert_ne!(second_thread_id, first_thread_id);

        let select_request = Request::builder()
            .method("GET")
            .uri(format!("/chat/fragments/thread/{second_thread_id}"))
            .header("hx-request", "true")
            .header("hx-target", "chat-thread-content-panel")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let select_response = app.clone().oneshot(select_request).await?;
        assert_eq!(select_response.status(), StatusCode::OK);
        let expected_push_url = format!("/chat/{second_thread_id}");
        assert_eq!(
            select_response
                .headers()
                .get("HX-Push-Url")
                .and_then(|value| value.to_str().ok()),
            Some(expected_push_url.as_str())
        );
        let select_body = read_text(select_response).await?;
        assert!(select_body.contains("id=\"chat-thread-content-panel\""));
        assert!(select_body.contains("hx-swap-oob=\"outerHTML\""));
        assert!(select_body.contains(&format!("Thread: <code>{second_thread_id}</code>")));
        assert!(select_body.contains("oa-thread-link active"));
        assert!(!select_body.contains("<html"));

        let non_hx_request = Request::builder()
            .method("GET")
            .uri(format!("/chat/fragments/thread/{second_thread_id}"))
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let non_hx_response = app.oneshot(non_hx_request).await?;
        assert_eq!(non_hx_response.status(), StatusCode::TEMPORARY_REDIRECT);
        let expected_location = format!("/chat/{second_thread_id}");
        assert_eq!(
            non_hx_response
                .headers()
                .get("location")
                .and_then(|value| value.to_str().ok()),
            Some(expected_location.as_str())
        );

        Ok(())
    }

    #[tokio::test]
    async fn web_chat_send_message_hx_success_triggers_incremental_refresh() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.codex_thread_store_path = Some(static_dir.path().join("thread-store.json"));
        let token = seed_local_test_token(&config, "chat-send-success@openagents.com").await?;
        let app = build_router(config);

        let create_request = Request::builder()
            .method("POST")
            .uri("/chat/new")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let create_response = app.clone().oneshot(create_request).await?;
        let location = create_response
            .headers()
            .get("location")
            .and_then(|value| value.to_str().ok())
            .unwrap_or_default()
            .to_string();
        let thread_id = location
            .trim_start_matches("/chat/")
            .split('?')
            .next()
            .unwrap_or_default()
            .to_string();
        assert!(!thread_id.is_empty());

        let send_request = Request::builder()
            .method("POST")
            .uri(format!("/chat/{thread_id}/send"))
            .header("content-type", "application/x-www-form-urlencoded")
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from("text=hello"))?;
        let send_response = app.clone().oneshot(send_request).await?;
        assert_eq!(send_response.status(), StatusCode::OK);
        assert_eq!(
            send_response
                .headers()
                .get("HX-Trigger")
                .and_then(|value| value.to_str().ok()),
            Some("chat-message-sent")
        );
        let send_body = read_text(send_response).await?;
        assert!(send_body.contains("id=\"chat-status\""));
        assert!(send_body.contains("Message queued in thread."));

        let refresh_request = Request::builder()
            .method("GET")
            .uri(format!("/chat/fragments/thread/{thread_id}"))
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let refresh_response = app.oneshot(refresh_request).await?;
        assert_eq!(refresh_response.status(), StatusCode::OK);
        let refresh_body = read_text(refresh_response).await?;
        assert!(refresh_body.contains("hello"));

        Ok(())
    }

    #[tokio::test]
    async fn web_chat_send_message_hx_empty_body_returns_inline_error() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.codex_thread_store_path = Some(static_dir.path().join("thread-store.json"));
        let token = seed_local_test_token(&config, "chat-send-empty@openagents.com").await?;
        let app = build_router(config);

        let create_request = Request::builder()
            .method("POST")
            .uri("/chat/new")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let create_response = app.clone().oneshot(create_request).await?;
        let location = create_response
            .headers()
            .get("location")
            .and_then(|value| value.to_str().ok())
            .unwrap_or_default()
            .to_string();
        let thread_id = location
            .trim_start_matches("/chat/")
            .split('?')
            .next()
            .unwrap_or_default()
            .to_string();
        assert!(!thread_id.is_empty());

        let send_request = Request::builder()
            .method("POST")
            .uri(format!("/chat/{thread_id}/send"))
            .header("content-type", "application/x-www-form-urlencoded")
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from("text=%20%20"))?;
        let send_response = app.oneshot(send_request).await?;
        assert_eq!(send_response.status(), StatusCode::UNPROCESSABLE_ENTITY);
        assert!(
            send_response.headers().get("HX-Trigger").is_none(),
            "validation error should not emit success trigger"
        );
        let send_body = read_text(send_response).await?;
        assert!(send_body.contains("id=\"chat-status\""));
        assert!(send_body.contains("Message body cannot be empty."));

        Ok(())
    }

    #[tokio::test]
    async fn web_chat_send_message_hx_oversized_body_returns_inline_error() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.codex_thread_store_path = Some(static_dir.path().join("thread-store.json"));
        let token = seed_local_test_token(&config, "chat-send-oversize@openagents.com").await?;
        let app = build_router(config);

        let create_request = Request::builder()
            .method("POST")
            .uri("/chat/new")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let create_response = app.clone().oneshot(create_request).await?;
        let location = create_response
            .headers()
            .get("location")
            .and_then(|value| value.to_str().ok())
            .unwrap_or_default()
            .to_string();
        let thread_id = location
            .trim_start_matches("/chat/")
            .split('?')
            .next()
            .unwrap_or_default()
            .to_string();
        assert!(!thread_id.is_empty());

        let oversized = "a".repeat(20_001);
        let send_request = Request::builder()
            .method("POST")
            .uri(format!("/chat/{thread_id}/send"))
            .header("content-type", "application/x-www-form-urlencoded")
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(format!("text={oversized}")))?;
        let send_response = app.oneshot(send_request).await?;
        assert_eq!(send_response.status(), StatusCode::UNPROCESSABLE_ENTITY);
        assert!(send_response.headers().get("HX-Trigger").is_none());
        let send_body = read_text(send_response).await?;
        assert!(send_body.contains("Could not send message."));

        Ok(())
    }

    #[tokio::test]
    async fn web_chat_send_message_hx_store_failure_returns_inline_error() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.codex_thread_store_path = Some(static_dir.path().join("thread-store.json"));
        let owner_token = seed_local_test_token(&config, "chat-send-owner@openagents.com").await?;
        let other_token = seed_local_test_token(&config, "chat-send-other@openagents.com").await?;
        let app = build_router(config);

        let create_request = Request::builder()
            .method("POST")
            .uri("/chat/new")
            .header("authorization", format!("Bearer {owner_token}"))
            .body(Body::empty())?;
        let create_response = app.clone().oneshot(create_request).await?;
        let location = create_response
            .headers()
            .get("location")
            .and_then(|value| value.to_str().ok())
            .unwrap_or_default()
            .to_string();
        let thread_id = location
            .trim_start_matches("/chat/")
            .split('?')
            .next()
            .unwrap_or_default()
            .to_string();
        assert!(!thread_id.is_empty());

        let send_request = Request::builder()
            .method("POST")
            .uri(format!("/chat/{thread_id}/send"))
            .header("content-type", "application/x-www-form-urlencoded")
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {other_token}"))
            .body(Body::from("text=hello"))?;
        let send_response = app.oneshot(send_request).await?;
        assert_eq!(send_response.status(), StatusCode::UNPROCESSABLE_ENTITY);
        assert!(send_response.headers().get("HX-Trigger").is_none());
        let send_body = read_text(send_response).await?;
        assert!(send_body.contains("Could not send message."));

        Ok(())
    }

    #[tokio::test]
    async fn web_chat_fragment_renders_turn_finish_error_tool_from_worker_event_store() -> Result<()>
    {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.codex_thread_store_path = Some(static_dir.path().join("thread-store.json"));
        let token = seed_local_test_token(&config, "chat-worker-bridge@openagents.com").await?;
        let app = build_router(config);

        let create_request = Request::builder()
            .method("POST")
            .uri("/chat/new")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let create_response = app.clone().oneshot(create_request).await?;
        let location = create_response
            .headers()
            .get("location")
            .and_then(|value| value.to_str().ok())
            .unwrap_or_default()
            .to_string();
        let thread_id = location
            .trim_start_matches("/chat/")
            .split('?')
            .next()
            .unwrap_or_default()
            .to_string();
        assert!(!thread_id.is_empty());

        let events = [
            serde_json::json!({
                "event": {
                    "event_type": "worker.event",
                    "payload": {
                        "method": "turn/start",
                        "thread_id": thread_id.clone(),
                        "turn": { "id": "turn_1" },
                        "occurred_at": "2026-02-22T00:00:00Z"
                    }
                }
            }),
            serde_json::json!({
                "event": {
                    "event_type": "worker.event",
                    "payload": {
                        "method": "turn/tool",
                        "thread_id": thread_id.clone(),
                        "tool": { "name": "search", "status": "running" },
                        "occurred_at": "2026-02-22T00:00:01Z"
                    }
                }
            }),
            serde_json::json!({
                "event": {
                    "event_type": "worker.event",
                    "payload": {
                        "method": "turn/error",
                        "thread_id": thread_id.clone(),
                        "error": { "message": "network" },
                        "occurred_at": "2026-02-22T00:00:02Z"
                    }
                }
            }),
            serde_json::json!({
                "event": {
                    "event_type": "worker.event",
                    "payload": {
                        "method": "turn/finish",
                        "thread_id": thread_id.clone(),
                        "output_text": "final answer",
                        "occurred_at": "2026-02-22T00:00:03Z"
                    }
                }
            }),
        ];

        for event in events {
            let request = Request::builder()
                .method("POST")
                .uri(format!("/api/runtime/codex/workers/{thread_id}/events"))
                .header("content-type", "application/json")
                .header("authorization", format!("Bearer {token}"))
                .body(Body::from(event.to_string()))?;
            let response = app.clone().oneshot(request).await?;
            assert_eq!(response.status(), StatusCode::ACCEPTED);
        }

        let fragment_request = Request::builder()
            .method("GET")
            .uri(format!("/chat/fragments/thread/{thread_id}"))
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let fragment_response = app.oneshot(fragment_request).await?;
        assert_eq!(fragment_response.status(), StatusCode::OK);
        let fragment = read_text(fragment_response).await?;

        let start_index = fragment
            .find("Turn started: turn_1")
            .expect("missing turn.start render");
        let tool_index = fragment
            .find("Tool search: running")
            .expect("missing turn.tool render");
        let error_index = fragment
            .find("Turn error: network")
            .expect("missing turn.error render");
        let finish_index = fragment
            .find("Turn finished: final answer")
            .expect("missing turn.finish render");
        assert!(start_index < tool_index);
        assert!(tool_index < error_index);
        assert!(error_index < finish_index);

        Ok(())
    }

    #[tokio::test]
    async fn local_test_login_route_enforces_gates_and_accepts_valid_signature() -> Result<()> {
        let mut config = test_config(std::env::temp_dir());
        config.auth_local_test_login_enabled = true;
        config.auth_local_test_login_allowed_emails = vec!["tester@openagents.com".to_string()];
        config.auth_local_test_login_signing_key = Some("local-test-signing-key".to_string());
        let app = build_router(config);

        let unsigned_request = Request::builder()
            .uri("/internal/test-login?email=tester@openagents.com&expires=4102444800")
            .body(Body::empty())?;
        let unsigned_response = app.clone().oneshot(unsigned_request).await?;
        assert_eq!(unsigned_response.status(), StatusCode::FORBIDDEN);

        let blocked_url = signed_test_login_url(
            "local-test-signing-key",
            "blocked@example.com",
            4_102_444_800,
            Some("MaintenanceTester"),
        );
        let blocked_request = Request::builder().uri(blocked_url).body(Body::empty())?;
        let blocked_response = app.clone().oneshot(blocked_request).await?;
        assert_eq!(blocked_response.status(), StatusCode::FORBIDDEN);

        let allowed_url = signed_test_login_url(
            "local-test-signing-key",
            "tester@openagents.com",
            4_102_444_800,
            Some("MaintenanceTester"),
        );
        let allowed_request = Request::builder().uri(allowed_url).body(Body::empty())?;
        let allowed_response = app.oneshot(allowed_request).await?;
        assert_eq!(allowed_response.status(), StatusCode::TEMPORARY_REDIRECT);
        assert_eq!(
            allowed_response
                .headers()
                .get("location")
                .and_then(|value| value.to_str().ok()),
            Some("/")
        );
        let set_cookies = all_set_cookie_values(&allowed_response);
        assert!(
            set_cookies
                .iter()
                .any(|value| value.starts_with(&format!("{}=", super::AUTH_ACCESS_COOKIE_NAME)))
        );
        assert!(set_cookies.iter().any(|value| {
            value.starts_with(&format!("{}=1", super::LOCAL_TEST_AUTH_COOKIE_NAME))
        }));

        Ok(())
    }

    #[tokio::test]
    async fn local_test_login_route_returns_not_found_when_disabled() -> Result<()> {
        let mut config = test_config(std::env::temp_dir());
        config.auth_local_test_login_enabled = false;
        config.auth_local_test_login_allowed_emails = vec!["tester@openagents.com".to_string()];
        config.auth_local_test_login_signing_key = Some("local-test-signing-key".to_string());
        let app = build_router(config);

        let request = Request::builder()
            .uri(signed_test_login_url(
                "local-test-signing-key",
                "tester@openagents.com",
                4_102_444_800,
                Some("MaintenanceTester"),
            ))
            .body(Body::empty())?;
        let response = app.oneshot(request).await?;
        assert_eq!(response.status(), StatusCode::NOT_FOUND);

        Ok(())
    }

    #[tokio::test]
    async fn refresh_rotates_refresh_token_and_logout_revokes_session() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        let send_request = Request::builder()
            .method("POST")
            .uri("/api/auth/email")
            .header("content-type", "application/json")
            .body(Body::from(r#"{"email":"rotation@example.com"}"#))?;
        let send_response = app.clone().oneshot(send_request).await?;
        let cookie = cookie_value(&send_response).unwrap_or_default();

        let verify_request = Request::builder()
            .method("POST")
            .uri("/api/auth/verify")
            .header("content-type", "application/json")
            .header("x-client", "autopilot-desktop")
            .header("cookie", cookie)
            .body(Body::from(r#"{"code":"123456"}"#))?;
        let verify_response = app.clone().oneshot(verify_request).await?;
        let verify_body = read_json(verify_response).await?;

        let token = verify_body["token"]
            .as_str()
            .unwrap_or_default()
            .to_string();
        let refresh_token = verify_body["refreshToken"]
            .as_str()
            .unwrap_or_default()
            .to_string();

        let refresh_request = Request::builder()
            .method("POST")
            .uri("/api/auth/refresh")
            .header("content-type", "application/json")
            .body(Body::from(format!(
                r#"{{"refresh_token":"{refresh_token}","rotate_refresh_token":true}}"#
            )))?;
        let refresh_response = app.clone().oneshot(refresh_request).await?;
        assert_eq!(refresh_response.status(), StatusCode::OK);
        let refresh_body = read_json(refresh_response).await?;
        let new_token = refresh_body["token"]
            .as_str()
            .unwrap_or_default()
            .to_string();

        let logout_request = Request::builder()
            .method("POST")
            .uri("/api/auth/logout")
            .header("authorization", format!("Bearer {new_token}"))
            .body(Body::empty())?;
        let logout_response = app.clone().oneshot(logout_request).await?;
        assert_eq!(logout_response.status(), StatusCode::OK);

        let old_session_request = Request::builder()
            .uri("/api/auth/session")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let old_session_response = app.oneshot(old_session_request).await?;
        assert_eq!(old_session_response.status(), StatusCode::UNAUTHORIZED);

        Ok(())
    }

    #[tokio::test]
    async fn refresh_token_is_single_use_and_replay_revokes_session() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        let send_request = Request::builder()
            .method("POST")
            .uri("/api/auth/email")
            .header("content-type", "application/json")
            .body(Body::from(r#"{"email":"refresh-replay@example.com"}"#))?;
        let send_response = app.clone().oneshot(send_request).await?;
        let cookie = cookie_value(&send_response).unwrap_or_default();

        let verify_request = Request::builder()
            .method("POST")
            .uri("/api/auth/verify")
            .header("content-type", "application/json")
            .header("x-client", "autopilot-ios")
            .header("x-device-id", "ios-replay-device")
            .header("cookie", cookie)
            .body(Body::from(r#"{"code":"123456"}"#))?;
        let verify_response = app.clone().oneshot(verify_request).await?;
        assert_eq!(verify_response.status(), StatusCode::OK);
        let verify_body = read_json(verify_response).await?;
        let refresh_token = verify_body["refreshToken"]
            .as_str()
            .unwrap_or_default()
            .to_string();

        let rotate_request = Request::builder()
            .method("POST")
            .uri("/api/auth/refresh")
            .header("content-type", "application/json")
            .header("x-device-id", "ios-replay-device")
            .body(Body::from(format!(
                r#"{{"refresh_token":"{refresh_token}","rotate_refresh_token":true,"device_id":"ios-replay-device"}}"#
            )))?;
        let rotate_response = app.clone().oneshot(rotate_request).await?;
        assert_eq!(rotate_response.status(), StatusCode::OK);
        let rotate_body = read_json(rotate_response).await?;
        let rotated_access_token = rotate_body["token"]
            .as_str()
            .unwrap_or_default()
            .to_string();

        let replay_request = Request::builder()
            .method("POST")
            .uri("/api/auth/refresh")
            .header("content-type", "application/json")
            .header("x-device-id", "ios-replay-device")
            .body(Body::from(format!(
                r#"{{"refresh_token":"{refresh_token}","rotate_refresh_token":true,"device_id":"ios-replay-device"}}"#
            )))?;
        let replay_response = app.clone().oneshot(replay_request).await?;
        assert_eq!(replay_response.status(), StatusCode::UNAUTHORIZED);

        let session_after_replay = Request::builder()
            .uri("/api/auth/session")
            .header("authorization", format!("Bearer {rotated_access_token}"))
            .body(Body::empty())?;
        let session_after_replay_response = app.oneshot(session_after_replay).await?;
        assert_eq!(
            session_after_replay_response.status(),
            StatusCode::UNAUTHORIZED
        );

        Ok(())
    }

    #[tokio::test]
    async fn refresh_parallel_rotation_race_revokes_rotated_session() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        let send_request = Request::builder()
            .method("POST")
            .uri("/api/auth/email")
            .header("content-type", "application/json")
            .body(Body::from(r#"{"email":"refresh-race@example.com"}"#))?;
        let send_response = app.clone().oneshot(send_request).await?;
        let cookie = cookie_value(&send_response).unwrap_or_default();

        let verify_request = Request::builder()
            .method("POST")
            .uri("/api/auth/verify")
            .header("content-type", "application/json")
            .header("x-client", "autopilot-ios")
            .header("x-device-id", "ios-race-device")
            .header("cookie", cookie)
            .body(Body::from(r#"{"code":"123456"}"#))?;
        let verify_response = app.clone().oneshot(verify_request).await?;
        assert_eq!(verify_response.status(), StatusCode::OK);
        let verify_body = read_json(verify_response).await?;
        let refresh_token = verify_body["refreshToken"]
            .as_str()
            .unwrap_or_default()
            .to_string();

        let refresh_payload = format!(
            r#"{{"refresh_token":"{refresh_token}","rotate_refresh_token":true,"device_id":"ios-race-device"}}"#
        );
        let refresh_request_a = Request::builder()
            .method("POST")
            .uri("/api/auth/refresh")
            .header("content-type", "application/json")
            .header("x-device-id", "ios-race-device")
            .body(Body::from(refresh_payload.clone()))?;
        let refresh_request_b = Request::builder()
            .method("POST")
            .uri("/api/auth/refresh")
            .header("content-type", "application/json")
            .header("x-device-id", "ios-race-device")
            .body(Body::from(refresh_payload))?;

        let (refresh_a_result, refresh_b_result) = tokio::join!(
            app.clone().oneshot(refresh_request_a),
            app.clone().oneshot(refresh_request_b)
        );
        let refresh_a = refresh_a_result?;
        let refresh_b = refresh_b_result?;

        let mut status_codes = vec![refresh_a.status().as_u16(), refresh_b.status().as_u16()];
        status_codes.sort();
        assert_eq!(status_codes, vec![200, 401]);

        let mut rotated_access_token = String::new();
        for response in [refresh_a, refresh_b] {
            let status = response.status();
            let body = read_json(response).await?;
            if status == StatusCode::OK {
                rotated_access_token = body["token"].as_str().unwrap_or_default().to_string();
            } else {
                assert_eq!(status, StatusCode::UNAUTHORIZED);
                assert_eq!(body["error"]["code"], json!("unauthorized"));
            }
        }

        assert!(!rotated_access_token.is_empty());

        let session_after_race = Request::builder()
            .uri("/api/auth/session")
            .header("authorization", format!("Bearer {rotated_access_token}"))
            .body(Body::empty())?;
        let session_after_race_response = app.oneshot(session_after_race).await?;
        assert_eq!(
            session_after_race_response.status(),
            StatusCode::UNAUTHORIZED
        );

        Ok(())
    }

    #[tokio::test]
    async fn session_listing_and_device_revocation_are_supported() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        let send_a = Request::builder()
            .method("POST")
            .uri("/api/auth/email")
            .header("content-type", "application/json")
            .body(Body::from(r#"{"email":"device-revoke@example.com"}"#))?;
        let send_a_response = app.clone().oneshot(send_a).await?;
        let cookie_a = cookie_value(&send_a_response).unwrap_or_default();

        let verify_a = Request::builder()
            .method("POST")
            .uri("/api/auth/verify")
            .header("content-type", "application/json")
            .header("x-client", "autopilot-ios")
            .header("x-device-id", "ios-device-a")
            .header("cookie", cookie_a)
            .body(Body::from(r#"{"code":"123456"}"#))?;
        let verify_a_response = app.clone().oneshot(verify_a).await?;
        let verify_a_body = read_json(verify_a_response).await?;
        let token_a = verify_a_body["token"]
            .as_str()
            .unwrap_or_default()
            .to_string();

        let send_b = Request::builder()
            .method("POST")
            .uri("/api/auth/email")
            .header("content-type", "application/json")
            .body(Body::from(r#"{"email":"device-revoke@example.com"}"#))?;
        let send_b_response = app.clone().oneshot(send_b).await?;
        let cookie_b = cookie_value(&send_b_response).unwrap_or_default();

        let verify_b = Request::builder()
            .method("POST")
            .uri("/api/auth/verify")
            .header("content-type", "application/json")
            .header("x-client", "autopilot-ios")
            .header("x-device-id", "ios-device-b")
            .header("cookie", cookie_b)
            .body(Body::from(r#"{"code":"123456"}"#))?;
        let verify_b_response = app.clone().oneshot(verify_b).await?;
        let verify_b_body = read_json(verify_b_response).await?;
        let token_b = verify_b_body["token"]
            .as_str()
            .unwrap_or_default()
            .to_string();

        let list_request = Request::builder()
            .uri("/api/auth/sessions")
            .header("authorization", format!("Bearer {token_a}"))
            .body(Body::empty())?;
        let list_response = app.clone().oneshot(list_request).await?;
        assert_eq!(list_response.status(), StatusCode::OK);
        let list_body = read_json(list_response).await?;
        let sessions = list_body["data"]["sessions"]
            .as_array()
            .cloned()
            .unwrap_or_default();
        assert_eq!(sessions.len(), 2);

        let revoke_request = Request::builder()
            .method("POST")
            .uri("/api/auth/sessions/revoke")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token_a}"))
            .body(Body::from(
                r#"{"device_id":"ios-device-b","reason":"user_requested","include_current":false}"#,
            ))?;
        let revoke_response = app.clone().oneshot(revoke_request).await?;
        assert_eq!(revoke_response.status(), StatusCode::OK);
        let revoke_body = read_json(revoke_response).await?;
        let revoked_sessions = revoke_body["revokedSessionIds"]
            .as_array()
            .cloned()
            .unwrap_or_default();
        let revoked_devices = revoke_body["revokedDeviceIds"]
            .as_array()
            .cloned()
            .unwrap_or_default();
        assert_eq!(revoked_sessions.len(), 1);
        assert_eq!(revoked_devices, vec![json!("ios-device-b")]);

        let current_a = Request::builder()
            .uri("/api/auth/session")
            .header("authorization", format!("Bearer {token_a}"))
            .body(Body::empty())?;
        let current_a_response = app.clone().oneshot(current_a).await?;
        assert_eq!(current_a_response.status(), StatusCode::OK);

        let current_b = Request::builder()
            .uri("/api/auth/session")
            .header("authorization", format!("Bearer {token_b}"))
            .body(Body::empty())?;
        let current_b_response = app.oneshot(current_b).await?;
        assert_eq!(current_b_response.status(), StatusCode::UNAUTHORIZED);

        Ok(())
    }

    #[tokio::test]
    async fn global_revocation_supports_include_current_toggle() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        let send_a = Request::builder()
            .method("POST")
            .uri("/api/auth/email")
            .header("content-type", "application/json")
            .body(Body::from(r#"{"email":"global-revoke@example.com"}"#))?;
        let send_a_response = app.clone().oneshot(send_a).await?;
        let cookie_a = cookie_value(&send_a_response).unwrap_or_default();

        let verify_a = Request::builder()
            .method("POST")
            .uri("/api/auth/verify")
            .header("content-type", "application/json")
            .header("x-client", "autopilot-ios")
            .header("x-device-id", "ios-global-a")
            .header("cookie", cookie_a)
            .body(Body::from(r#"{"code":"123456"}"#))?;
        let verify_a_response = app.clone().oneshot(verify_a).await?;
        let verify_a_body = read_json(verify_a_response).await?;
        let token_a = verify_a_body["token"]
            .as_str()
            .unwrap_or_default()
            .to_string();

        let send_b = Request::builder()
            .method("POST")
            .uri("/api/auth/email")
            .header("content-type", "application/json")
            .body(Body::from(r#"{"email":"global-revoke@example.com"}"#))?;
        let send_b_response = app.clone().oneshot(send_b).await?;
        let cookie_b = cookie_value(&send_b_response).unwrap_or_default();

        let verify_b = Request::builder()
            .method("POST")
            .uri("/api/auth/verify")
            .header("content-type", "application/json")
            .header("x-client", "autopilot-ios")
            .header("x-device-id", "ios-global-b")
            .header("cookie", cookie_b)
            .body(Body::from(r#"{"code":"123456"}"#))?;
        let verify_b_response = app.clone().oneshot(verify_b).await?;
        let verify_b_body = read_json(verify_b_response).await?;
        let token_b = verify_b_body["token"]
            .as_str()
            .unwrap_or_default()
            .to_string();

        let revoke_others_request = Request::builder()
            .method("POST")
            .uri("/api/auth/sessions/revoke")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token_a}"))
            .body(Body::from(
                r#"{"revoke_all_sessions":true,"include_current":false,"reason":"user_requested"}"#,
            ))?;
        let revoke_others_response = app.clone().oneshot(revoke_others_request).await?;
        assert_eq!(revoke_others_response.status(), StatusCode::OK);

        let current_a = Request::builder()
            .uri("/api/auth/session")
            .header("authorization", format!("Bearer {token_a}"))
            .body(Body::empty())?;
        let current_a_response = app.clone().oneshot(current_a).await?;
        assert_eq!(current_a_response.status(), StatusCode::OK);

        let current_b = Request::builder()
            .uri("/api/auth/session")
            .header("authorization", format!("Bearer {token_b}"))
            .body(Body::empty())?;
        let current_b_response = app.clone().oneshot(current_b).await?;
        assert_eq!(current_b_response.status(), StatusCode::UNAUTHORIZED);

        let revoke_all_request = Request::builder()
            .method("POST")
            .uri("/api/auth/sessions/revoke")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token_a}"))
            .body(Body::from(
                r#"{"revoke_all_sessions":true,"include_current":true,"reason":"user_requested"}"#,
            ))?;
        let revoke_all_response = app.clone().oneshot(revoke_all_request).await?;
        assert_eq!(revoke_all_response.status(), StatusCode::OK);

        let current_a_after = Request::builder()
            .uri("/api/auth/session")
            .header("authorization", format!("Bearer {token_a}"))
            .body(Body::empty())?;
        let current_a_after_response = app.oneshot(current_a_after).await?;
        assert_eq!(current_a_after_response.status(), StatusCode::UNAUTHORIZED);

        Ok(())
    }

    #[tokio::test]
    async fn logout_propagates_runtime_revocation_when_configured() -> Result<()> {
        let captured = Arc::new(Mutex::new(Vec::<Value>::new()));
        let (runtime_addr, runtime_handle) =
            start_runtime_revocation_stub(captured.clone()).await?;

        let mut config = test_config(std::env::temp_dir());
        config.runtime_sync_revoke_base_url = Some(format!("http://{runtime_addr}"));
        config.runtime_sync_revoke_path = "/internal/v1/sync/sessions/revoke".to_string();
        config.runtime_signature_secret = Some("runtime-signature-secret".to_string());
        config.runtime_signature_ttl_seconds = 60;

        let app = build_router(config);

        let send_request = Request::builder()
            .method("POST")
            .uri("/api/auth/email")
            .header("content-type", "application/json")
            .body(Body::from(r#"{"email":"runtime-revoke@openagents.com"}"#))?;
        let send_response = app.clone().oneshot(send_request).await?;
        let cookie = cookie_value(&send_response).unwrap_or_default();

        let verify_request = Request::builder()
            .method("POST")
            .uri("/api/auth/verify")
            .header("content-type", "application/json")
            .header("x-client", "autopilot-ios")
            .header("x-device-id", "ios-runtime-revoke")
            .header("cookie", cookie)
            .body(Body::from(r#"{"code":"123456"}"#))?;
        let verify_response = app.clone().oneshot(verify_request).await?;
        let verify_body = read_json(verify_response).await?;
        let token = verify_body["token"]
            .as_str()
            .unwrap_or_default()
            .to_string();

        let logout_request = Request::builder()
            .method("POST")
            .uri("/api/auth/logout")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let logout_response = app.clone().oneshot(logout_request).await?;
        assert_eq!(logout_response.status(), StatusCode::OK);
        let logout_body = read_json(logout_response).await?;
        let revoked_session_id = logout_body["sessionId"]
            .as_str()
            .unwrap_or_default()
            .to_string();
        assert!(!revoked_session_id.is_empty());

        let records = captured.lock().await.clone();
        assert_eq!(records.len(), 1);
        assert!(
            records[0]["signature"]
                .as_str()
                .unwrap_or_default()
                .starts_with("v1.")
        );
        assert_eq!(records[0]["payload"]["reason"], "user_requested");
        assert_eq!(
            records[0]["payload"]["session_ids"]
                .as_array()
                .cloned()
                .unwrap_or_default(),
            vec![Value::String(revoked_session_id)]
        );
        assert_eq!(
            records[0]["payload"]["device_ids"]
                .as_array()
                .cloned()
                .unwrap_or_default(),
            vec![json!("ios-runtime-revoke")]
        );

        runtime_handle.abort();

        Ok(())
    }

    #[tokio::test]
    async fn revoke_other_device_propagates_runtime_revocation_device_ids() -> Result<()> {
        let captured = Arc::new(Mutex::new(Vec::<Value>::new()));
        let (runtime_addr, runtime_handle) =
            start_runtime_revocation_stub(captured.clone()).await?;

        let mut config = test_config(std::env::temp_dir());
        config.runtime_sync_revoke_base_url = Some(format!("http://{runtime_addr}"));
        config.runtime_sync_revoke_path = "/internal/v1/sync/sessions/revoke".to_string();
        config.runtime_signature_secret = Some("runtime-signature-secret".to_string());
        config.runtime_signature_ttl_seconds = 60;
        let app = build_router(config);

        let send_a = Request::builder()
            .method("POST")
            .uri("/api/auth/email")
            .header("content-type", "application/json")
            .body(Body::from(
                r#"{"email":"runtime-device-revoke@openagents.com"}"#,
            ))?;
        let send_a_response = app.clone().oneshot(send_a).await?;
        let cookie_a = cookie_value(&send_a_response).unwrap_or_default();
        let verify_a = Request::builder()
            .method("POST")
            .uri("/api/auth/verify")
            .header("content-type", "application/json")
            .header("x-client", "autopilot-ios")
            .header("x-device-id", "ios-runtime-a")
            .header("cookie", cookie_a)
            .body(Body::from(r#"{"code":"123456"}"#))?;
        let verify_a_response = app.clone().oneshot(verify_a).await?;
        let verify_a_body = read_json(verify_a_response).await?;
        let token_a = verify_a_body["token"]
            .as_str()
            .unwrap_or_default()
            .to_string();

        let send_b = Request::builder()
            .method("POST")
            .uri("/api/auth/email")
            .header("content-type", "application/json")
            .body(Body::from(
                r#"{"email":"runtime-device-revoke@openagents.com"}"#,
            ))?;
        let send_b_response = app.clone().oneshot(send_b).await?;
        let cookie_b = cookie_value(&send_b_response).unwrap_or_default();
        let verify_b = Request::builder()
            .method("POST")
            .uri("/api/auth/verify")
            .header("content-type", "application/json")
            .header("x-client", "autopilot-ios")
            .header("x-device-id", "ios-runtime-b")
            .header("cookie", cookie_b)
            .body(Body::from(r#"{"code":"123456"}"#))?;
        let verify_b_response = app.clone().oneshot(verify_b).await?;
        let verify_b_body = read_json(verify_b_response).await?;
        let token_b = verify_b_body["token"]
            .as_str()
            .unwrap_or_default()
            .to_string();

        let revoke_request = Request::builder()
            .method("POST")
            .uri("/api/auth/sessions/revoke")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token_a}"))
            .body(Body::from(
                r#"{"device_id":"ios-runtime-b","reason":"user_requested","include_current":false}"#,
            ))?;
        let revoke_response = app.clone().oneshot(revoke_request).await?;
        assert_eq!(revoke_response.status(), StatusCode::OK);
        let revoke_body = read_json(revoke_response).await?;
        let revoked_session_ids = revoke_body["revokedSessionIds"]
            .as_array()
            .cloned()
            .unwrap_or_default();
        assert_eq!(revoked_session_ids.len(), 1);
        assert_eq!(
            revoke_body["revokedDeviceIds"]
                .as_array()
                .cloned()
                .unwrap_or_default(),
            vec![json!("ios-runtime-b")]
        );

        let records = captured.lock().await.clone();
        assert_eq!(records.len(), 1);
        assert_eq!(records[0]["payload"]["reason"], "user_requested");
        assert_eq!(
            records[0]["payload"]["device_ids"]
                .as_array()
                .cloned()
                .unwrap_or_default(),
            vec![json!("ios-runtime-b")]
        );
        assert_eq!(
            records[0]["payload"]["session_ids"]
                .as_array()
                .cloned()
                .unwrap_or_default(),
            revoked_session_ids
        );

        let current_a = Request::builder()
            .uri("/api/auth/session")
            .header("authorization", format!("Bearer {token_a}"))
            .body(Body::empty())?;
        let current_a_response = app.clone().oneshot(current_a).await?;
        assert_eq!(current_a_response.status(), StatusCode::OK);

        let current_b = Request::builder()
            .uri("/api/auth/session")
            .header("authorization", format!("Bearer {token_b}"))
            .body(Body::empty())?;
        let current_b_response = app.oneshot(current_b).await?;
        assert_eq!(current_b_response.status(), StatusCode::UNAUTHORIZED);

        runtime_handle.abort();

        Ok(())
    }

    #[tokio::test]
    async fn org_membership_and_policy_matrix_enforces_boundaries() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        let send_request = Request::builder()
            .method("POST")
            .uri("/api/auth/email")
            .header("content-type", "application/json")
            .body(Body::from(r#"{"email":"policy@openagents.com"}"#))?;
        let send_response = app.clone().oneshot(send_request).await?;
        let cookie = cookie_value(&send_response).unwrap_or_default();

        let verify_request = Request::builder()
            .method("POST")
            .uri("/api/auth/verify")
            .header("content-type", "application/json")
            .header("x-client", "autopilot-ios")
            .header("cookie", cookie)
            .body(Body::from(r#"{"code":"123456"}"#))?;
        let verify_response = app.clone().oneshot(verify_request).await?;
        let verify_body = read_json(verify_response).await?;
        let token = verify_body["token"]
            .as_str()
            .unwrap_or_default()
            .to_string();

        let memberships_request = Request::builder()
            .uri("/api/orgs/memberships")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let memberships_response = app.clone().oneshot(memberships_request).await?;
        assert_eq!(memberships_response.status(), StatusCode::OK);
        let memberships_body = read_json(memberships_response).await?;
        let memberships = memberships_body["data"]["memberships"]
            .as_array()
            .cloned()
            .unwrap_or_default();
        let has_openagents_org = memberships.iter().any(|membership| {
            membership["org_id"]
                .as_str()
                .map(|org_id| org_id == "org:openagents")
                .unwrap_or(false)
        });
        assert!(has_openagents_org);

        let set_org_request = Request::builder()
            .method("POST")
            .uri("/api/orgs/active")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(r#"{"org_id":"org:openagents"}"#))?;
        let set_org_response = app.clone().oneshot(set_org_request).await?;
        assert_eq!(set_org_response.status(), StatusCode::OK);

        let deny_scope_request = Request::builder()
            .method("POST")
            .uri("/api/policy/authorize")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"org_id":"org:openagents","required_scopes":["runtime.write"],"requested_topics":["org:openagents:workers"]}"#,
            ))?;
        let deny_scope_response = app.clone().oneshot(deny_scope_request).await?;
        assert_eq!(deny_scope_response.status(), StatusCode::OK);
        let deny_scope_body = read_json(deny_scope_response).await?;
        assert_eq!(deny_scope_body["data"]["allowed"], false);

        let allow_request = Request::builder()
            .method("POST")
            .uri("/api/policy/authorize")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"org_id":"org:openagents","required_scopes":["runtime.read"],"requested_topics":["org:openagents:workers"]}"#,
            ))?;
        let allow_response = app.clone().oneshot(allow_request).await?;
        assert_eq!(allow_response.status(), StatusCode::OK);
        let allow_body = read_json(allow_response).await?;
        assert_eq!(allow_body["data"]["allowed"], true);

        let deny_topic_request = Request::builder()
            .method("POST")
            .uri("/api/policy/authorize")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"org_id":"org:openagents","required_scopes":["runtime.read"],"requested_topics":["org:other:workers"]}"#,
            ))?;
        let deny_topic_response = app.oneshot(deny_topic_request).await?;
        assert_eq!(deny_topic_response.status(), StatusCode::OK);
        let deny_topic_body = read_json(deny_topic_response).await?;
        assert_eq!(deny_topic_body["data"]["allowed"], false);

        Ok(())
    }

    #[tokio::test]
    async fn me_route_returns_user_profile_and_thread_summaries() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token = authenticate_token(app.clone(), "me-route@openagents.com").await?;

        for thread_id in ["thread-a", "thread-b"] {
            let request = Request::builder()
                .method("POST")
                .uri(format!("/api/runtime/threads/{thread_id}/messages"))
                .header("content-type", "application/json")
                .header("authorization", format!("Bearer {token}"))
                .body(Body::from(r#"{"text":"hello"}"#))?;
            let response = app.clone().oneshot(request).await?;
            assert_eq!(response.status(), StatusCode::OK);
        }

        let me_request = Request::builder()
            .uri("/api/me?chat_limit=1")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let me_response = app.oneshot(me_request).await?;
        assert_eq!(me_response.status(), StatusCode::OK);
        let me_body = read_json(me_response).await?;
        assert_eq!(me_body["data"]["user"]["email"], "me-route@openagents.com");
        assert_eq!(
            me_body["data"]["chatThreads"].as_array().map(Vec::len),
            Some(1)
        );
        assert_eq!(me_body["data"]["chatThreads"][0]["id"], "thread-b");

        Ok(())
    }

    #[test]
    fn autopilot_tool_resolution_audit_applies_allowlist_and_denylist() {
        let aggregate = sample_autopilot_aggregate();
        let audit = super::autopilot_tool_resolution_audit(&aggregate, true);

        assert_eq!(audit["policyApplied"], json!(true));
        assert_eq!(audit["authRestricted"], json!(false));
        assert_eq!(audit["sessionAuthenticated"], json!(true));
        assert_eq!(audit["autopilotId"], json!("ap_test_1"));
        assert_eq!(audit["exposedTools"], json!(vec!["openagents_api"]));
        assert_eq!(
            audit["removedByDenylist"],
            json!(vec!["lightning_l402_fetch"])
        );

        let removed_by_allowlist = audit["removedByAllowlist"]
            .as_array()
            .cloned()
            .unwrap_or_default();
        assert!(
            removed_by_allowlist
                .iter()
                .any(|tool| tool == &json!("lightning_l402_approve"))
        );
    }

    #[test]
    fn autopilot_prompt_context_includes_profile_policy_and_limits() {
        let aggregate = sample_autopilot_aggregate();
        let context = super::autopilot_prompt_context(&aggregate).expect("context should exist");

        assert!(context.contains("autopilot_id=ap_test_1"));
        assert!(context.contains("config_version=3"));
        assert!(context.contains("owner_display_name=Chris"));
        assert!(context.contains("persona_summary=Pragmatic and concise"));
        assert!(context.contains("autopilot_voice=calm and direct"));
        assert!(context.contains("tool_allowlist=openagents_api,lightning_l402_fetch"));
        assert!(context.contains("tool_denylist=lightning_l402_fetch"));
        assert!(context.contains("l402_require_approval=true"));
        assert!(context.chars().count() <= 3200);
    }

    #[test]
    fn autopilot_runtime_binding_payload_prefers_primary_binding() {
        let aggregate = sample_autopilot_aggregate();
        let binding = super::autopilot_runtime_binding_payload(&aggregate);

        assert_eq!(binding["id"], json!("arb_primary"));
        assert_eq!(binding["runtimeType"], json!("runtime"));
        assert_eq!(binding["runtimeRef"], json!("desktopw:autopilot"));
        assert_eq!(binding["driverHint"], json!("elixir"));
        assert_eq!(
            super::autopilot_runtime_binding_worker_ref(&aggregate),
            Some("desktopw:autopilot".to_string())
        );
    }

    #[tokio::test]
    async fn autopilot_crud_routes_support_create_list_show_and_update() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token = authenticate_token(app.clone(), "autopilot-owner@openagents.com").await?;

        let create_request = Request::builder()
            .method("POST")
            .uri("/api/autopilots")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"handle":"ep212-bot","displayName":"EP212 Bot","status":"active","visibility":"private"}"#,
            ))?;
        let create_response = app.clone().oneshot(create_request).await?;
        assert_eq!(create_response.status(), StatusCode::CREATED);
        let create_body = read_json(create_response).await?;
        let autopilot_id = create_body["data"]["id"]
            .as_str()
            .unwrap_or_default()
            .to_string();
        assert!(autopilot_id.starts_with("ap_"));
        assert_eq!(create_body["data"]["handle"], json!("ep212-bot"));
        assert_eq!(create_body["data"]["displayName"], json!("EP212 Bot"));
        assert_eq!(create_body["data"]["configVersion"], json!(1));

        let list_request = Request::builder()
            .method("GET")
            .uri("/api/autopilots?limit=200")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let list_response = app.clone().oneshot(list_request).await?;
        assert_eq!(list_response.status(), StatusCode::OK);
        let list_body = read_json(list_response).await?;
        let listed = list_body["data"].as_array().cloned().unwrap_or_default();
        assert!(!listed.is_empty());
        assert!(
            listed
                .iter()
                .any(|row| row["id"] == json!(autopilot_id.clone()))
        );

        let show_by_id_request = Request::builder()
            .method("GET")
            .uri(format!("/api/autopilots/{autopilot_id}"))
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let show_by_id_response = app.clone().oneshot(show_by_id_request).await?;
        assert_eq!(show_by_id_response.status(), StatusCode::OK);
        let show_by_id_body = read_json(show_by_id_response).await?;
        assert_eq!(show_by_id_body["data"]["handle"], json!("ep212-bot"));

        let show_by_handle_request = Request::builder()
            .method("GET")
            .uri("/api/autopilots/ep212-bot")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let show_by_handle_response = app.clone().oneshot(show_by_handle_request).await?;
        assert_eq!(show_by_handle_response.status(), StatusCode::OK);
        let show_by_handle_body = read_json(show_by_handle_response).await?;
        assert_eq!(
            show_by_handle_body["data"]["id"],
            json!(autopilot_id.clone())
        );

        let update_request = Request::builder()
            .method("PATCH")
            .uri(format!("/api/autopilots/{autopilot_id}"))
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"displayName":"EP212 Bot Updated","profile":{"ownerDisplayName":"Chris","personaSummary":"Pragmatic and concise","autopilotVoice":"calm and direct"},"policy":{"toolAllowlist":["openagents_api"],"toolDenylist":["lightning_l402_fetch"],"l402RequireApproval":true,"l402MaxSpendMsatsPerCall":100000,"l402AllowedHosts":["sats4ai.com"]}}"#,
            ))?;
        let update_response = app.clone().oneshot(update_request).await?;
        assert_eq!(update_response.status(), StatusCode::OK);
        let update_body = read_json(update_response).await?;
        assert_eq!(
            update_body["data"]["displayName"],
            json!("EP212 Bot Updated")
        );
        assert_eq!(update_body["data"]["configVersion"], json!(2));
        assert_eq!(
            update_body["data"]["profile"]["ownerDisplayName"],
            json!("Chris")
        );
        assert_eq!(
            update_body["data"]["policy"]["toolAllowlist"][0],
            json!("openagents_api")
        );
        assert_eq!(
            update_body["data"]["policy"]["l402MaxSpendMsatsPerCall"],
            json!(100000)
        );

        Ok(())
    }

    #[tokio::test]
    async fn autopilot_thread_routes_support_create_and_list() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token = authenticate_token(app.clone(), "autopilot-threads@openagents.com").await?;

        let create_autopilot_request = Request::builder()
            .method("POST")
            .uri("/api/autopilots")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"handle":"thread-bot","displayName":"Thread Bot"}"#,
            ))?;
        let create_autopilot_response = app.clone().oneshot(create_autopilot_request).await?;
        assert_eq!(create_autopilot_response.status(), StatusCode::CREATED);
        let create_autopilot_body = read_json(create_autopilot_response).await?;
        let autopilot_id = create_autopilot_body["data"]["id"]
            .as_str()
            .unwrap_or_default()
            .to_string();

        let update_autopilot_request = Request::builder()
            .method("PATCH")
            .uri(format!("/api/autopilots/{autopilot_id}"))
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"profile":{"ownerDisplayName":"Chris","personaSummary":"Pragmatic and concise","autopilotVoice":"calm and direct"},"policy":{"toolAllowlist":["openagents_api","lightning_l402_fetch"],"toolDenylist":["lightning_l402_fetch"],"l402RequireApproval":true,"l402AllowedHosts":["sats4ai.com"]}}"#,
            ))?;
        let update_autopilot_response = app.clone().oneshot(update_autopilot_request).await?;
        assert_eq!(update_autopilot_response.status(), StatusCode::OK);
        assert!(autopilot_id.starts_with("ap_"));

        let create_thread_request = Request::builder()
            .method("POST")
            .uri(format!("/api/autopilots/{autopilot_id}/threads"))
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(r#"{"title":"Autopilot test thread"}"#))?;
        let create_thread_response = app.clone().oneshot(create_thread_request).await?;
        assert_eq!(create_thread_response.status(), StatusCode::CREATED);
        let create_thread_body = read_json(create_thread_response).await?;
        let thread_id = create_thread_body["data"]["id"]
            .as_str()
            .unwrap_or_default()
            .to_string();
        assert!(thread_id.starts_with("thread_"));
        assert_eq!(
            create_thread_body["data"]["autopilotId"],
            json!(autopilot_id.clone())
        );
        assert_eq!(
            create_thread_body["data"]["title"],
            json!("Autopilot test thread")
        );

        let create_default_title_request = Request::builder()
            .method("POST")
            .uri(format!("/api/autopilots/{autopilot_id}/threads"))
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(r#"{}"#))?;
        let create_default_title_response =
            app.clone().oneshot(create_default_title_request).await?;
        assert_eq!(create_default_title_response.status(), StatusCode::CREATED);
        let create_default_title_body = read_json(create_default_title_response).await?;
        assert_eq!(
            create_default_title_body["data"]["title"],
            json!("New conversation")
        );

        let list_threads_request = Request::builder()
            .method("GET")
            .uri(format!("/api/autopilots/{autopilot_id}/threads?limit=200"))
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let list_threads_response = app.clone().oneshot(list_threads_request).await?;
        assert_eq!(list_threads_response.status(), StatusCode::OK);
        let list_threads_body = read_json(list_threads_response).await?;
        let listed_threads = list_threads_body["data"]
            .as_array()
            .cloned()
            .unwrap_or_default();
        assert!(listed_threads.len() >= 2);
        assert!(listed_threads.iter().all(|row| {
            row["autopilotId"] == json!(autopilot_id.clone()) && row["id"].is_string()
        }));
        assert!(
            listed_threads
                .iter()
                .any(|row| row["id"] == json!(thread_id.clone()))
        );

        Ok(())
    }

    #[tokio::test]
    async fn autopilot_stream_route_bootstraps_codex_and_returns_ws_delivery() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token = authenticate_token(app.clone(), "autopilot-stream@openagents.com").await?;

        let create_autopilot_request = Request::builder()
            .method("POST")
            .uri("/api/autopilots")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"handle":"stream-bot","displayName":"Stream Bot"}"#,
            ))?;
        let create_autopilot_response = app.clone().oneshot(create_autopilot_request).await?;
        assert_eq!(create_autopilot_response.status(), StatusCode::CREATED);
        let create_autopilot_body = read_json(create_autopilot_response).await?;
        let autopilot_id = create_autopilot_body["data"]["id"]
            .as_str()
            .unwrap_or_default()
            .to_string();

        let stream_request = Request::builder()
            .method("POST")
            .uri(format!("/api/autopilots/{autopilot_id}/stream"))
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"messages":[{"id":"m1","role":"user","content":"hello from autopilot stream alias"}]}"#,
            ))?;
        let stream_response = app.clone().oneshot(stream_request).await?;
        assert_eq!(stream_response.status(), StatusCode::OK);
        let stream_body = read_json(stream_response).await?;
        let thread_id = stream_body["data"]["threadId"]
            .as_str()
            .unwrap_or_default()
            .to_string();
        assert!(thread_id.starts_with("thread_"));
        assert_eq!(stream_body["data"]["accepted"], json!(true));
        assert_eq!(
            stream_body["data"]["autopilotId"],
            json!(autopilot_id.clone())
        );
        assert_eq!(
            stream_body["data"]["delivery"]["transport"],
            json!("khala_ws")
        );
        let delivery_topic = stream_body["data"]["delivery"]["topic"]
            .as_str()
            .unwrap_or_default();
        assert!(delivery_topic.ends_with(":worker_events"));
        assert_eq!(
            stream_body["data"]["control"]["method"],
            json!("turn/start")
        );
        assert_eq!(
            stream_body["data"]["response"]["thread_id"],
            json!(thread_id.clone())
        );
        let prompt_context = stream_body["data"]["promptContext"]
            .as_str()
            .unwrap_or_default();
        assert!(!prompt_context.is_empty());
        assert!(prompt_context.contains("autopilot_id="));
        assert!(prompt_context.contains("l402_require_approval=true"));
        assert_eq!(
            stream_body["data"]["toolPolicy"]["policyApplied"],
            json!(true)
        );
        let exposed_tools = stream_body["data"]["toolPolicy"]["exposedTools"]
            .as_array()
            .cloned()
            .unwrap_or_default();
        assert!(!exposed_tools.is_empty());
        let removed_by_denylist = stream_body["data"]["toolPolicy"]["removedByDenylist"]
            .as_array()
            .cloned()
            .unwrap_or_default();
        assert!(removed_by_denylist.len() <= exposed_tools.len());
        assert!(
            stream_body["data"]["runtimeBinding"].is_null()
                || stream_body["data"]["runtimeBinding"].is_object()
        );

        let list_request = Request::builder()
            .method("GET")
            .uri(format!("/api/autopilots/{autopilot_id}/threads"))
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let list_response = app.clone().oneshot(list_request).await?;
        assert_eq!(list_response.status(), StatusCode::OK);
        let list_body = read_json(list_response).await?;
        let listed = list_body["data"].as_array().cloned().unwrap_or_default();
        assert!(
            listed
                .iter()
                .any(|row| row["id"] == json!(thread_id.clone()))
        );

        let resume_request = Request::builder()
            .method("POST")
            .uri(format!("/api/autopilots/{autopilot_id}/stream"))
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(format!(
                r#"{{"conversationId":"{thread_id}","messages":[{{"id":"m2","role":"user","content":"continue this thread"}}]}}"#
            )))?;
        let resume_response = app.oneshot(resume_request).await?;
        assert_eq!(resume_response.status(), StatusCode::OK);
        let resume_body = read_json(resume_response).await?;
        assert_eq!(resume_body["data"]["threadId"], json!(thread_id));

        Ok(())
    }

    #[tokio::test]
    async fn autopilot_routes_enforce_owner_boundary() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let owner_token =
            authenticate_token(app.clone(), "autopilot-owner-a@openagents.com").await?;
        let other_token =
            authenticate_token(app.clone(), "autopilot-owner-b@openagents.com").await?;

        let create_request = Request::builder()
            .method("POST")
            .uri("/api/autopilots")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {owner_token}"))
            .body(Body::from(
                r#"{"handle":"owner-bot","displayName":"Owner Bot"}"#,
            ))?;
        let create_response = app.clone().oneshot(create_request).await?;
        assert_eq!(create_response.status(), StatusCode::CREATED);
        let create_body = read_json(create_response).await?;
        let autopilot_id = create_body["data"]["id"]
            .as_str()
            .unwrap_or_default()
            .to_string();

        let other_show_request = Request::builder()
            .method("GET")
            .uri(format!("/api/autopilots/{autopilot_id}"))
            .header("authorization", format!("Bearer {other_token}"))
            .body(Body::empty())?;
        let other_show_response = app.clone().oneshot(other_show_request).await?;
        assert_eq!(other_show_response.status(), StatusCode::NOT_FOUND);

        let other_update_request = Request::builder()
            .method("PATCH")
            .uri(format!("/api/autopilots/{autopilot_id}"))
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {other_token}"))
            .body(Body::from(r#"{"displayName":"Hacked"}"#))?;
        let other_update_response = app.clone().oneshot(other_update_request).await?;
        assert_eq!(other_update_response.status(), StatusCode::NOT_FOUND);

        let other_show_handle_request = Request::builder()
            .method("GET")
            .uri("/api/autopilots/owner-bot")
            .header("authorization", format!("Bearer {other_token}"))
            .body(Body::empty())?;
        let other_show_handle_response = app.clone().oneshot(other_show_handle_request).await?;
        assert_eq!(other_show_handle_response.status(), StatusCode::NOT_FOUND);

        let other_threads_request = Request::builder()
            .method("GET")
            .uri(format!("/api/autopilots/{autopilot_id}/threads"))
            .header("authorization", format!("Bearer {other_token}"))
            .body(Body::empty())?;
        let other_threads_response = app.clone().oneshot(other_threads_request).await?;
        assert_eq!(other_threads_response.status(), StatusCode::NOT_FOUND);

        let other_create_thread_request = Request::builder()
            .method("POST")
            .uri(format!("/api/autopilots/{autopilot_id}/threads"))
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {other_token}"))
            .body(Body::from(r#"{"title":"intruder thread"}"#))?;
        let other_create_thread_response = app.clone().oneshot(other_create_thread_request).await?;
        assert_eq!(other_create_thread_response.status(), StatusCode::NOT_FOUND);

        let other_stream_request = Request::builder()
            .method("POST")
            .uri(format!("/api/autopilots/{autopilot_id}/stream"))
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {other_token}"))
            .body(Body::from(
                r#"{"messages":[{"id":"m1","role":"user","content":"intruder stream"}]}"#,
            ))?;
        let other_stream_response = app.oneshot(other_stream_request).await?;
        assert_eq!(other_stream_response.status(), StatusCode::NOT_FOUND);

        Ok(())
    }

    #[tokio::test]
    async fn autopilot_routes_enforce_validation_semantics() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token = authenticate_token(app.clone(), "autopilot-validation@openagents.com").await?;

        let bad_create_request = Request::builder()
            .method("POST")
            .uri("/api/autopilots")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(r#"{"handle":"invalid handle!"}"#))?;
        let bad_create_response = app.clone().oneshot(bad_create_request).await?;
        assert_eq!(
            bad_create_response.status(),
            StatusCode::UNPROCESSABLE_ENTITY
        );
        let bad_create_body = read_json(bad_create_response).await?;
        assert_eq!(bad_create_body["error"]["code"], json!("invalid_request"));

        let create_request = Request::builder()
            .method("POST")
            .uri("/api/autopilots")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(r#"{"handle":"valid-bot"}"#))?;
        let create_response = app.clone().oneshot(create_request).await?;
        assert_eq!(create_response.status(), StatusCode::CREATED);
        let create_body = read_json(create_response).await?;
        let autopilot_id = create_body["data"]["id"]
            .as_str()
            .unwrap_or_default()
            .to_string();

        let bad_update_request = Request::builder()
            .method("PATCH")
            .uri(format!("/api/autopilots/{autopilot_id}"))
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"status":"ACTIVE","profile":{"schemaVersion":0},"policy":{"l402MaxSpendMsatsPerCall":0}}"#,
            ))?;
        let bad_update_response = app.clone().oneshot(bad_update_request).await?;
        assert_eq!(
            bad_update_response.status(),
            StatusCode::UNPROCESSABLE_ENTITY
        );
        let bad_update_body = read_json(bad_update_response).await?;
        assert_eq!(bad_update_body["error"]["code"], json!("invalid_request"));

        let oversized_title = "x".repeat(201);
        let bad_thread_request = Request::builder()
            .method("POST")
            .uri(format!("/api/autopilots/{autopilot_id}/threads"))
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(format!(r#"{{"title":"{oversized_title}"}}"#)))?;
        let bad_thread_response = app.clone().oneshot(bad_thread_request).await?;
        assert_eq!(
            bad_thread_response.status(),
            StatusCode::UNPROCESSABLE_ENTITY
        );
        let bad_thread_body = read_json(bad_thread_response).await?;
        assert_eq!(bad_thread_body["error"]["code"], json!("invalid_request"));

        let bad_stream_request = Request::builder()
            .method("POST")
            .uri(format!("/api/autopilots/{autopilot_id}/stream"))
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"messages":[{"id":"m1","role":"assistant","content":"missing user prompt"}]}"#,
            ))?;
        let bad_stream_response = app.clone().oneshot(bad_stream_request).await?;
        assert_eq!(
            bad_stream_response.status(),
            StatusCode::UNPROCESSABLE_ENTITY
        );
        let bad_stream_body = read_json(bad_stream_response).await?;
        assert_eq!(bad_stream_body["error"]["code"], json!("invalid_request"));

        let missing_thread_request = Request::builder()
            .method("POST")
            .uri(format!("/api/autopilots/{autopilot_id}/stream"))
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"conversationId":"thread_missing","messages":[{"id":"m2","role":"user","content":"hello"}]}"#,
            ))?;
        let missing_thread_response = app.oneshot(missing_thread_request).await?;
        assert_eq!(missing_thread_response.status(), StatusCode::NOT_FOUND);

        Ok(())
    }

    #[tokio::test]
    async fn settings_profile_routes_support_read_update_delete() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token = authenticate_token(app.clone(), "profile-user@openagents.com").await?;

        let show_request = Request::builder()
            .uri("/api/settings/profile")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let show_response = app.clone().oneshot(show_request).await?;
        assert_eq!(show_response.status(), StatusCode::OK);
        let show_body = read_json(show_response).await?;
        assert_eq!(show_body["data"]["email"], "profile-user@openagents.com");

        let update_request = Request::builder()
            .method("PATCH")
            .uri("/api/settings/profile")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(r#"{"name":"Updated Name"}"#))?;
        let update_response = app.clone().oneshot(update_request).await?;
        assert_eq!(update_response.status(), StatusCode::OK);
        let update_body = read_json(update_response).await?;
        assert_eq!(update_body["data"]["name"], "Updated Name");

        let wrong_delete_request = Request::builder()
            .method("DELETE")
            .uri("/api/settings/profile")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(r#"{"email":"wrong@openagents.com"}"#))?;
        let wrong_delete_response = app.clone().oneshot(wrong_delete_request).await?;
        assert_eq!(
            wrong_delete_response.status(),
            StatusCode::UNPROCESSABLE_ENTITY
        );
        let wrong_delete_body = read_json(wrong_delete_response).await?;
        assert_eq!(
            wrong_delete_body["message"],
            "Email confirmation does not match the authenticated user."
        );

        let delete_request = Request::builder()
            .method("DELETE")
            .uri("/api/settings/profile")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(r#"{"email":"profile-user@openagents.com"}"#))?;
        let delete_response = app.clone().oneshot(delete_request).await?;
        assert_eq!(delete_response.status(), StatusCode::OK);
        let delete_body = read_json(delete_response).await?;
        assert_eq!(delete_body["data"]["deleted"], true);

        let show_after_delete_request = Request::builder()
            .uri("/api/settings/profile")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let show_after_delete_response = app.oneshot(show_after_delete_request).await?;
        assert_eq!(
            show_after_delete_response.status(),
            StatusCode::UNAUTHORIZED
        );

        Ok(())
    }

    #[tokio::test]
    async fn settings_autopilot_route_supports_create_update_and_validation() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token = authenticate_token(app.clone(), "autopilot-settings@openagents.com").await?;

        let update_request = Request::builder()
            .method("PATCH")
            .uri("/settings/autopilot")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"displayName":"Chris Autopilot","tagline":"Persistent and practical","ownerDisplayName":"Chris","personaSummary":"Keep it concise and engineering-minded.","autopilotVoice":"calm and direct","principlesText":"Prefer verification over guessing\nAsk before irreversible actions"}"#,
            ))?;
        let update_response = app.clone().oneshot(update_request).await?;
        assert_eq!(update_response.status(), StatusCode::OK);
        let update_body = read_json(update_response).await?;
        assert_eq!(update_body["data"]["status"], "autopilot-updated");
        assert_eq!(
            update_body["data"]["autopilot"]["displayName"],
            "Chris Autopilot"
        );
        assert_eq!(
            update_body["data"]["autopilot"]["tagline"],
            "Persistent and practical"
        );
        assert_eq!(
            update_body["data"]["autopilot"]["profile"]["ownerDisplayName"],
            "Chris"
        );
        assert_eq!(
            update_body["data"]["autopilot"]["profile"]["personaSummary"],
            "Keep it concise and engineering-minded."
        );
        assert_eq!(
            update_body["data"]["autopilot"]["profile"]["autopilotVoice"],
            "calm and direct"
        );
        let principles = update_body["data"]["autopilot"]["profile"]["principles"]
            .as_array()
            .cloned()
            .unwrap_or_default();
        assert!(
            principles
                .iter()
                .any(|value| value == "Prefer verification over guessing")
        );
        assert!(
            principles
                .iter()
                .any(|value| value == "Ask before irreversible actions")
        );
        assert!(
            update_body["data"]["autopilot"]["configVersion"]
                .as_u64()
                .unwrap_or_default()
                > 1
        );

        let too_long_display_name = "x".repeat(121);
        let invalid_request = Request::builder()
            .method("PATCH")
            .uri("/settings/autopilot")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(format!(
                r#"{{"displayName":"{too_long_display_name}"}}"#
            )))?;
        let invalid_response = app.oneshot(invalid_request).await?;
        assert_eq!(invalid_response.status(), StatusCode::UNPROCESSABLE_ENTITY);
        let invalid_body = read_json(invalid_response).await?;
        assert_eq!(invalid_body["error"]["code"], json!("invalid_request"));
        assert_eq!(
            invalid_body["errors"]["displayName"],
            json!(["Value may not be greater than 120 characters."])
        );

        Ok(())
    }

    #[tokio::test]
    async fn settings_integrations_resend_routes_support_lifecycle_and_validation() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token = authenticate_token(app.clone(), "integrations-resend@openagents.com").await?;

        let upsert_request = Request::builder()
            .method("POST")
            .uri("/settings/integrations/resend")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"resend_api_key":"re_live_1234567890","sender_email":"bot@openagents.com","sender_name":"OpenAgents Bot"}"#,
            ))?;
        let upsert_response = app.clone().oneshot(upsert_request).await?;
        assert_eq!(upsert_response.status(), StatusCode::OK);
        let upsert_body = read_json(upsert_response).await?;
        assert_eq!(upsert_body["data"]["status"], "resend-connected");
        assert_eq!(upsert_body["data"]["action"], "secret_created");
        assert_eq!(upsert_body["data"]["integration"]["provider"], "resend");
        assert_eq!(upsert_body["data"]["integration"]["connected"], true);
        assert_eq!(upsert_body["data"]["integration"]["secretLast4"], "7890");

        let test_request = Request::builder()
            .method("POST")
            .uri("/settings/integrations/resend/test")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let test_response = app.clone().oneshot(test_request).await?;
        assert_eq!(test_response.status(), StatusCode::OK);
        let test_body = read_json(test_response).await?;
        assert_eq!(test_body["data"]["status"], "resend-test-queued");
        assert_eq!(test_body["data"]["action"], "test_requested");

        let disconnect_request = Request::builder()
            .method("DELETE")
            .uri("/settings/integrations/resend")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let disconnect_response = app.clone().oneshot(disconnect_request).await?;
        assert_eq!(disconnect_response.status(), StatusCode::OK);
        let disconnect_body = read_json(disconnect_response).await?;
        assert_eq!(disconnect_body["data"]["status"], "resend-disconnected");
        assert_eq!(disconnect_body["data"]["action"], "secret_revoked");
        assert_eq!(disconnect_body["data"]["integration"]["connected"], false);

        let test_after_disconnect_request = Request::builder()
            .method("POST")
            .uri("/settings/integrations/resend/test")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let test_after_disconnect_response = app.oneshot(test_after_disconnect_request).await?;
        assert_eq!(
            test_after_disconnect_response.status(),
            StatusCode::UNPROCESSABLE_ENTITY
        );
        let test_after_disconnect_body = read_json(test_after_disconnect_response).await?;
        assert_eq!(
            test_after_disconnect_body["error"]["code"],
            "invalid_request"
        );
        assert_eq!(
            test_after_disconnect_body["message"],
            "Connect an active Resend key before running a test."
        );

        Ok(())
    }

    #[tokio::test]
    async fn settings_integrations_google_routes_support_redirect_callback_and_disconnect()
    -> Result<()> {
        let captured_bodies = Arc::new(Mutex::new(Vec::<String>::new()));
        let (token_stub_addr, token_stub_handle) =
            start_google_oauth_token_stub(captured_bodies.clone()).await?;

        let mut config = test_config(std::env::temp_dir());
        config.google_oauth_client_id = Some("google-client-id".to_string());
        config.google_oauth_client_secret = Some("google-client-secret".to_string());
        config.google_oauth_redirect_uri =
            Some("https://openagents.test/google/callback".to_string());
        config.google_oauth_token_url = format!("http://{token_stub_addr}/oauth2/token");
        let app = build_router(config);
        let token = authenticate_token(app.clone(), "integrations-google@openagents.com").await?;

        let redirect_request = Request::builder()
            .method("GET")
            .uri("/settings/integrations/google/redirect")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let redirect_response = app.clone().oneshot(redirect_request).await?;
        assert_eq!(redirect_response.status(), StatusCode::SEE_OTHER);

        let location = redirect_response
            .headers()
            .get("location")
            .and_then(|value| value.to_str().ok())
            .unwrap_or_default()
            .to_string();
        assert!(location.starts_with("https://accounts.google.com/o/oauth2/v2/auth"));

        let redirect_url = reqwest::Url::parse(&location)?;
        let state = redirect_url
            .query_pairs()
            .find(|(key, _)| key == "state")
            .map(|(_, value)| value.to_string())
            .unwrap_or_default();
        assert!(!state.is_empty());

        let callback_request = Request::builder()
            .method("GET")
            .uri(format!(
                "/settings/integrations/google/callback?state={state}&code=google-auth-code-123"
            ))
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let callback_response = app.clone().oneshot(callback_request).await?;
        assert_eq!(callback_response.status(), StatusCode::SEE_OTHER);
        assert_eq!(
            callback_response
                .headers()
                .get("location")
                .and_then(|value| value.to_str().ok()),
            Some("/settings/integrations?status=google-connected")
        );

        let captured = captured_bodies.lock().await.clone();
        assert_eq!(captured.len(), 1);
        assert!(captured[0].contains("grant_type=authorization_code"));
        assert!(captured[0].contains("code=google-auth-code-123"));

        let disconnect_request = Request::builder()
            .method("DELETE")
            .uri("/settings/integrations/google")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let disconnect_response = app.clone().oneshot(disconnect_request).await?;
        assert_eq!(disconnect_response.status(), StatusCode::OK);
        let disconnect_body = read_json(disconnect_response).await?;
        assert_eq!(disconnect_body["data"]["status"], "google-disconnected");
        assert_eq!(disconnect_body["data"]["action"], "secret_revoked");
        assert_eq!(disconnect_body["data"]["integration"]["connected"], false);

        let bad_state_request = Request::builder()
            .method("GET")
            .uri("/settings/integrations/google/callback?state=bad-state&code=another")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let bad_state_response = app.oneshot(bad_state_request).await?;
        assert_eq!(
            bad_state_response.status(),
            StatusCode::UNPROCESSABLE_ENTITY
        );
        let bad_state_body = read_json(bad_state_response).await?;
        assert_eq!(bad_state_body["error"]["code"], "invalid_request");
        assert_eq!(
            bad_state_body["message"],
            "OAuth state mismatch. Please retry connecting Google."
        );

        token_stub_handle.abort();
        Ok(())
    }

    #[tokio::test]
    async fn inbox_routes_fetch_gmail_threads_and_support_actions() -> Result<()> {
        let token_calls = Arc::new(Mutex::new(Vec::<String>::new()));
        let send_calls = Arc::new(Mutex::new(Vec::<Value>::new()));
        let (gmail_stub_addr, gmail_stub_handle) =
            start_gmail_inbox_stub(token_calls.clone(), send_calls.clone()).await?;

        let static_dir = tempdir()?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.google_oauth_client_id = Some("google-client-id".to_string());
        config.google_oauth_client_secret = Some("google-client-secret".to_string());
        config.google_oauth_token_url = format!("http://{gmail_stub_addr}/oauth2/token");
        config.google_gmail_api_base_url = format!("http://{gmail_stub_addr}");
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));

        let auth = super::AuthService::from_config(&config);
        let verify = auth
            .local_test_sign_in(
                "inbox-google@openagents.com".to_string(),
                None,
                Some("autopilot-ios"),
                None,
            )
            .await?;
        let token = verify.access_token.clone();
        let user_id = verify.user.id.clone();

        let store = DomainStore::from_config(&config);
        store
            .upsert_google_integration(UpsertGoogleIntegrationInput {
                user_id: user_id.clone(),
                refresh_token: Some("refresh_token_1234567890".to_string()),
                access_token: Some("stale_access_token".to_string()),
                scope: Some(
                    "https://www.googleapis.com/auth/gmail.readonly https://www.googleapis.com/auth/gmail.send"
                        .to_string(),
                ),
                token_type: Some("Bearer".to_string()),
                expires_at: Some(Utc::now() - Duration::minutes(5)),
            })
            .await?;
        let app = build_router(config.clone());

        let list_request = Request::builder()
            .method("GET")
            .uri("/api/inbox/threads")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let list_response = app.clone().oneshot(list_request).await?;
        assert_eq!(list_response.status(), StatusCode::OK);
        let list_body = read_json(list_response).await?;
        assert_eq!(
            list_body["data"]["snapshot"]["threads"][0]["id"],
            "thread_1"
        );

        let detail_request = Request::builder()
            .method("GET")
            .uri("/api/inbox/threads/thread_1")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let detail_response = app.clone().oneshot(detail_request).await?;
        assert_eq!(detail_response.status(), StatusCode::OK);
        let detail_body = read_json(detail_response).await?;
        assert_eq!(detail_body["data"]["thread"]["id"], "thread_1");

        let approve_request = Request::builder()
            .method("POST")
            .uri("/api/inbox/threads/thread_1/draft/approve")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(r#"{"detail":"approved in test"}"#))?;
        let approve_response = app.clone().oneshot(approve_request).await?;
        assert_eq!(approve_response.status(), StatusCode::OK);
        let approve_body = read_json(approve_response).await?;
        assert_eq!(
            approve_body["data"]["snapshot"]["threads"][0]["pending_approval"],
            false
        );

        let reject_request = Request::builder()
            .method("POST")
            .uri("/api/inbox/threads/thread_1/draft/reject")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(r#"{"detail":"reject in test"}"#))?;
        let reject_response = app.clone().oneshot(reject_request).await?;
        assert_eq!(reject_response.status(), StatusCode::OK);
        let reject_body = read_json(reject_response).await?;
        assert_eq!(
            reject_body["data"]["snapshot"]["threads"][0]["pending_approval"],
            true
        );

        let send_request = Request::builder()
            .method("POST")
            .uri("/api/inbox/threads/thread_1/reply/send")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"body":"Thanks for the update. Tuesday works for us."}"#,
            ))?;
        let send_response = app.clone().oneshot(send_request).await?;
        assert_eq!(send_response.status(), StatusCode::OK);
        let send_body = read_json(send_response).await?;
        assert_eq!(send_body["data"]["status"], "sent");
        assert_eq!(send_body["data"]["message_id"], "gmail_msg_sent_1");

        let refresh_calls = token_calls.lock().await.clone();
        assert!(!refresh_calls.is_empty());
        assert!(refresh_calls[0].contains("grant_type=refresh_token"));

        let sends = send_calls.lock().await.clone();
        assert_eq!(sends.len(), 1);
        assert_eq!(sends[0]["threadId"], "thread_1");

        gmail_stub_handle.abort();
        Ok(())
    }

    #[tokio::test]
    async fn inbox_threads_fail_when_refresh_token_is_missing() -> Result<()> {
        let static_dir = tempdir()?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.google_oauth_client_id = Some("google-client-id".to_string());
        config.google_oauth_client_secret = Some("google-client-secret".to_string());
        config.google_oauth_token_url = "http://127.0.0.1:9/oauth2/token".to_string();
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));

        let auth = super::AuthService::from_config(&config);
        let verify = auth
            .local_test_sign_in(
                "inbox-missing-refresh@openagents.com".to_string(),
                None,
                Some("autopilot-ios"),
                None,
            )
            .await?;
        let token = verify.access_token.clone();
        let user_id = verify.user.id.clone();

        let store = DomainStore::from_config(&config);
        store
            .upsert_google_integration(UpsertGoogleIntegrationInput {
                user_id,
                refresh_token: Some("   ".to_string()),
                access_token: Some("stale_access_token".to_string()),
                scope: Some("https://www.googleapis.com/auth/gmail.readonly".to_string()),
                token_type: Some("Bearer".to_string()),
                expires_at: Some(Utc::now() - Duration::minutes(5)),
            })
            .await?;
        let app = build_router(config.clone());

        let list_request = Request::builder()
            .method("GET")
            .uri("/api/inbox/threads")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let list_response = app.oneshot(list_request).await?;
        assert_eq!(list_response.status(), StatusCode::UNPROCESSABLE_ENTITY);
        let body = read_json(list_response).await?;
        assert_eq!(body["error"]["code"], "invalid_request");
        assert_eq!(
            body["message"],
            "Google refresh token is missing. Reconnect Google integration."
        );

        Ok(())
    }

    #[tokio::test]
    async fn personal_access_token_routes_support_current_and_bulk_revocation() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let session_token =
            authenticate_token(app.clone(), "token-lifecycle@openagents.com").await?;

        let create_request = Request::builder()
            .method("POST")
            .uri("/api/tokens")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {session_token}"))
            .body(Body::from(
                r#"{"name":"api-cli","abilities":["chat:read","chat:write"]}"#,
            ))?;
        let create_response = app.clone().oneshot(create_request).await?;
        assert_eq!(create_response.status(), StatusCode::CREATED);
        let create_body = read_json(create_response).await?;
        let pat_token = create_body["data"]["token"]
            .as_str()
            .unwrap_or_default()
            .to_string();
        assert!(pat_token.starts_with("oa_pat_"));

        let list_by_pat_request = Request::builder()
            .uri("/api/tokens")
            .header("authorization", format!("Bearer {pat_token}"))
            .body(Body::empty())?;
        let list_by_pat_response = app.clone().oneshot(list_by_pat_request).await?;
        assert_eq!(list_by_pat_response.status(), StatusCode::OK);
        let list_by_pat_body = read_json(list_by_pat_response).await?;
        let tokens = list_by_pat_body["data"]
            .as_array()
            .cloned()
            .unwrap_or_default();
        assert!(tokens.iter().any(|token| token["isCurrent"] == true));

        let delete_current_request = Request::builder()
            .method("DELETE")
            .uri("/api/tokens/current")
            .header("authorization", format!("Bearer {pat_token}"))
            .body(Body::empty())?;
        let delete_current_response = app.clone().oneshot(delete_current_request).await?;
        assert_eq!(delete_current_response.status(), StatusCode::OK);
        let delete_current_body = read_json(delete_current_response).await?;
        assert_eq!(delete_current_body["data"]["deleted"], true);

        for name in ["bulk-a", "bulk-b"] {
            let request = Request::builder()
                .method("POST")
                .uri("/api/tokens")
                .header("content-type", "application/json")
                .header("authorization", format!("Bearer {session_token}"))
                .body(Body::from(format!(r#"{{"name":"{name}"}}"#)))?;
            let response = app.clone().oneshot(request).await?;
            assert_eq!(response.status(), StatusCode::CREATED);
        }

        let delete_all_request = Request::builder()
            .method("DELETE")
            .uri("/api/tokens")
            .header("authorization", format!("Bearer {session_token}"))
            .body(Body::empty())?;
        let delete_all_response = app.clone().oneshot(delete_all_request).await?;
        assert_eq!(delete_all_response.status(), StatusCode::OK);
        let delete_all_body = read_json(delete_all_response).await?;
        assert_eq!(delete_all_body["data"]["deletedCount"], 2);

        let final_list_request = Request::builder()
            .uri("/api/tokens")
            .header("authorization", format!("Bearer {session_token}"))
            .body(Body::empty())?;
        let final_list_response = app.oneshot(final_list_request).await?;
        assert_eq!(final_list_response.status(), StatusCode::OK);
        let final_list_body = read_json(final_list_response).await?;
        assert_eq!(final_list_body["data"].as_array().map(Vec::len), Some(0));

        Ok(())
    }

    #[tokio::test]
    async fn khala_token_route_mints_and_surfaces_configuration_errors() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token = authenticate_token(app.clone(), "khala-route@openagents.com").await?;

        let mint_request = Request::builder()
            .method("POST")
            .uri("/api/khala/token")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"scope":["codex:read","codex:write"],"workspace_id":"workspace_42","role":"admin"}"#,
            ))?;
        let mint_response = app.clone().oneshot(mint_request).await?;
        assert_eq!(mint_response.status(), StatusCode::OK);
        let mint_body = read_json(mint_response).await?;
        assert_eq!(mint_body["data"]["token_type"], "Bearer");
        assert_eq!(mint_body["data"]["issuer"], "https://openagents.test");
        assert_eq!(mint_body["data"]["audience"], "openagents-khala-test");
        assert_eq!(mint_body["data"]["claims_version"], "oa_khala_claims_v1");

        let mut config = test_config(std::env::temp_dir());
        config.khala_token_signing_key = None;
        let misconfigured_app = build_router(config);
        let misconfigured_token = authenticate_token(
            misconfigured_app.clone(),
            "khala-misconfigured@openagents.com",
        )
        .await?;
        let unavailable_request = Request::builder()
            .method("POST")
            .uri("/api/khala/token")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {misconfigured_token}"))
            .body(Body::from("{}"))?;
        let unavailable_response = misconfigured_app.oneshot(unavailable_request).await?;
        assert_eq!(
            unavailable_response.status(),
            StatusCode::SERVICE_UNAVAILABLE
        );
        let unavailable_body = read_json(unavailable_response).await?;
        assert_eq!(unavailable_body["error"]["code"], "khala_token_unavailable");

        Ok(())
    }

    #[tokio::test]
    async fn sync_token_route_accepts_personal_access_token_auth() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let session_token = authenticate_token(app.clone(), "sync-pat@openagents.com").await?;

        let create_pat_request = Request::builder()
            .method("POST")
            .uri("/api/tokens")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {session_token}"))
            .body(Body::from(r#"{"name":"sync-pat"}"#))?;
        let create_pat_response = app.clone().oneshot(create_pat_request).await?;
        assert_eq!(create_pat_response.status(), StatusCode::CREATED);
        let create_pat_body = read_json(create_pat_response).await?;
        let pat_token = create_pat_body["data"]["token"]
            .as_str()
            .unwrap_or_default()
            .to_string();

        let sync_request = Request::builder()
            .method("POST")
            .uri("/api/sync/token")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {pat_token}"))
            .body(Body::from(
                r#"{"scopes":["runtime.codex_worker_events"],"device_id":"mobile:custom"}"#,
            ))?;
        let sync_response = app.oneshot(sync_request).await?;
        assert_eq!(sync_response.status(), StatusCode::OK);
        let sync_body = read_json(sync_response).await?;
        assert_eq!(sync_body["data"]["token_type"], "Bearer");
        assert!(
            sync_body["data"]["session_id"]
                .as_str()
                .unwrap_or_default()
                .starts_with("pat:")
        );

        Ok(())
    }

    #[tokio::test]
    async fn sync_token_v1_alias_matches_primary_contract_shape() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token = authenticate_token(app.clone(), "sync-v1-alias@openagents.com").await?;
        let payload = r#"{"scopes":["runtime.codex_worker_events"]}"#;

        let primary_request = Request::builder()
            .method("POST")
            .uri("/api/sync/token")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(payload))?;
        let primary_response = app.clone().oneshot(primary_request).await?;
        assert_eq!(primary_response.status(), StatusCode::OK);
        let primary_body = read_json(primary_response).await?;

        let alias_request = Request::builder()
            .method("POST")
            .uri("/api/v1/sync/token")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(payload))?;
        let alias_response = app.oneshot(alias_request).await?;
        assert_eq!(alias_response.status(), StatusCode::OK);
        let alias_body = read_json(alias_response).await?;

        for key in [
            "token_type",
            "issuer",
            "audience",
            "claims_version",
            "session_id",
            "device_id",
            "org_id",
        ] {
            assert_eq!(alias_body["data"][key], primary_body["data"][key]);
        }
        assert_eq!(alias_body["data"]["scopes"], primary_body["data"]["scopes"]);
        assert_eq!(
            alias_body["data"]["granted_topics"],
            primary_body["data"]["granted_topics"]
        );

        Ok(())
    }

    #[tokio::test]
    async fn sync_token_v1_alias_uses_compatibility_handshake_controls() -> Result<()> {
        let static_dir = tempdir()?;
        let app = build_router(compat_enforced_config(static_dir.path().to_path_buf()));

        let missing_handshake_request = Request::builder()
            .method("POST")
            .uri("/api/v1/sync/token")
            .header("content-type", "application/json")
            .body(Body::from(r#"{"scopes":["runtime.codex_worker_events"]}"#))?;
        let missing_handshake_response = app.clone().oneshot(missing_handshake_request).await?;
        assert_eq!(
            missing_handshake_response.status(),
            StatusCode::UPGRADE_REQUIRED
        );
        let missing_body = read_json(missing_handshake_response).await?;
        assert_eq!(missing_body["error"]["code"], json!("invalid_client_build"));

        let handshake_without_auth = Request::builder()
            .method("POST")
            .uri("/api/v1/sync/token")
            .header("content-type", "application/json")
            .header("x-oa-client-build-id", "20260221T130000Z")
            .header("x-oa-protocol-version", "openagents.control.v1")
            .header("x-oa-schema-version", "1")
            .body(Body::from(r#"{"scopes":["runtime.codex_worker_events"]}"#))?;
        let handshake_without_auth_response = app.clone().oneshot(handshake_without_auth).await?;
        assert_eq!(
            handshake_without_auth_response.status(),
            StatusCode::UNAUTHORIZED
        );

        let primary_request = Request::builder()
            .method("POST")
            .uri("/api/sync/token")
            .header("content-type", "application/json")
            .body(Body::from(r#"{"scopes":["runtime.codex_worker_events"]}"#))?;
        let primary_response = app.oneshot(primary_request).await?;
        assert_eq!(primary_response.status(), StatusCode::UNAUTHORIZED);

        Ok(())
    }

    #[tokio::test]
    async fn sync_token_mint_enforces_scope_and_org_policy() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        let send_request = Request::builder()
            .method("POST")
            .uri("/api/auth/email")
            .header("content-type", "application/json")
            .body(Body::from(r#"{"email":"sync@openagents.com"}"#))?;
        let send_response = app.clone().oneshot(send_request).await?;
        let cookie = cookie_value(&send_response).unwrap_or_default();

        let verify_request = Request::builder()
            .method("POST")
            .uri("/api/auth/verify")
            .header("content-type", "application/json")
            .header("x-client", "autopilot-ios")
            .header("cookie", cookie)
            .body(Body::from(r#"{"code":"123456"}"#))?;
        let verify_response = app.clone().oneshot(verify_request).await?;
        let verify_body = read_json(verify_response).await?;
        let token = verify_body["token"]
            .as_str()
            .unwrap_or_default()
            .to_string();

        let memberships_request = Request::builder()
            .uri("/api/orgs/memberships")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let memberships_response = app.clone().oneshot(memberships_request).await?;
        let memberships_body = read_json(memberships_response).await?;
        let memberships = memberships_body["data"]["memberships"]
            .as_array()
            .cloned()
            .unwrap_or_default();
        let personal_org_id = memberships
            .iter()
            .find(|membership| membership["default_org"].as_bool().unwrap_or(false))
            .and_then(|membership| membership["org_id"].as_str())
            .unwrap_or_default()
            .to_string();

        let set_openagents_org = Request::builder()
            .method("POST")
            .uri("/api/orgs/active")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(r#"{"org_id":"org:openagents"}"#))?;
        let set_openagents_response = app.clone().oneshot(set_openagents_org).await?;
        assert_eq!(set_openagents_response.status(), StatusCode::OK);

        let denied_by_policy_request = Request::builder()
            .method("POST")
            .uri("/api/sync/token")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"scopes":["runtime.codex_worker_events"],"topics":["org:openagents:worker_events"]}"#,
            ))?;
        let denied_by_policy_response = app.clone().oneshot(denied_by_policy_request).await?;
        assert_eq!(denied_by_policy_response.status(), StatusCode::FORBIDDEN);

        let set_personal_org = Request::builder()
            .method("POST")
            .uri("/api/orgs/active")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(format!(r#"{{"org_id":"{personal_org_id}"}}"#)))?;
        let set_personal_response = app.clone().oneshot(set_personal_org).await?;
        assert_eq!(set_personal_response.status(), StatusCode::OK);

        let invalid_scope_request = Request::builder()
            .method("POST")
            .uri("/api/sync/token")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(r#"{"scopes":["runtime.unknown_scope"]}"#))?;
        let invalid_scope_response = app.clone().oneshot(invalid_scope_request).await?;
        assert_eq!(
            invalid_scope_response.status(),
            StatusCode::UNPROCESSABLE_ENTITY
        );
        let invalid_scope_body = read_json(invalid_scope_response).await?;
        assert_eq!(invalid_scope_body["error"]["code"], "invalid_scope");

        let mismatched_device_request = Request::builder()
            .method("POST")
            .uri("/api/sync/token")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"scopes":["runtime.codex_worker_events"],"device_id":"mobile:other-device"}"#,
            ))?;
        let mismatched_device_response = app.clone().oneshot(mismatched_device_request).await?;
        assert_eq!(mismatched_device_response.status(), StatusCode::FORBIDDEN);

        let unsupported_topic_request = Request::builder()
            .method("POST")
            .uri("/api/sync/token")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"scopes":["runtime.codex_worker_events"],"topics":["org:openagents:unknown"]}"#,
            ))?;
        let unsupported_topic_response = app.clone().oneshot(unsupported_topic_request).await?;
        assert_eq!(
            unsupported_topic_response.status(),
            StatusCode::UNPROCESSABLE_ENTITY
        );
        let unsupported_topic_body = read_json(unsupported_topic_response).await?;
        assert_eq!(unsupported_topic_body["error"]["code"], "invalid_request");

        let success_request = Request::builder()
            .method("POST")
            .uri("/api/sync/token")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"scopes":["runtime.codex_worker_events","runtime.run_summaries"]}"#,
            ))?;
        let success_response = app.oneshot(success_request).await?;
        assert_eq!(success_response.status(), StatusCode::OK);
        let success_body = read_json(success_response).await?;
        assert_eq!(success_body["data"]["token_type"], "Bearer");
        assert_eq!(success_body["data"]["issuer"], "https://openagents.test");
        assert_eq!(success_body["data"]["claims_version"], "oa_sync_claims_v1");

        Ok(())
    }

    #[tokio::test]
    async fn sync_token_requires_active_non_revoked_session() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        let send_request = Request::builder()
            .method("POST")
            .uri("/api/auth/email")
            .header("content-type", "application/json")
            .body(Body::from(r#"{"email":"sync-revoke@openagents.com"}"#))?;
        let send_response = app.clone().oneshot(send_request).await?;
        let cookie = cookie_value(&send_response).unwrap_or_default();

        let verify_request = Request::builder()
            .method("POST")
            .uri("/api/auth/verify")
            .header("content-type", "application/json")
            .header("x-client", "autopilot-ios")
            .header("cookie", cookie)
            .body(Body::from(r#"{"code":"123456"}"#))?;
        let verify_response = app.clone().oneshot(verify_request).await?;
        let verify_body = read_json(verify_response).await?;
        let token = verify_body["token"]
            .as_str()
            .unwrap_or_default()
            .to_string();

        let logout_request = Request::builder()
            .method("POST")
            .uri("/api/auth/logout")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let logout_response = app.clone().oneshot(logout_request).await?;
        assert_eq!(logout_response.status(), StatusCode::OK);

        let sync_request = Request::builder()
            .method("POST")
            .uri("/api/sync/token")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(r#"{"scopes":["runtime.codex_worker_events"]}"#))?;
        let sync_response = app.oneshot(sync_request).await?;
        assert_eq!(sync_response.status(), StatusCode::UNAUTHORIZED);

        Ok(())
    }

    #[tokio::test]
    async fn thread_message_command_requires_authentication() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        let request = Request::builder()
            .method("POST")
            .uri("/api/runtime/threads/thread-1/messages")
            .header("content-type", "application/json")
            .body(Body::from(r#"{"text":"hello"}"#))?;
        let response = app.oneshot(request).await?;
        assert_eq!(response.status(), StatusCode::UNAUTHORIZED);

        Ok(())
    }

    #[tokio::test]
    async fn thread_message_command_accepts_authenticated_message() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        let send_request = Request::builder()
            .method("POST")
            .uri("/api/auth/email")
            .header("content-type", "application/json")
            .body(Body::from(r#"{"email":"thread-command@openagents.com"}"#))?;
        let send_response = app.clone().oneshot(send_request).await?;
        let cookie = cookie_value(&send_response).unwrap_or_default();

        let verify_request = Request::builder()
            .method("POST")
            .uri("/api/auth/verify")
            .header("content-type", "application/json")
            .header("x-client", "autopilot-ios")
            .header("cookie", cookie)
            .body(Body::from(r#"{"code":"123456"}"#))?;
        let verify_response = app.clone().oneshot(verify_request).await?;
        let verify_body = read_json(verify_response).await?;
        let token = verify_body["token"]
            .as_str()
            .unwrap_or_default()
            .to_string();

        let command_request = Request::builder()
            .method("POST")
            .uri("/api/runtime/threads/thread-42/messages")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from("{\"text\":\"Who are you?\"}"))?;
        let command_response = app.oneshot(command_request).await?;
        assert_eq!(command_response.status(), StatusCode::OK);
        let command_body = read_json(command_response).await?;
        assert_eq!(command_body["data"]["accepted"], true);
        assert_eq!(command_body["data"]["message"]["thread_id"], "thread-42");
        assert_eq!(command_body["data"]["message"]["text"], "Who are you?");
        assert!(
            command_body["data"]["message"]["id"]
                .as_str()
                .unwrap_or_default()
                .starts_with("msg_")
        );

        Ok(())
    }

    #[tokio::test]
    async fn runtime_thread_read_paths_return_projected_threads_and_messages() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token = authenticate_token(app.clone(), "thread-read@openagents.com").await?;

        for thread_id in ["thread-42", "thread-42", "thread-99"] {
            let request = Request::builder()
                .method("POST")
                .uri(format!("/api/runtime/threads/{thread_id}/messages"))
                .header("content-type", "application/json")
                .header("authorization", format!("Bearer {token}"))
                .body(Body::from(r#"{"text":"hello"}"#))?;
            let response = app.clone().oneshot(request).await?;
            assert_eq!(response.status(), StatusCode::OK);
        }

        let list_threads_request = Request::builder()
            .method("GET")
            .uri("/api/runtime/threads")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let list_threads_response = app.clone().oneshot(list_threads_request).await?;
        assert_eq!(list_threads_response.status(), StatusCode::OK);
        let list_threads_body = read_json(list_threads_response).await?;
        assert_eq!(
            list_threads_body["data"]["threads"]
                .as_array()
                .map(Vec::len),
            Some(2)
        );

        let list_messages_request = Request::builder()
            .method("GET")
            .uri("/api/runtime/threads/thread-42/messages")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let list_messages_response = app.oneshot(list_messages_request).await?;
        assert_eq!(list_messages_response.status(), StatusCode::OK);
        let list_messages_body = read_json(list_messages_response).await?;
        assert_eq!(
            list_messages_body["data"]["messages"]
                .as_array()
                .map(Vec::len),
            Some(2)
        );

        Ok(())
    }

    #[tokio::test]
    async fn runtime_thread_message_read_path_enforces_owner_boundary() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let owner_token = authenticate_token(app.clone(), "thread-owner@openagents.com").await?;
        let other_token = authenticate_token(app.clone(), "thread-other@openagents.com").await?;

        let append_request = Request::builder()
            .method("POST")
            .uri("/api/runtime/threads/thread-private/messages")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {owner_token}"))
            .body(Body::from(r#"{"text":"private"}"#))?;
        let append_response = app.clone().oneshot(append_request).await?;
        assert_eq!(append_response.status(), StatusCode::OK);

        let read_other_request = Request::builder()
            .method("GET")
            .uri("/api/runtime/threads/thread-private/messages")
            .header("authorization", format!("Bearer {other_token}"))
            .body(Body::empty())?;
        let read_other_response = app.oneshot(read_other_request).await?;
        assert_eq!(read_other_response.status(), StatusCode::FORBIDDEN);

        Ok(())
    }

    #[tokio::test]
    async fn legacy_guest_session_route_requires_authenticated_codex_account() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));

        let request = Request::builder()
            .method("GET")
            .uri("/api/chat/guest-session?conversationId=g-1234567890abcdef1234567890abcdef")
            .body(Body::empty())?;
        let response = app.clone().oneshot(request).await?;
        assert_eq!(response.status(), StatusCode::UNAUTHORIZED);
        let body = read_json(response).await?;
        assert_eq!(body["error"]["code"], json!("unauthorized"));
        let message = body["message"].as_str().unwrap_or_default();
        assert!(
            matches!(
                message,
                "Codex chat requires an authenticated ChatGPT account." | "Unauthenticated."
            ),
            "unexpected unauthorized message: {message}"
        );

        Ok(())
    }

    #[tokio::test]
    async fn legacy_guest_session_route_returns_retirement_contract_for_authenticated_user()
    -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token = authenticate_token(app.clone(), "legacy-guest-session@openagents.com").await?;

        let request = Request::builder()
            .method("GET")
            .uri("/api/chat/guest-session?conversationId=g-1234567890abcdef1234567890abcdef")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let response = app.clone().oneshot(request).await?;
        assert_eq!(response.status(), StatusCode::GONE);
        assert!(response.headers().get("x-oa-legacy-chat-retired").is_none());
        assert!(
            response
                .headers()
                .get("x-oa-legacy-chat-canonical")
                .is_none()
        );
        assert_eq!(
            response
                .headers()
                .get("x-oa-chat-auth-policy")
                .and_then(|value| value.to_str().ok()),
            Some("codex-auth-required")
        );
        let body = read_json(response).await?;
        assert_eq!(body["data"]["retired"], json!(true));
        assert_eq!(body["data"]["status"], json!("codex_auth_required"));
        assert_eq!(body["data"]["canonical"], json!("/api/runtime/threads"));

        Ok(())
    }

    #[tokio::test]
    async fn legacy_chats_aliases_map_to_codex_threads() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token = authenticate_token(app.clone(), "legacy-chats@openagents.com").await?;

        let create_request = Request::builder()
            .method("POST")
            .uri("/api/chats")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(r#"{"title":"Migration Chat"}"#))?;
        let create_response = app.clone().oneshot(create_request).await?;
        assert_eq!(create_response.status(), StatusCode::CREATED);
        assert!(
            create_response
                .headers()
                .get("x-oa-legacy-chat-retired")
                .is_none()
        );
        assert!(
            create_response
                .headers()
                .get("x-oa-legacy-chat-canonical")
                .is_none()
        );
        let create_body = read_json(create_response).await?;
        let conversation_id = create_body["data"]["id"]
            .as_str()
            .unwrap_or_default()
            .to_string();
        assert!(conversation_id.starts_with("thread_"));

        let runtime_threads_request = Request::builder()
            .method("GET")
            .uri("/api/runtime/threads")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let runtime_threads_response = app.clone().oneshot(runtime_threads_request).await?;
        assert_eq!(runtime_threads_response.status(), StatusCode::OK);
        let runtime_threads_body = read_json(runtime_threads_response).await?;
        let contains_thread = runtime_threads_body["data"]["threads"]
            .as_array()
            .map(|threads| {
                threads
                    .iter()
                    .any(|thread| thread["thread_id"] == json!(conversation_id.clone()))
            })
            .unwrap_or(false);
        assert!(contains_thread);

        let send_message_request = Request::builder()
            .method("POST")
            .uri(format!("/api/runtime/threads/{conversation_id}/messages"))
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(r#"{"text":"legacy bridge message"}"#))?;
        let send_message_response = app.clone().oneshot(send_message_request).await?;
        assert_eq!(send_message_response.status(), StatusCode::OK);

        let show_request = Request::builder()
            .method("GET")
            .uri(format!("/api/chats/{conversation_id}"))
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let show_response = app.clone().oneshot(show_request).await?;
        assert_eq!(show_response.status(), StatusCode::OK);
        let show_body = read_json(show_response).await?;
        assert_eq!(
            show_body["data"]["conversation"]["id"],
            json!(conversation_id.clone())
        );
        assert_eq!(
            show_body["data"]["messages"]
                .as_array()
                .map(Vec::len)
                .unwrap_or_default(),
            1
        );
        assert_eq!(
            show_body["data"]["messages"][0]["content"],
            json!("legacy bridge message")
        );
        assert_eq!(
            show_body["data"]["runs"]
                .as_array()
                .map(Vec::len)
                .unwrap_or_default(),
            0
        );

        let runs_request = Request::builder()
            .method("GET")
            .uri(format!("/api/chats/{conversation_id}/runs"))
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let runs_response = app.clone().oneshot(runs_request).await?;
        assert_eq!(runs_response.status(), StatusCode::OK);
        let runs_body = read_json(runs_response).await?;
        assert_eq!(
            runs_body["data"]
                .as_array()
                .map(Vec::len)
                .unwrap_or_default(),
            0
        );

        let events_request = Request::builder()
            .method("GET")
            .uri(format!(
                "/api/chats/{conversation_id}/runs/run_legacy/events"
            ))
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let events_response = app.oneshot(events_request).await?;
        assert_eq!(events_response.status(), StatusCode::OK);
        let events_body = read_json(events_response).await?;
        assert_eq!(events_body["data"]["run"]["status"], json!("retired"));
        assert_eq!(
            events_body["data"]["events"]
                .as_array()
                .map(Vec::len)
                .unwrap_or_default(),
            0
        );

        Ok(())
    }

    #[tokio::test]
    async fn legacy_chat_show_rejects_cross_user_access() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let owner_token = authenticate_token(app.clone(), "legacy-owner@openagents.com").await?;
        let other_token = authenticate_token(app.clone(), "legacy-other@openagents.com").await?;

        let create_request = Request::builder()
            .method("POST")
            .uri("/api/chats")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {owner_token}"))
            .body(Body::from(r#"{"title":"Owner Chat"}"#))?;
        let create_response = app.clone().oneshot(create_request).await?;
        assert_eq!(create_response.status(), StatusCode::CREATED);
        let create_body = read_json(create_response).await?;
        let conversation_id = create_body["data"]["id"]
            .as_str()
            .unwrap_or_default()
            .to_string();
        assert!(!conversation_id.is_empty());

        let other_show_request = Request::builder()
            .method("GET")
            .uri(format!("/api/chats/{conversation_id}"))
            .header("authorization", format!("Bearer {other_token}"))
            .body(Body::empty())?;
        let other_show_response = app.oneshot(other_show_request).await?;
        assert_eq!(other_show_response.status(), StatusCode::FORBIDDEN);

        Ok(())
    }

    #[tokio::test]
    async fn legacy_chat_stream_alias_bridges_to_codex_control_request() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token = authenticate_token(app.clone(), "legacy-stream@openagents.com").await?;

        let stream_request = Request::builder()
            .method("POST")
            .uri("/api/chat/stream")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"id":"thread-stream-alias","messages":[{"role":"user","content":"bridge hello"}]}"#,
            ))?;
        let stream_response = app.clone().oneshot(stream_request).await?;
        assert_eq!(stream_response.status(), StatusCode::OK);
        assert_eq!(
            stream_response
                .headers()
                .get(CONTENT_TYPE)
                .and_then(|value| value.to_str().ok()),
            Some("text/event-stream; charset=utf-8")
        );
        assert_eq!(
            stream_response
                .headers()
                .get("x-vercel-ai-ui-message-stream")
                .and_then(|value| value.to_str().ok()),
            Some("v1")
        );
        assert!(
            stream_response
                .headers()
                .get("x-oa-legacy-chat-retired")
                .is_none()
        );
        assert!(
            stream_response
                .headers()
                .get("x-oa-legacy-chat-canonical")
                .is_none()
        );
        assert!(
            stream_response
                .headers()
                .get("x-oa-legacy-chat-stream-protocol")
                .is_none()
        );
        let stream_body = read_text(stream_response).await?;
        assert!(stream_body.contains("\"type\":\"start\""));
        assert!(stream_body.contains("\"type\":\"start-step\""));
        assert!(stream_body.contains("\"threadId\":\"thread-stream-alias\""));
        assert!(stream_body.contains("\"type\":\"finish-step\""));
        assert!(stream_body.contains("\"type\":\"finish\""));
        assert!(stream_body.ends_with("data: [DONE]\n\n"));

        let messages_request = Request::builder()
            .method("GET")
            .uri("/api/runtime/threads/thread-stream-alias/messages")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let messages_response = app.oneshot(messages_request).await?;
        assert_eq!(messages_response.status(), StatusCode::OK);
        let messages_body = read_json(messages_response).await?;
        assert_eq!(
            messages_body["data"]["messages"][0]["text"],
            json!("bridge hello")
        );

        Ok(())
    }

    #[tokio::test]
    async fn legacy_chats_stream_alias_uses_path_thread_id_and_accepts_structured_content()
    -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token = authenticate_token(app.clone(), "legacy-stream-path@openagents.com").await?;

        let stream_request = Request::builder()
            .method("POST")
            .uri("/api/chats/thread-stream-path/stream")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"messages":[{"role":"user","content":[{"type":"text","text":"path bridge"}]}]}"#,
            ))?;
        let stream_response = app.clone().oneshot(stream_request).await?;
        assert_eq!(stream_response.status(), StatusCode::OK);
        assert_eq!(
            stream_response
                .headers()
                .get(CONTENT_TYPE)
                .and_then(|value| value.to_str().ok()),
            Some("text/event-stream; charset=utf-8")
        );
        let stream_body = read_text(stream_response).await?;
        assert!(stream_body.contains("\"threadId\":\"thread-stream-path\""));
        assert!(stream_body.ends_with("data: [DONE]\n\n"));

        let messages_request = Request::builder()
            .method("GET")
            .uri("/api/runtime/threads/thread-stream-path/messages")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let messages_response = app.oneshot(messages_request).await?;
        assert_eq!(messages_response.status(), StatusCode::OK);
        let messages_body = read_json(messages_response).await?;
        assert_eq!(
            messages_body["data"]["messages"][0]["text"],
            json!("path bridge")
        );

        Ok(())
    }

    #[tokio::test]
    async fn legacy_chat_stream_alias_rejects_payload_without_user_text() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token = authenticate_token(app.clone(), "legacy-stream-bad@openagents.com").await?;

        let stream_request = Request::builder()
            .method("POST")
            .uri("/api/chat/stream")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"messages":[{"role":"assistant","content":"no user message"}]}"#,
            ))?;
        let stream_response = app.oneshot(stream_request).await?;
        assert_eq!(stream_response.status(), StatusCode::UNPROCESSABLE_ENTITY);
        let stream_body = read_json(stream_response).await?;
        assert_eq!(stream_body["error"]["code"], json!("invalid_request"));

        Ok(())
    }

    #[tokio::test]
    async fn legacy_chat_stream_edge_malformed_payloads_reject_deterministically() -> Result<()> {
        let static_dir = tempdir()?;
        let app = build_router(compat_enforced_config(static_dir.path().to_path_buf()));
        let token =
            authenticate_token(app.clone(), "legacy-stream-edge-malformed@openagents.com").await?;

        let malformed_json_request = legacy_stream_request(
            "/api/chat/stream",
            Some(&token),
            r#"{"messages":[{"role":"user","content":"oops"}"#,
        )?;
        let malformed_json_response = app.clone().oneshot(malformed_json_request).await?;
        assert_eq!(malformed_json_response.status(), StatusCode::BAD_REQUEST);

        let missing_text_request = legacy_stream_request(
            "/api/chat/stream",
            Some(&token),
            r#"{"messages":[{"role":"assistant","content":"no user payload"}]}"#,
        )?;
        let missing_text_response = app.oneshot(missing_text_request).await?;
        assert_eq!(
            missing_text_response.status(),
            StatusCode::UNPROCESSABLE_ENTITY
        );
        let missing_text_body = read_json(missing_text_response).await?;
        assert_eq!(missing_text_body["error"]["code"], json!("invalid_request"));

        Ok(())
    }

    #[tokio::test]
    async fn legacy_chat_stream_edge_guest_auth_gating_requires_bearer_token() -> Result<()> {
        let static_dir = tempdir()?;
        let app = build_router(compat_enforced_config(static_dir.path().to_path_buf()));

        let unauthenticated_request = legacy_stream_request(
            "/api/chat/stream",
            None,
            r#"{"messages":[{"role":"user","content":"missing auth"}]}"#,
        )?;
        let unauthenticated_response = app.clone().oneshot(unauthenticated_request).await?;
        assert_eq!(unauthenticated_response.status(), StatusCode::UNAUTHORIZED);
        let unauthenticated_body = read_json(unauthenticated_response).await?;
        assert_eq!(unauthenticated_body["error"]["code"], json!("unauthorized"));

        let token =
            authenticate_token(app.clone(), "legacy-stream-edge-auth@openagents.com").await?;
        let authenticated_request = legacy_stream_request(
            "/api/chat/stream",
            Some(&token),
            r#"{"messages":[{"role":"user","content":"authorized"}]}"#,
        )?;
        let authenticated_response = app.oneshot(authenticated_request).await?;
        assert_eq!(authenticated_response.status(), StatusCode::OK);
        let wire = read_text(authenticated_response).await?;
        assert_eq!(
            sse_event_types(&wire),
            vec!["start", "start-step", "finish-step", "finish"]
        );
        assert_eq!(sse_done_count(&wire), 1);

        Ok(())
    }

    #[tokio::test]
    async fn legacy_chat_stream_edge_tool_event_ordering_matches_legacy_contract() -> Result<()> {
        let stream = super::vercel_sse_adapter::translate_codex_events(&[
            super::vercel_sse_adapter::CodexCompatibilityEvent {
                method: "thread/started".to_string(),
                params: json!({"thread_id":"thread_edge_tools"}),
            },
            super::vercel_sse_adapter::CodexCompatibilityEvent {
                method: "turn/started".to_string(),
                params: json!({
                    "thread_id":"thread_edge_tools",
                    "turn_id":"turn_edge_tools",
                    "model":"gpt-5.2-codex"
                }),
            },
            super::vercel_sse_adapter::CodexCompatibilityEvent {
                method: "item/started".to_string(),
                params: json!({
                    "item_id":"tool_edge_1",
                    "item_kind":"mcp_tool_call",
                    "item":{"tool_name":"openagents_api","arguments":{"q":"status"}}
                }),
            },
            super::vercel_sse_adapter::CodexCompatibilityEvent {
                method: "item/toolOutput/delta".to_string(),
                params: json!({"item_id":"tool_edge_1","delta":"{\"ok\":true}"}),
            },
            super::vercel_sse_adapter::CodexCompatibilityEvent {
                method: "item/completed".to_string(),
                params: json!({
                    "item_id":"tool_edge_1",
                    "item_kind":"mcp_tool_call",
                    "item_status":"completed"
                }),
            },
            super::vercel_sse_adapter::CodexCompatibilityEvent {
                method: "turn/completed".to_string(),
                params: json!({"turn_id":"turn_edge_tools","status":"completed"}),
            },
        ])?;

        assert_eq!(
            sse_event_types(&stream.wire),
            vec![
                "start",
                "start-step",
                "tool-input",
                "tool-output",
                "tool-output",
                "finish-step",
                "finish"
            ]
        );
        assert_eq!(sse_done_count(&stream.wire), 1);

        Ok(())
    }

    #[tokio::test]
    async fn legacy_chat_stream_edge_terminal_error_sequence_is_stable() -> Result<()> {
        let stream = super::vercel_sse_adapter::translate_codex_events(&[
            super::vercel_sse_adapter::CodexCompatibilityEvent {
                method: "thread/started".to_string(),
                params: json!({"thread_id":"thread_edge_error"}),
            },
            super::vercel_sse_adapter::CodexCompatibilityEvent {
                method: "turn/started".to_string(),
                params: json!({
                    "thread_id":"thread_edge_error",
                    "turn_id":"turn_edge_error",
                    "model":"gpt-5.2-codex"
                }),
            },
            super::vercel_sse_adapter::CodexCompatibilityEvent {
                method: "turn/failed".to_string(),
                params: json!({"message":"forced failure","will_retry":false}),
            },
        ])?;

        let event_types = sse_event_types(&stream.wire);
        assert_eq!(event_types, vec!["start", "start-step", "error", "finish"]);
        assert_eq!(
            stream.events[2].get("code").and_then(Value::as_str),
            Some("turn_failed")
        );
        assert_eq!(
            stream.events[3].get("status").and_then(Value::as_str),
            Some("error")
        );
        assert_eq!(sse_done_count(&stream.wire), 1);

        Ok(())
    }

    #[tokio::test]
    async fn runtime_codex_control_request_accepts_turn_start_and_persists_message() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token = authenticate_token(app.clone(), "codex-control@openagents.com").await?;

        let control_request = Request::builder()
            .method("POST")
            .uri("/api/runtime/codex/workers/desktopw%3Ashared/requests")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"request":{"request_id":"req_turn_1","method":"turn/start","params":{"thread_id":"thread-control-1","text":"continue"}}}"#,
            ))?;
        let control_response = app.clone().oneshot(control_request).await?;
        assert_eq!(control_response.status(), StatusCode::OK);
        let control_body = read_json(control_response).await?;
        assert_eq!(control_body["data"]["method"], "turn/start");
        assert_eq!(control_body["data"]["request_id"], "req_turn_1");
        assert_eq!(control_body["data"]["idempotent_replay"], false);
        assert_eq!(
            control_body["data"]["response"]["thread_id"],
            "thread-control-1"
        );
        assert!(
            control_body["data"]["response"]["turn"]["id"]
                .as_str()
                .unwrap_or_default()
                .starts_with("turn_")
        );

        let list_messages_request = Request::builder()
            .method("GET")
            .uri("/api/runtime/threads/thread-control-1/messages")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let list_messages_response = app.oneshot(list_messages_request).await?;
        assert_eq!(list_messages_response.status(), StatusCode::OK);
        let list_messages_body = read_json(list_messages_response).await?;
        assert_eq!(
            list_messages_body["data"]["messages"][0]["text"],
            serde_json::json!("continue")
        );

        Ok(())
    }

    #[tokio::test]
    async fn runtime_codex_control_request_replays_duplicate_request_ids() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token = authenticate_token(app.clone(), "codex-replay@openagents.com").await?;
        let payload = r#"{"request":{"request_id":"req_replay_1","method":"thread/start","params":{"thread_id":"thread-replay-1"}}}"#;

        let first_request = Request::builder()
            .method("POST")
            .uri("/api/runtime/codex/workers/desktopw%3Ashared/requests")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(payload))?;
        let first_response = app.clone().oneshot(first_request).await?;
        assert_eq!(first_response.status(), StatusCode::OK);
        let first_body = read_json(first_response).await?;
        assert_eq!(first_body["data"]["idempotent_replay"], false);

        let second_request = Request::builder()
            .method("POST")
            .uri("/api/runtime/codex/workers/desktopw%3Ashared/requests")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(payload))?;
        let second_response = app.oneshot(second_request).await?;
        assert_eq!(second_response.status(), StatusCode::OK);
        let second_body = read_json(second_response).await?;
        assert_eq!(second_body["data"]["idempotent_replay"], true);
        assert_eq!(
            second_body["data"]["response"]["thread_id"],
            serde_json::json!("thread-replay-1")
        );

        Ok(())
    }

    #[tokio::test]
    async fn runtime_codex_control_request_rejects_non_allowlisted_methods() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token = authenticate_token(app.clone(), "codex-invalid@openagents.com").await?;

        let request = Request::builder()
            .method("POST")
            .uri("/api/runtime/codex/workers/desktopw%3Ashared/requests")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"request":{"request_id":"req_bad_1","method":"shell/exec","params":{}}}"#,
            ))?;
        let response = app.oneshot(request).await?;
        assert_eq!(response.status(), StatusCode::UNPROCESSABLE_ENTITY);
        let body = read_json(response).await?;
        assert_eq!(body["error"]["code"], "invalid_request");

        Ok(())
    }

    #[tokio::test]
    async fn runtime_codex_worker_lifecycle_routes_support_create_events_stream_and_stop()
    -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token =
            authenticate_token(app.clone(), "codex-worker-lifecycle@openagents.com").await?;

        let create_request = Request::builder()
            .method("POST")
            .uri("/api/runtime/codex/workers")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"worker_id":"desktopw:lifecycle","workspace_ref":"ws-local","adapter":"codex_cli"}"#,
            ))?;
        let create_response = app.clone().oneshot(create_request).await?;
        assert_eq!(create_response.status(), StatusCode::ACCEPTED);
        let create_body = read_json(create_response).await?;
        assert_eq!(create_body["data"]["workerId"], "desktopw:lifecycle");
        assert_eq!(create_body["data"]["status"], "running");
        assert_eq!(create_body["data"]["latestSeq"], 0);
        assert_eq!(create_body["data"]["idempotentReplay"], false);

        let list_request = Request::builder()
            .method("GET")
            .uri("/api/runtime/codex/workers?status=running&workspace_ref=ws-local")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let list_response = app.clone().oneshot(list_request).await?;
        assert_eq!(list_response.status(), StatusCode::OK);
        let list_body = read_json(list_response).await?;
        let workers = list_body["data"].as_array().cloned().unwrap_or_default();
        assert!(
            workers
                .iter()
                .any(|worker| worker["worker_id"] == json!("desktopw:lifecycle"))
        );

        let show_request = Request::builder()
            .method("GET")
            .uri("/api/runtime/codex/workers/desktopw%3Alifecycle")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let show_response = app.clone().oneshot(show_request).await?;
        assert_eq!(show_response.status(), StatusCode::OK);
        let show_body = read_json(show_response).await?;
        assert_eq!(show_body["data"]["worker_id"], "desktopw:lifecycle");
        assert_eq!(show_body["data"]["status"], "running");
        assert_eq!(show_body["data"]["latest_seq"], 0);

        let event_request = Request::builder()
            .method("POST")
            .uri("/api/runtime/codex/workers/desktopw%3Alifecycle/events")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"event":{"event_type":"worker.event","payload":{"source":"autopilot-ios","method":"ios/handshake","handshake_id":"hs_1","occurred_at":"2026-02-22T00:00:00Z","device_id":"ios:device"}}}"#,
            ))?;
        let event_response = app.clone().oneshot(event_request).await?;
        assert_eq!(event_response.status(), StatusCode::ACCEPTED);
        let event_body = read_json(event_response).await?;
        assert_eq!(event_body["data"]["worker_id"], "desktopw:lifecycle");
        assert_eq!(event_body["data"]["event_type"], "worker.event");
        assert_eq!(event_body["data"]["seq"], 1);

        let stream_request = Request::builder()
            .method("GET")
            .uri("/api/runtime/codex/workers/desktopw%3Alifecycle/stream?cursor=0&tail_ms=5000")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let stream_response = app.clone().oneshot(stream_request).await?;
        assert_eq!(stream_response.status(), StatusCode::OK);
        let stream_body = read_json(stream_response).await?;
        assert_eq!(stream_body["data"]["stream_protocol"], "khala_ws");
        assert_eq!(stream_body["data"]["delivery"]["transport"], "khala_ws");
        let events = stream_body["data"]["events"]
            .as_array()
            .cloned()
            .unwrap_or_default();
        assert_eq!(events.len(), 1);
        assert_eq!(events[0]["event_type"], "worker.event");
        assert_eq!(events[0]["seq"], 1);

        let stop_request = Request::builder()
            .method("POST")
            .uri("/api/runtime/codex/workers/desktopw%3Alifecycle/stop")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(r#"{"reason":"test_complete"}"#))?;
        let stop_response = app.clone().oneshot(stop_request).await?;
        assert_eq!(stop_response.status(), StatusCode::ACCEPTED);
        let stop_body = read_json(stop_response).await?;
        assert_eq!(stop_body["data"]["status"], "stopped");
        assert_eq!(stop_body["data"]["seq"], 2);
        assert_eq!(stop_body["data"]["idempotent_replay"], false);
        assert_eq!(stop_body["data"]["idempotentReplay"], false);

        let stop_replay_request = Request::builder()
            .method("POST")
            .uri("/api/runtime/codex/workers/desktopw%3Alifecycle/stop")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from("{}"))?;
        let stop_replay_response = app.clone().oneshot(stop_replay_request).await?;
        assert_eq!(stop_replay_response.status(), StatusCode::ACCEPTED);
        let stop_replay_body = read_json(stop_replay_response).await?;
        assert_eq!(stop_replay_body["data"]["seq"], 2);
        assert_eq!(stop_replay_body["data"]["idempotent_replay"], true);
        assert_eq!(stop_replay_body["data"]["idempotentReplay"], true);

        let stream_after_stop_request = Request::builder()
            .method("GET")
            .uri("/api/runtime/codex/workers/desktopw%3Alifecycle/stream?cursor=1")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let stream_after_stop_response = app.oneshot(stream_after_stop_request).await?;
        assert_eq!(stream_after_stop_response.status(), StatusCode::OK);
        let stream_after_stop_body = read_json(stream_after_stop_response).await?;
        let events_after_stop = stream_after_stop_body["data"]["events"]
            .as_array()
            .cloned()
            .unwrap_or_default();
        assert_eq!(events_after_stop.len(), 1);
        assert_eq!(events_after_stop[0]["event_type"], "worker.stopped");
        assert_eq!(events_after_stop[0]["seq"], 2);

        Ok(())
    }

    #[tokio::test]
    async fn runtime_codex_worker_events_validate_handshake_requirements() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token =
            authenticate_token(app.clone(), "codex-worker-validation@openagents.com").await?;

        let missing_device_request = Request::builder()
            .method("POST")
            .uri("/api/runtime/codex/workers/desktopw%3Avalidation/events")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"event":{"event_type":"worker.event","payload":{"source":"autopilot-ios","method":"ios/handshake","handshake_id":"hs_2","occurred_at":"2026-02-22T00:00:00Z"}}}"#,
            ))?;
        let missing_device_response = app.oneshot(missing_device_request).await?;
        assert_eq!(
            missing_device_response.status(),
            StatusCode::UNPROCESSABLE_ENTITY
        );
        let missing_device_body = read_json(missing_device_response).await?;
        assert_eq!(missing_device_body["error"]["code"], "invalid_request");

        Ok(())
    }

    #[tokio::test]
    async fn runtime_codex_workers_index_rejects_invalid_status_filter() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token =
            authenticate_token(app.clone(), "codex-worker-list-invalid@openagents.com").await?;

        let request = Request::builder()
            .method("GET")
            .uri("/api/runtime/codex/workers?status=unsupported")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let response = app.oneshot(request).await?;
        assert_eq!(response.status(), StatusCode::UNPROCESSABLE_ENTITY);
        let body = read_json(response).await?;
        assert_eq!(body["error"]["code"], "invalid_request");

        Ok(())
    }

    #[tokio::test]
    async fn runtime_codex_control_request_conflicts_for_stopped_worker() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token = authenticate_token(app.clone(), "codex-worker-stopped@openagents.com").await?;

        let create_request = Request::builder()
            .method("POST")
            .uri("/api/runtime/codex/workers")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(r#"{"worker_id":"desktopw:stopped"}"#))?;
        let create_response = app.clone().oneshot(create_request).await?;
        assert_eq!(create_response.status(), StatusCode::ACCEPTED);

        let stop_request = Request::builder()
            .method("POST")
            .uri("/api/runtime/codex/workers/desktopw%3Astopped/stop")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from("{}"))?;
        let stop_response = app.clone().oneshot(stop_request).await?;
        assert_eq!(stop_response.status(), StatusCode::ACCEPTED);

        let control_request = Request::builder()
            .method("POST")
            .uri("/api/runtime/codex/workers/desktopw%3Astopped/requests")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"request":{"request_id":"req_stopped_1","method":"turn/start","params":{"thread_id":"thread-stopped-1","text":"continue"}}}"#,
            ))?;
        let control_response = app.oneshot(control_request).await?;
        assert_eq!(control_response.status(), StatusCode::CONFLICT);
        let control_body = read_json(control_response).await?;
        assert_eq!(control_body["error"]["code"], "conflict");

        Ok(())
    }

    #[tokio::test]
    async fn runtime_tools_execute_returns_deterministic_receipts_and_replays() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token = authenticate_token(app.clone(), "runtime-tools@openagents.com").await?;
        let payload = r#"{
            "tool_pack":"coding.v1",
            "mode":"replay",
            "run_id":"run_tools_1",
            "thread_id":"thread_tools_1",
            "manifest_ref":{"integration_id":"github.primary"},
            "request":{
                "integration_id":"github.primary",
                "operation":"get_issue",
                "repository":"OpenAgentsInc/openagents",
                "issue_number":1747,
                "tool_call_id":"tool_call_001"
            },
            "policy":{
                "authorization_id":"auth_123",
                "authorization_mode":"delegated_budget",
                "budget":{"max_per_call_sats":100}
            }
        }"#;

        let first_request = Request::builder()
            .method("POST")
            .uri("/api/runtime/tools/execute")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(payload))?;
        let first_response = app.clone().oneshot(first_request).await?;
        assert_eq!(first_response.status(), StatusCode::OK);
        let first_body = read_json(first_response).await?;
        assert_eq!(first_body["data"]["state"], "succeeded");
        assert_eq!(first_body["data"]["decision"], "allowed");
        assert_eq!(first_body["data"]["reason_code"], "policy_allowed.default");
        assert_eq!(first_body["data"]["idempotentReplay"], false);
        assert!(
            first_body["data"]["receipt"]["receipt_id"]
                .as_str()
                .unwrap_or_default()
                .starts_with("coding_")
        );

        let second_request = Request::builder()
            .method("POST")
            .uri("/api/runtime/tools/execute")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(payload))?;
        let second_response = app.oneshot(second_request).await?;
        assert_eq!(second_response.status(), StatusCode::OK);
        let second_body = read_json(second_response).await?;
        assert_eq!(second_body["data"]["idempotentReplay"], true);
        assert_eq!(
            second_body["data"]["receipt"]["replay_hash"],
            first_body["data"]["receipt"]["replay_hash"]
        );

        Ok(())
    }

    #[tokio::test]
    async fn runtime_tools_execute_rejects_user_mismatch_and_missing_manifest() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token = authenticate_token(app.clone(), "runtime-mismatch@openagents.com").await?;

        let session_request = Request::builder()
            .method("GET")
            .uri("/api/auth/session")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let session_response = app.clone().oneshot(session_request).await?;
        assert_eq!(session_response.status(), StatusCode::OK);
        let session_body = read_json(session_response).await?;
        let user_id = session_body["data"]["user"]["id"]
            .as_str()
            .unwrap_or_default()
            .to_string();
        let authenticated_user_id = crate::runtime_tools_principal_user_id(&user_id);

        let mismatch_request = Request::builder()
            .method("POST")
            .uri("/api/runtime/tools/execute")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(format!(
                r#"{{
                    "tool_pack":"coding.v1",
                    "manifest_ref":{{"integration_id":"github.primary"}},
                    "request":{{"integration_id":"github.primary","operation":"get_issue","repository":"OpenAgentsInc/openagents","issue_number":1747}},
                    "user_id":{}
                }}"#,
                authenticated_user_id.saturating_add(1)
            )))?;
        let mismatch_response = app.clone().oneshot(mismatch_request).await?;
        assert_eq!(mismatch_response.status(), StatusCode::FORBIDDEN);
        let mismatch_body = read_json(mismatch_response).await?;
        assert_eq!(mismatch_body["error"]["code"], "forbidden");

        let missing_manifest_request = Request::builder()
            .method("POST")
            .uri("/api/runtime/tools/execute")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"tool_pack":"coding.v1","request":{"integration_id":"github.primary","operation":"get_issue","repository":"OpenAgentsInc/openagents","issue_number":1747}}"#,
            ))?;
        let missing_manifest_response = app.oneshot(missing_manifest_request).await?;
        assert_eq!(
            missing_manifest_response.status(),
            StatusCode::UNPROCESSABLE_ENTITY
        );
        let missing_manifest_body = read_json(missing_manifest_response).await?;
        assert_eq!(missing_manifest_body["error"]["code"], "invalid_request");
        assert_eq!(
            missing_manifest_body["message"],
            "manifest or manifest_ref is required"
        );

        Ok(())
    }

    #[tokio::test]
    async fn runtime_tools_execute_enforces_write_approval_policy() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token = authenticate_token(app.clone(), "runtime-write@openagents.com").await?;

        let denied_request = Request::builder()
            .method("POST")
            .uri("/api/runtime/tools/execute")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{
                    "tool_pack":"coding.v1",
                    "manifest":{
                        "capabilities":["add_issue_comment"],
                        "policy":{"write_operations_mode":"enforce"}
                    },
                    "request":{
                        "integration_id":"github.primary",
                        "operation":"add_issue_comment",
                        "repository":"OpenAgentsInc/openagents",
                        "issue_number":1747,
                        "body":"Ship it."
                    },
                    "policy":{"write_approved":false}
                }"#,
            ))?;
        let denied_response = app.clone().oneshot(denied_request).await?;
        assert_eq!(denied_response.status(), StatusCode::OK);
        let denied_body = read_json(denied_response).await?;
        assert_eq!(denied_body["data"]["decision"], "denied");
        assert_eq!(denied_body["data"]["state"], "blocked");
        assert_eq!(
            denied_body["data"]["reason_code"],
            "policy_denied.write_approval_required"
        );

        let allowed_request = Request::builder()
            .method("POST")
            .uri("/api/runtime/tools/execute")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{
                    "tool_pack":"coding.v1",
                    "manifest":{
                        "capabilities":["add_issue_comment"],
                        "policy":{"write_operations_mode":"enforce"}
                    },
                    "request":{
                        "integration_id":"github.primary",
                        "operation":"add_issue_comment",
                        "repository":"OpenAgentsInc/openagents",
                        "issue_number":1747,
                        "body":"Ship it."
                    },
                    "policy":{"write_approved":true}
                }"#,
            ))?;
        let allowed_response = app.oneshot(allowed_request).await?;
        assert_eq!(allowed_response.status(), StatusCode::OK);
        let allowed_body = read_json(allowed_response).await?;
        assert_eq!(allowed_body["data"]["decision"], "allowed");
        assert_eq!(allowed_body["data"]["state"], "succeeded");
        assert_eq!(
            allowed_body["data"]["result"]["comment"]["body"],
            "Ship it."
        );

        Ok(())
    }

    #[tokio::test]
    async fn runtime_skill_registry_routes_support_list_upsert_publish_and_release() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token = authenticate_token(app.clone(), "runtime-skills@openagents.com").await?;

        let list_tools_request = Request::builder()
            .method("GET")
            .uri("/api/runtime/skills/tool-specs")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let list_tools_response = app.clone().oneshot(list_tools_request).await?;
        assert_eq!(list_tools_response.status(), StatusCode::OK);
        let list_tools_body = read_json(list_tools_response).await?;
        let tool_specs = list_tools_body["data"]
            .as_array()
            .cloned()
            .unwrap_or_default();
        assert!(
            tool_specs
                .iter()
                .any(|tool| tool["tool_id"] == serde_json::json!("github.primary"))
        );

        let store_tool_request = Request::builder()
            .method("POST")
            .uri("/api/runtime/skills/tool-specs")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{
                    "state":"validated",
                    "tool_spec":{
                        "tool_id":"github.custom",
                        "version":1,
                        "tool_pack":"coding.v1",
                        "name":"GitHub Custom",
                        "execution_kind":"http",
                        "integration_manifest":{
                            "manifest_version":"coding.integration.v1",
                            "integration_id":"github.custom",
                            "provider":"github",
                            "status":"active",
                            "tool_pack":"coding.v1",
                            "capabilities":["get_issue","get_pull_request"]
                        }
                    }
                }"#,
            ))?;
        let store_tool_response = app.clone().oneshot(store_tool_request).await?;
        assert_eq!(store_tool_response.status(), StatusCode::CREATED);
        let store_tool_body = read_json(store_tool_response).await?;
        assert_eq!(store_tool_body["data"]["tool_id"], "github.custom");
        assert_eq!(store_tool_body["data"]["state"], "validated");

        let store_skill_request = Request::builder()
            .method("POST")
            .uri("/api/runtime/skills/skill-specs")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{
                    "state":"validated",
                    "skill_spec":{
                        "skill_id":"github-coding-custom",
                        "version":1,
                        "name":"GitHub Coding Custom",
                        "allowed_tools":[{"tool_id":"github.custom","version":1}],
                        "compatibility":{"runtime":"runtime"}
                    }
                }"#,
            ))?;
        let store_skill_response = app.clone().oneshot(store_skill_request).await?;
        assert_eq!(store_skill_response.status(), StatusCode::CREATED);
        let store_skill_body = read_json(store_skill_response).await?;
        assert_eq!(store_skill_body["data"]["skill_id"], "github-coding-custom");
        assert_eq!(store_skill_body["data"]["state"], "validated");

        let publish_request = Request::builder()
            .method("POST")
            .uri("/api/runtime/skills/skill-specs/github-coding-custom/1/publish")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let publish_response = app.clone().oneshot(publish_request).await?;
        assert_eq!(publish_response.status(), StatusCode::CREATED);
        let publish_body = read_json(publish_response).await?;
        assert_eq!(publish_body["data"]["skill_id"], "github-coding-custom");
        assert!(
            publish_body["data"]["bundle_hash"]
                .as_str()
                .unwrap_or_default()
                .len()
                == 64
        );

        let release_request = Request::builder()
            .method("GET")
            .uri("/api/runtime/skills/releases/github-coding-custom/1")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let release_response = app.oneshot(release_request).await?;
        assert_eq!(release_response.status(), StatusCode::OK);
        let release_body = read_json(release_response).await?;
        assert_eq!(
            release_body["data"]["bundle"]["bundle_format"],
            "agent_skills.v1"
        );

        Ok(())
    }

    #[tokio::test]
    async fn runtime_skill_registry_routes_validate_schema_and_state() -> Result<()> {
        let app = build_router(test_config(std::env::temp_dir()));
        let token =
            authenticate_token(app.clone(), "runtime-skills-invalid@openagents.com").await?;

        let invalid_state_request = Request::builder()
            .method("POST")
            .uri("/api/runtime/skills/tool-specs")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{
                    "state":"unsupported",
                    "tool_spec":{
                        "tool_id":"github.custom",
                        "version":1,
                        "tool_pack":"coding.v1"
                    }
                }"#,
            ))?;
        let invalid_state_response = app.clone().oneshot(invalid_state_request).await?;
        assert_eq!(
            invalid_state_response.status(),
            StatusCode::UNPROCESSABLE_ENTITY
        );
        let invalid_state_body = read_json(invalid_state_response).await?;
        assert_eq!(invalid_state_body["error"]["code"], "invalid_request");

        let missing_version_request = Request::builder()
            .method("POST")
            .uri("/api/runtime/skills/tool-specs")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{
                    "tool_spec":{
                        "tool_id":"github.custom",
                        "tool_pack":"coding.v1"
                    }
                }"#,
            ))?;
        let missing_version_response = app.oneshot(missing_version_request).await?;
        assert_eq!(
            missing_version_response.status(),
            StatusCode::UNPROCESSABLE_ENTITY
        );
        let missing_version_body = read_json(missing_version_response).await?;
        assert_eq!(missing_version_body["error"]["code"], "invalid_request");
        assert_eq!(
            missing_version_body["errors"]["tool_spec.version"],
            serde_json::json!(["The tool_spec.version field must be an integer."])
        );

        Ok(())
    }

    #[tokio::test]
    async fn auth_failure_paths_emit_failure_audit_events() -> Result<()> {
        let static_dir = tempdir()?;
        let sink = Arc::new(RecordingAuditSink::default());
        let app = build_router_with_observability(
            test_config(static_dir.path().to_path_buf()),
            Observability::new(sink.clone()),
        );

        let send_request = Request::builder()
            .method("POST")
            .uri("/api/auth/email")
            .header("x-request-id", "req-auth-send")
            .header("content-type", "application/json")
            .body(Body::from(r#"{"email":"failure-audit@openagents.com"}"#))?;
        let send_response = app.clone().oneshot(send_request).await?;
        assert_eq!(send_response.status(), StatusCode::OK);
        let cookie = cookie_value(&send_response).unwrap_or_default();

        let verify_request = Request::builder()
            .method("POST")
            .uri("/api/auth/verify")
            .header("x-request-id", "req-auth-verify-failed")
            .header("content-type", "application/json")
            .header("x-client", "autopilot-ios")
            .header("cookie", cookie)
            .body(Body::from(r#"{"code":"000000"}"#))?;
        let verify_response = app.clone().oneshot(verify_request).await?;
        assert_eq!(verify_response.status(), StatusCode::UNPROCESSABLE_ENTITY);

        let refresh_request = Request::builder()
            .method("POST")
            .uri("/api/auth/refresh")
            .header("x-request-id", "req-auth-refresh-failed")
            .header("content-type", "application/json")
            .body(Body::from(
                r#"{"refresh_token":"oa_rt_invalid","rotate_refresh_token":true}"#,
            ))?;
        let refresh_response = app.clone().oneshot(refresh_request).await?;
        assert_eq!(refresh_response.status(), StatusCode::UNAUTHORIZED);

        let valid_session_token =
            authenticate_token(app.clone(), "logout-failure@openagents.com").await?;
        let create_pat_request = Request::builder()
            .method("POST")
            .uri("/api/tokens")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {valid_session_token}"))
            .body(Body::from(r#"{"name":"logout-failure-pat"}"#))?;
        let create_pat_response = app.clone().oneshot(create_pat_request).await?;
        assert_eq!(create_pat_response.status(), StatusCode::CREATED);
        let create_pat_body = read_json(create_pat_response).await?;
        let pat_token = create_pat_body["data"]["token"]
            .as_str()
            .unwrap_or_default()
            .to_string();

        let logout_request = Request::builder()
            .method("POST")
            .uri("/api/auth/logout")
            .header("x-request-id", "req-auth-logout-failed")
            .header("authorization", format!("Bearer {pat_token}"))
            .body(Body::empty())?;
        let logout_response = app.oneshot(logout_request).await?;
        assert_eq!(logout_response.status(), StatusCode::UNAUTHORIZED);

        let events = sink.events();
        let verify_failed = events
            .iter()
            .find(|event| event.event_name == "auth.verify.failed")
            .expect("missing auth.verify.failed audit event");
        assert_eq!(verify_failed.request_id, "req-auth-verify-failed");
        assert_eq!(verify_failed.outcome, "failure");
        assert_eq!(
            verify_failed.attributes.get("reason").map(String::as_str),
            Some("invalid_request")
        );

        let refresh_failed = events
            .iter()
            .find(|event| event.event_name == "auth.refresh.failed")
            .expect("missing auth.refresh.failed audit event");
        assert_eq!(refresh_failed.request_id, "req-auth-refresh-failed");
        assert_eq!(refresh_failed.outcome, "failure");
        assert_eq!(
            refresh_failed.attributes.get("reason").map(String::as_str),
            Some("unauthorized")
        );

        let logout_failed = events
            .iter()
            .find(|event| event.event_name == "auth.logout.failed")
            .expect("missing auth.logout.failed audit event");
        assert_eq!(logout_failed.request_id, "req-auth-logout-failed");
        assert_eq!(logout_failed.outcome, "failure");
        assert_eq!(
            logout_failed.attributes.get("reason").map(String::as_str),
            Some("unauthorized")
        );

        Ok(())
    }

    #[tokio::test]
    async fn audit_events_include_request_correlation_and_identity_fields() -> Result<()> {
        let static_dir = tempdir()?;
        let sink = Arc::new(RecordingAuditSink::default());
        let app = build_router_with_observability(
            test_config(static_dir.path().to_path_buf()),
            Observability::new(sink.clone()),
        );

        let send_request = Request::builder()
            .method("POST")
            .uri("/api/auth/email")
            .header("x-request-id", "req-auth-email")
            .header("content-type", "application/json")
            .body(Body::from(r#"{"email":"audit@openagents.com"}"#))?;
        let send_response = app.clone().oneshot(send_request).await?;
        let cookie = cookie_value(&send_response).unwrap_or_default();

        let verify_request = Request::builder()
            .method("POST")
            .uri("/api/auth/verify")
            .header("x-request-id", "req-auth-verify")
            .header("content-type", "application/json")
            .header("x-client", "autopilot-ios")
            .header("cookie", cookie)
            .body(Body::from(r#"{"code":"123456"}"#))?;
        let verify_response = app.clone().oneshot(verify_request).await?;
        let verify_body = read_json(verify_response).await?;
        let token = verify_body["token"]
            .as_str()
            .unwrap_or_default()
            .to_string();

        let sync_request = Request::builder()
            .method("POST")
            .uri("/api/sync/token")
            .header("x-request-id", "req-sync-token")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(r#"{"scopes":["runtime.codex_worker_events"]}"#))?;
        let sync_response = app.oneshot(sync_request).await?;
        assert_eq!(sync_response.status(), StatusCode::OK);

        let events = sink.events();
        let verify_event = events
            .iter()
            .find(|event| event.event_name == "auth.verify.completed")
            .expect("missing auth.verify.completed event");
        assert_eq!(verify_event.request_id, "req-auth-verify");
        assert_eq!(verify_event.outcome, "success");
        assert!(verify_event.user_id.is_some());
        assert!(verify_event.session_id.is_some());
        assert!(verify_event.org_id.is_some());
        assert!(verify_event.device_id.is_some());

        let sync_event = events
            .iter()
            .find(|event| event.event_name == "sync.token.issued")
            .expect("missing sync.token.issued event");
        assert_eq!(sync_event.request_id, "req-sync-token");
        assert_eq!(sync_event.outcome, "success");
        assert!(sync_event.attributes.contains_key("scope_count"));
        assert!(sync_event.attributes.contains_key("topic_count"));
        assert!(sync_event.attributes.contains_key("expires_in"));

        Ok(())
    }

    #[tokio::test]
    async fn route_split_serves_rust_shell_and_audits_decision() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;

        let sink = Arc::new(RecordingAuditSink::default());
        let app = build_router_with_observability(
            test_config(static_dir.path().to_path_buf()),
            Observability::new(sink.clone()),
        );

        let request = Request::builder()
            .uri("/chat/thread-1")
            .header("x-request-id", "req-route-split")
            .header("x-oa-route-key", "user:route")
            .header("user-agent", "autopilot-ios")
            .body(Body::empty())?;
        let response = app.oneshot(request).await?;
        assert_eq!(response.status(), StatusCode::OK);

        let body = response.into_body().collect().await?.to_bytes();
        let html = String::from_utf8_lossy(&body);
        assert!(html.contains("rust shell"));

        let events = sink.events();
        let decision_event = events
            .iter()
            .find(|event| event.event_name == "route.split.decision")
            .expect("missing route.split.decision audit event");
        assert_eq!(decision_event.request_id, "req-route-split");
        assert_eq!(
            decision_event
                .attributes
                .get("target")
                .map(String::as_str)
                .unwrap_or_default(),
            "rust_shell"
        );

        Ok(())
    }

    #[tokio::test]
    async fn route_split_serves_management_route_prefixes_in_rust_cohort() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let app = build_router(test_config(static_dir.path().to_path_buf()));

        for path in [
            "/account/session",
            "/settings/profile",
            "/l402/paywalls",
            "/billing/deployments",
            "/admin",
        ] {
            let request = Request::builder()
                .uri(path)
                .header("x-oa-route-key", "user:route")
                .body(Body::empty())?;
            let response = app.clone().oneshot(request).await?;
            if [
                "/settings/profile",
                "/l402/paywalls",
                "/billing/deployments",
                "/admin",
            ]
            .contains(&path)
            {
                assert_eq!(
                    response.status(),
                    StatusCode::TEMPORARY_REDIRECT,
                    "unexpected status for {path}"
                );
                assert_eq!(
                    response
                        .headers()
                        .get("location")
                        .and_then(|value| value.to_str().ok()),
                    Some("/login"),
                    "management route should remain rust-owned auth redirect: {path}"
                );
            } else {
                assert_eq!(
                    response.status(),
                    StatusCode::OK,
                    "unexpected status for {path}"
                );
                let body = response.into_body().collect().await?.to_bytes();
                let html = String::from_utf8_lossy(&body);
                assert!(
                    html.contains("rust shell"),
                    "management route was not served by rust shell: {path}"
                );
            }
        }

        Ok(())
    }

    #[tokio::test]
    async fn route_split_serves_auth_entry_routes_in_rust_cohort() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let app = build_router(test_config(static_dir.path().to_path_buf()));

        for path in [
            "/login",
            "/register",
            "/authenticate",
            "/onboarding/checklist",
        ] {
            let request = Request::builder()
                .uri(path)
                .header("x-oa-route-key", "user:route")
                .body(Body::empty())?;
            let response = app.clone().oneshot(request).await?;
            assert_eq!(
                response.status(),
                StatusCode::OK,
                "unexpected status for {path}"
            );
            let body = response.into_body().collect().await?.to_bytes();
            let html = String::from_utf8_lossy(&body);
            assert!(
                html.contains("rust shell"),
                "auth route was not served by rust shell: {path}"
            );
        }

        Ok(())
    }

    #[tokio::test]
    async fn route_split_rust_mode_with_root_prefix_serves_unlisted_paths() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;

        let mut config = test_config(static_dir.path().to_path_buf());
        config.route_split_mode = "rust".to_string();
        config.route_split_rust_routes = vec!["/".to_string()];
        let app = build_router(config);

        for path in ["/feed", "/new-surface/path", "/login"] {
            let request = Request::builder()
                .uri(path)
                .header("x-oa-route-key", "user:route")
                .body(Body::empty())?;
            let response = app.clone().oneshot(request).await?;
            assert_eq!(
                response.status(),
                StatusCode::OK,
                "unexpected status for {path}"
            );
            let body = response.into_body().collect().await?.to_bytes();
            let html = String::from_utf8_lossy(&body);
            assert!(
                html.contains("rust shell"),
                "path was not served by rust shell: {path}"
            );
        }

        Ok(())
    }

    #[tokio::test]
    async fn route_split_override_keeps_chat_pilot_on_rust_shell() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let app = build_router(test_config(static_dir.path().to_path_buf()));

        let send_request = Request::builder()
            .method("POST")
            .uri("/api/auth/email")
            .header("content-type", "application/json")
            .body(Body::from(r#"{"email":"routes@openagents.com"}"#))?;
        let send_response = app.clone().oneshot(send_request).await?;
        let cookie = cookie_value(&send_response).unwrap_or_default();

        let verify_request = Request::builder()
            .method("POST")
            .uri("/api/auth/verify")
            .header("content-type", "application/json")
            .header("x-client", "autopilot-ios")
            .header("cookie", cookie)
            .body(Body::from(r#"{"code":"123456"}"#))?;
        let verify_response = app.clone().oneshot(verify_request).await?;
        let verify_body = read_json(verify_response).await?;
        let token = verify_body["token"]
            .as_str()
            .unwrap_or_default()
            .to_string();

        let override_request = Request::builder()
            .method("POST")
            .uri("/api/v1/control/route-split/override")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(r#"{"target":"legacy"}"#))?;
        let override_response = app.clone().oneshot(override_request).await?;
        assert_eq!(override_response.status(), StatusCode::OK);

        let route_request = Request::builder()
            .uri("/chat/thread-1")
            .header("x-oa-route-key", "user:route")
            .body(Body::empty())?;
        let route_response = app.clone().oneshot(route_request).await?;
        assert_eq!(route_response.status(), StatusCode::OK);
        let route_body = route_response.into_body().collect().await?.to_bytes();
        let route_html = String::from_utf8_lossy(&route_body);
        assert!(route_html.contains("rust shell"));

        let root_request = Request::builder()
            .uri("/")
            .header("x-oa-route-key", "user:route")
            .body(Body::empty())?;
        let root_response = app.clone().oneshot(root_request).await?;
        assert_eq!(root_response.status(), StatusCode::OK);
        let root_body = root_response.into_body().collect().await?.to_bytes();
        let root_html = String::from_utf8_lossy(&root_body);
        assert!(root_html.contains("rust shell"));

        let workspace_request = Request::builder()
            .uri("/workspace/session-1")
            .header("x-oa-route-key", "user:route")
            .body(Body::empty())?;
        let workspace_response = app.oneshot(workspace_request).await?;
        assert_eq!(workspace_response.status(), StatusCode::TEMPORARY_REDIRECT);
        assert_eq!(
            workspace_response
                .headers()
                .get("location")
                .and_then(|value| value.to_str().ok()),
            Some("https://legacy.openagents.test/workspace/session-1")
        );

        Ok(())
    }

    #[tokio::test]
    async fn retired_aui_route_returns_not_found() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let app = build_router(test_config(static_dir.path().to_path_buf()));

        let request = Request::builder().uri("/aui").body(Body::empty())?;
        let response = app.oneshot(request).await?;
        assert_eq!(response.status(), StatusCode::NOT_FOUND);

        Ok(())
    }

    #[tokio::test]
    async fn route_split_domain_override_only_affects_selected_route_group() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.route_split_mode = "rust".to_string();
        config.route_split_rust_routes = vec!["/".to_string()];
        let app = build_router(config);
        let token = authenticate_token(app.clone(), "routes@openagents.com").await?;

        let override_request = Request::builder()
            .method("POST")
            .uri("/api/v1/control/route-split/override")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(r#"{"target":"legacy","domain":"billing_l402"}"#))?;
        let override_response = app.clone().oneshot(override_request).await?;
        assert_eq!(override_response.status(), StatusCode::OK);

        let billing_request = Request::builder()
            .uri("/l402/paywalls")
            .header("x-oa-route-key", "user:route")
            .body(Body::empty())?;
        let billing_response = app.clone().oneshot(billing_request).await?;
        assert_eq!(billing_response.status(), StatusCode::TEMPORARY_REDIRECT);
        assert_eq!(
            billing_response
                .headers()
                .get("location")
                .and_then(|value| value.to_str().ok()),
            Some("https://legacy.openagents.test/l402/paywalls")
        );

        let settings_request = Request::builder()
            .uri("/settings/profile")
            .header("x-oa-route-key", "user:route")
            .body(Body::empty())?;
        let settings_response = app.oneshot(settings_request).await?;
        assert_eq!(settings_response.status(), StatusCode::TEMPORARY_REDIRECT);
        assert_eq!(
            settings_response
                .headers()
                .get("location")
                .and_then(|value| value.to_str().ok()),
            Some("/login")
        );

        Ok(())
    }

    #[tokio::test]
    async fn route_split_status_exposes_rollback_matrix_and_domain_overrides() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.route_split_mode = "rust".to_string();
        config.route_split_rust_routes = vec!["/".to_string()];
        let app = build_router(config);
        let token = authenticate_token(app.clone(), "routes@openagents.com").await?;

        let override_request = Request::builder()
            .method("POST")
            .uri("/api/v1/control/route-split/override")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"target":"rollback","domain":"billing_l402"}"#,
            ))?;
        let override_response = app.clone().oneshot(override_request).await?;
        assert_eq!(override_response.status(), StatusCode::OK);

        let htmx_override_request = Request::builder()
            .method("POST")
            .uri("/api/v1/control/route-split/override")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"target":"htmx_full_page","domain":"billing_l402"}"#,
            ))?;
        let htmx_override_response = app.clone().oneshot(htmx_override_request).await?;
        assert_eq!(htmx_override_response.status(), StatusCode::OK);

        let status_request = Request::builder()
            .method("GET")
            .uri("/api/v1/control/route-split/status")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let status_response = app.oneshot(status_request).await?;
        assert_eq!(status_response.status(), StatusCode::OK);

        let body = read_json(status_response).await?;
        assert_eq!(
            body["data"]["rollback_matrix"]["billing_l402"],
            json!("legacy")
        );
        assert_eq!(
            body["data"]["rollback_matrix"]["chat_pilot"],
            json!("rust_shell")
        );
        assert_eq!(
            body["data"]["domain_overrides"]["billing_l402"],
            json!("legacy")
        );
        assert_eq!(
            body["data"]["htmx_rollback_matrix"]["billing_l402"],
            json!("full_page")
        );
        assert_eq!(
            body["data"]["htmx_domain_overrides"]["billing_l402"],
            json!("full_page")
        );

        Ok(())
    }

    #[tokio::test]
    async fn route_split_evaluate_pins_api_paths_to_rust_authority() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.route_split_mode = "legacy".to_string();
        config.route_split_force_legacy = true;
        let app = build_router(config);
        let token = authenticate_token(app.clone(), "routes@openagents.com").await?;

        let override_request = Request::builder()
            .method("POST")
            .uri("/api/v1/control/route-split/override")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(r#"{"target":"legacy"}"#))?;
        let override_response = app.clone().oneshot(override_request).await?;
        assert_eq!(override_response.status(), StatusCode::OK);

        let evaluate_request = Request::builder()
            .method("POST")
            .uri("/api/v1/control/route-split/evaluate")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"path":"/api/auth/email","cohort_key":"user:route"}"#,
            ))?;
        let evaluate_response = app.oneshot(evaluate_request).await?;
        assert_eq!(evaluate_response.status(), StatusCode::OK);

        let body = read_json(evaluate_response).await?;
        assert_eq!(body["data"]["target"], json!("rust_shell"));
        assert_eq!(body["data"]["reason"], json!("api_rust_authority"));
        assert_eq!(body["data"]["route_domain"], json!("api_rust_authority"));
        assert_eq!(body["data"]["rollback_target"], json!("rust_shell"));

        Ok(())
    }

    #[tokio::test]
    async fn l402_read_routes_match_wallet_transactions_and_deployments_shape() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));

        let fixture = seed_l402_fixture(&config, "l402-reader@openagents.com").await?;
        let app = build_router(config);

        let wallet_request = Request::builder()
            .method("GET")
            .uri(format!(
                "/api/l402/wallet?autopilot={}",
                fixture.autopilot_handle
            ))
            .header("authorization", format!("Bearer {}", fixture.token))
            .body(Body::empty())?;
        let wallet_response = app.clone().oneshot(wallet_request).await?;
        assert_eq!(wallet_response.status(), StatusCode::OK);
        let wallet_body = read_json(wallet_response).await?;
        assert_eq!(wallet_body["data"]["summary"]["totalAttempts"], json!(2));
        assert_eq!(wallet_body["data"]["summary"]["paidCount"], json!(1));
        assert_eq!(wallet_body["data"]["summary"]["cachedCount"], json!(1));
        assert_eq!(wallet_body["data"]["summary"]["blockedCount"], json!(0));
        assert_eq!(
            wallet_body["data"]["sparkWallet"]["walletId"],
            json!("wallet_123")
        );
        assert_eq!(
            wallet_body["data"]["settings"]["invoicePayer"],
            json!("fake")
        );
        assert_eq!(
            wallet_body["data"]["settings"]["allowlistHosts"],
            json!(vec!["sats4ai.com", "l402.openagents.com"])
        );
        assert_eq!(
            wallet_body["data"]["settings"]["credentialTtlSeconds"],
            json!(600)
        );
        assert_eq!(
            wallet_body["data"]["settings"]["paymentTimeoutMs"],
            json!(12_000)
        );
        assert_eq!(
            wallet_body["data"]["filter"]["autopilot"]["id"],
            json!(fixture.autopilot_id.clone())
        );

        let transactions_request = Request::builder()
            .method("GET")
            .uri(format!(
                "/api/l402/transactions?autopilot={}&per_page=1&page=2",
                fixture.autopilot_id
            ))
            .header("authorization", format!("Bearer {}", fixture.token))
            .body(Body::empty())?;
        let transactions_response = app.clone().oneshot(transactions_request).await?;
        assert_eq!(transactions_response.status(), StatusCode::OK);
        let transactions_body = read_json(transactions_response).await?;
        assert_eq!(
            transactions_body["data"]["transactions"]
                .as_array()
                .map(|rows| rows.len()),
            Some(1)
        );
        assert_eq!(
            transactions_body["data"]["pagination"]["currentPage"],
            json!(2)
        );
        assert_eq!(
            transactions_body["data"]["pagination"]["lastPage"],
            json!(2)
        );
        assert_eq!(
            transactions_body["data"]["pagination"]["hasMorePages"],
            json!(false)
        );

        let transaction_show_request = Request::builder()
            .method("GET")
            .uri(format!(
                "/api/l402/transactions/{}",
                fixture.paid_receipt_event_id
            ))
            .header("authorization", format!("Bearer {}", fixture.token))
            .body(Body::empty())?;
        let transaction_show_response = app.clone().oneshot(transaction_show_request).await?;
        assert_eq!(transaction_show_response.status(), StatusCode::OK);
        let transaction_show_body = read_json(transaction_show_response).await?;
        assert_eq!(
            transaction_show_body["data"]["transaction"]["eventId"],
            json!(fixture.paid_receipt_event_id)
        );
        assert_eq!(
            transaction_show_body["data"]["transaction"]["status"],
            json!("paid")
        );

        let paywalls_request = Request::builder()
            .method("GET")
            .uri("/api/l402/paywalls")
            .header("authorization", format!("Bearer {}", fixture.token))
            .body(Body::empty())?;
        let paywalls_response = app.clone().oneshot(paywalls_request).await?;
        assert_eq!(paywalls_response.status(), StatusCode::OK);
        let paywalls_body = read_json(paywalls_response).await?;
        assert_eq!(paywalls_body["data"]["summary"]["uniqueTargets"], json!(2));
        assert_eq!(paywalls_body["data"]["summary"]["totalAttempts"], json!(3));
        assert_eq!(paywalls_body["data"]["summary"]["totalPaidCount"], json!(1));

        let settlements_request = Request::builder()
            .method("GET")
            .uri(format!(
                "/api/l402/settlements?autopilot={}",
                fixture.autopilot_id
            ))
            .header("authorization", format!("Bearer {}", fixture.token))
            .body(Body::empty())?;
        let settlements_response = app.clone().oneshot(settlements_request).await?;
        assert_eq!(settlements_response.status(), StatusCode::OK);
        let settlements_body = read_json(settlements_response).await?;
        assert_eq!(
            settlements_body["data"]["summary"]["settledCount"],
            json!(1)
        );
        assert_eq!(
            settlements_body["data"]["summary"]["totalMsats"],
            json!(2100)
        );

        let deployments_request = Request::builder()
            .method("GET")
            .uri(format!(
                "/api/l402/deployments?autopilot={}",
                fixture.autopilot_id
            ))
            .header("authorization", format!("Bearer {}", fixture.token))
            .body(Body::empty())?;
        let deployments_response = app.oneshot(deployments_request).await?;
        assert_eq!(deployments_response.status(), StatusCode::OK);
        let deployments_body = read_json(deployments_response).await?;
        assert_eq!(
            deployments_body["data"]["deployments"]
                .as_array()
                .map(|rows| rows.len()),
            Some(1)
        );
        assert_eq!(
            deployments_body["data"]["deployments"][0]["type"],
            json!("l402_gateway_event")
        );
        assert_eq!(
            deployments_body["data"]["configSnapshot"]["invoicePayer"],
            json!("fake")
        );
        assert_eq!(
            deployments_body["data"]["configSnapshot"]["allowlistHosts"],
            json!(vec!["sats4ai.com", "l402.openagents.com"])
        );
        assert_eq!(
            deployments_body["data"]["configSnapshot"]["demoPresets"],
            json!(vec![
                "sats4ai",
                "ep212_openagents_premium",
                "ep212_openagents_expensive",
                "fake"
            ])
        );

        Ok(())
    }

    #[tokio::test]
    async fn l402_transaction_show_returns_not_found_for_missing_event() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));

        let fixture = seed_l402_fixture(&config, "l402-detail-missing@openagents.com").await?;
        let app = build_router(config);

        let request = Request::builder()
            .method("GET")
            .uri("/api/l402/transactions/999999")
            .header("authorization", format!("Bearer {}", fixture.token))
            .body(Body::empty())?;
        let response = app.oneshot(request).await?;
        assert_eq!(response.status(), StatusCode::NOT_FOUND);
        let body = read_json(response).await?;
        assert_eq!(body["error"]["code"], json!("not_found"));

        Ok(())
    }

    #[tokio::test]
    async fn l402_autopilot_filter_returns_not_found_and_forbidden() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));

        let fixture = seed_l402_fixture(&config, "l402-access@openagents.com").await?;

        let foreign_auth = super::AuthService::from_config(&config);
        let foreign_verify = foreign_auth
            .local_test_sign_in(
                "l402-foreign@openagents.com".to_string(),
                None,
                Some("autopilot-ios"),
                None,
            )
            .await?;
        let store = super::DomainStore::from_config(&config);
        let foreign_autopilot = store
            .create_autopilot(CreateAutopilotInput {
                owner_user_id: foreign_verify.user.id,
                owner_display_name: "Other".to_string(),
                display_name: "Foreign Pilot".to_string(),
                handle_seed: None,
                avatar: None,
                status: None,
                visibility: None,
                tagline: None,
            })
            .await
            .expect("seed foreign autopilot");

        let app = build_router(config);

        let missing_request = Request::builder()
            .method("GET")
            .uri("/api/l402/wallet?autopilot=missing-pilot")
            .header("authorization", format!("Bearer {}", fixture.token))
            .body(Body::empty())?;
        let missing_response = app.clone().oneshot(missing_request).await?;
        assert_eq!(missing_response.status(), StatusCode::NOT_FOUND);
        let missing_body = read_json(missing_response).await?;
        assert_eq!(missing_body["message"], json!("autopilot_not_found"));

        let forbidden_request = Request::builder()
            .method("GET")
            .uri(format!(
                "/api/l402/wallet?autopilot={}",
                foreign_autopilot.autopilot.id
            ))
            .header("authorization", format!("Bearer {}", fixture.token))
            .body(Body::empty())?;
        let forbidden_response = app.oneshot(forbidden_request).await?;
        assert_eq!(forbidden_response.status(), StatusCode::FORBIDDEN);
        let forbidden_body = read_json(forbidden_response).await?;
        assert_eq!(forbidden_body["message"], json!("autopilot_forbidden"));

        Ok(())
    }

    #[tokio::test]
    async fn l402_paywall_lifecycle_requires_admin_and_records_mutation_events() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));

        let admin_token = seed_local_test_token(&config, "routes@openagents.com").await?;
        let member_token = seed_local_test_token(&config, "member@openagents.com").await?;
        let app = build_router(config);

        let forbidden_request = Request::builder()
            .method("POST")
            .uri("/api/l402/paywalls")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {member_token}"))
            .body(Body::from(
                r#"{
                    "name":"Default",
                    "hostRegexp":"sats4ai\\.com",
                    "pathRegexp":"^/api/.*",
                    "priceMsats":1000,
                    "upstream":"https://upstream.openagents.com",
                    "enabled":true
                }"#,
            ))?;
        let forbidden_response = app.clone().oneshot(forbidden_request).await?;
        assert_eq!(forbidden_response.status(), StatusCode::FORBIDDEN);

        let invalid_request = Request::builder()
            .method("POST")
            .uri("/api/l402/paywalls")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {admin_token}"))
            .body(Body::from(
                r#"{
                    "name":"Invalid",
                    "hostRegexp":"sats4ai\\.com",
                    "pathRegexp":"/api/.*",
                    "priceMsats":1000,
                    "upstream":"https://upstream.openagents.com"
                }"#,
            ))?;
        let invalid_response = app.clone().oneshot(invalid_request).await?;
        assert_eq!(invalid_response.status(), StatusCode::UNPROCESSABLE_ENTITY);

        let create_request = Request::builder()
            .method("POST")
            .uri("/api/l402/paywalls")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {admin_token}"))
            .body(Body::from(
                r#"{
                    "name":"Default",
                    "hostRegexp":"sats4ai\\.com",
                    "pathRegexp":"^/api/.*",
                    "priceMsats":1000,
                    "upstream":"https://upstream.openagents.com",
                    "enabled":true,
                    "metadata":{"tier":"default"}
                }"#,
            ))?;
        let create_response = app.clone().oneshot(create_request).await?;
        assert_eq!(create_response.status(), StatusCode::CREATED);
        let create_body = read_json(create_response).await?;
        let paywall_id = create_body["data"]["paywall"]["id"]
            .as_str()
            .unwrap_or_default()
            .to_string();
        assert!(!paywall_id.is_empty());
        assert_eq!(create_body["data"]["paywall"]["name"], json!("Default"));
        assert_eq!(
            create_body["data"]["deployment"]["status"],
            json!("applied")
        );
        assert!(create_body["data"]["mutationEventId"].as_u64().unwrap_or(0) > 0);

        let empty_update_request = Request::builder()
            .method("PATCH")
            .uri(format!("/api/l402/paywalls/{paywall_id}"))
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {admin_token}"))
            .body(Body::from("{}"))?;
        let empty_update_response = app.clone().oneshot(empty_update_request).await?;
        assert_eq!(
            empty_update_response.status(),
            StatusCode::UNPROCESSABLE_ENTITY
        );
        let empty_update_body = read_json(empty_update_response).await?;
        assert_eq!(
            empty_update_body["message"],
            json!("At least one mutable paywall field must be provided.")
        );

        let update_request = Request::builder()
            .method("PATCH")
            .uri(format!("/api/l402/paywalls/{paywall_id}"))
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {admin_token}"))
            .body(Body::from(
                r#"{
                    "priceMsats":2500,
                    "enabled":false,
                    "metadata":{"tier":"burst"}
                }"#,
            ))?;
        let update_response = app.clone().oneshot(update_request).await?;
        assert_eq!(update_response.status(), StatusCode::OK);
        let update_body = read_json(update_response).await?;
        assert_eq!(update_body["data"]["paywall"]["priceMsats"], json!(2500));
        assert_eq!(update_body["data"]["paywall"]["enabled"], json!(false));
        assert_eq!(
            update_body["data"]["deployment"]["eventType"],
            json!("l402_paywall_updated")
        );

        let delete_request = Request::builder()
            .method("DELETE")
            .uri(format!("/api/l402/paywalls/{paywall_id}"))
            .header("authorization", format!("Bearer {admin_token}"))
            .body(Body::empty())?;
        let delete_response = app.clone().oneshot(delete_request).await?;
        assert_eq!(delete_response.status(), StatusCode::OK);
        let delete_body = read_json(delete_response).await?;
        assert_eq!(delete_body["data"]["deleted"], json!(true));
        assert_eq!(
            delete_body["data"]["deployment"]["eventType"],
            json!("l402_paywall_deleted")
        );

        let deployments_request = Request::builder()
            .method("GET")
            .uri("/api/l402/deployments")
            .header("authorization", format!("Bearer {admin_token}"))
            .body(Body::empty())?;
        let deployments_response = app.oneshot(deployments_request).await?;
        assert_eq!(deployments_response.status(), StatusCode::OK);
        let deployments_body = read_json(deployments_response).await?;
        let deployment_types = deployments_body["data"]["deployments"]
            .as_array()
            .cloned()
            .unwrap_or_default()
            .into_iter()
            .filter_map(|event| event["type"].as_str().map(ToString::to_string))
            .collect::<Vec<_>>();
        assert!(deployment_types.contains(&"l402_paywall_created".to_string()));
        assert!(deployment_types.contains(&"l402_paywall_updated".to_string()));
        assert!(deployment_types.contains(&"l402_paywall_deleted".to_string()));

        Ok(())
    }

    #[tokio::test]
    async fn lightning_ops_control_plane_query_and_mutation_contracts() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;

        let mut config = test_config(static_dir.path().to_path_buf());
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));
        let store = DomainStore::from_config(&config);
        let owner_user_id = "usr_ops".to_string();

        let active_paywall = store
            .create_l402_paywall(CreateL402PaywallInput {
                owner_user_id: owner_user_id.clone(),
                name: "Ops Active".to_string(),
                host_regexp: "sats4ai\\.com".to_string(),
                path_regexp: "^/v1/.*".to_string(),
                price_msats: 1200,
                upstream: "https://upstream.openagents.com".to_string(),
                enabled: Some(true),
                meta: Some(json!({
                    "timeoutMs": 3000,
                    "priority": 5,
                    "allowedHosts": ["sats4ai.com"],
                })),
            })
            .await
            .expect("create active paywall");

        let _paused_paywall = store
            .create_l402_paywall(CreateL402PaywallInput {
                owner_user_id: owner_user_id.clone(),
                name: "Ops Paused".to_string(),
                host_regexp: "api\\.openagents\\.com".to_string(),
                path_regexp: "^/ops/.*".to_string(),
                price_msats: 3000,
                upstream: "http://localhost:8080".to_string(),
                enabled: Some(false),
                meta: None,
            })
            .await
            .expect("create paused paywall");

        let archived_paywall = store
            .create_l402_paywall(CreateL402PaywallInput {
                owner_user_id: owner_user_id.clone(),
                name: "Ops Archived".to_string(),
                host_regexp: "archive\\.example\\.com".to_string(),
                path_regexp: "^/archive/.*".to_string(),
                price_msats: 5000,
                upstream: "https://archive.openagents.com".to_string(),
                enabled: Some(true),
                meta: None,
            })
            .await
            .expect("create archived paywall");
        let _ = store
            .soft_delete_owned_l402_paywall(&owner_user_id, &archived_paywall.id)
            .await
            .expect("archive paywall");

        let app = build_router(config);

        let bad_secret_request = Request::builder()
            .method("POST")
            .uri("/api/internal/lightning-ops/control-plane/query")
            .header("content-type", "application/json")
            .body(Body::from(
                json!({
                    "functionName": "lightning/ops:listPaywallControlPlaneState",
                    "args": {
                        "secret": "nope"
                    }
                })
                .to_string(),
            ))?;
        let bad_secret_response = app.clone().oneshot(bad_secret_request).await?;
        assert_eq!(bad_secret_response.status(), StatusCode::UNAUTHORIZED);
        let bad_secret_body = read_json(bad_secret_response).await?;
        assert_eq!(
            bad_secret_body["error"]["code"],
            json!("invalid_ops_secret")
        );

        let query_request = Request::builder()
            .method("POST")
            .uri("/api/internal/lightning-ops/control-plane/query")
            .header("content-type", "application/json")
            .body(Body::from(
                json!({
                    "functionName": "lightning/ops:listPaywallControlPlaneState",
                    "args": {
                        "secret": "ops-secret-test"
                    }
                })
                .to_string(),
            ))?;
        let query_response = app.clone().oneshot(query_request).await?;
        assert_eq!(query_response.status(), StatusCode::OK);
        let query_body = read_json(query_response).await?;
        assert_eq!(query_body["ok"], json!(true));
        let paywalls = query_body["paywalls"]
            .as_array()
            .cloned()
            .unwrap_or_default();
        assert_eq!(paywalls.len(), 2);
        let statuses = paywalls
            .iter()
            .filter_map(|row| row["status"].as_str().map(ToString::to_string))
            .collect::<Vec<_>>();
        assert!(statuses.contains(&"active".to_string()));
        assert!(statuses.contains(&"paused".to_string()));
        assert_eq!(paywalls[0]["routes"][0]["timeoutMs"], json!(3000));
        assert_eq!(paywalls[0]["routes"][0]["priority"], json!(5));

        let security_before_request = Request::builder()
            .method("POST")
            .uri("/api/internal/lightning-ops/control-plane/query")
            .header("content-type", "application/json")
            .body(Body::from(
                json!({
                    "functionName": "lightning/security:getControlPlaneSecurityState",
                    "args": {
                        "secret": "ops-secret-test"
                    }
                })
                .to_string(),
            ))?;
        let security_before_response = app.clone().oneshot(security_before_request).await?;
        assert_eq!(security_before_response.status(), StatusCode::OK);
        let security_before_body = read_json(security_before_response).await?;
        assert_eq!(security_before_body["global"]["globalPause"], json!(false));
        assert_eq!(security_before_body["ownerControls"], json!([]));
        assert_eq!(security_before_body["credentialRoles"], json!([]));

        let global_pause_request = Request::builder()
            .method("POST")
            .uri("/api/internal/lightning-ops/control-plane/mutation")
            .header("content-type", "application/json")
            .body(Body::from(
                json!({
                    "functionName": "lightning/security:setGlobalPause",
                    "args": {
                        "secret": "ops-secret-test",
                        "active": true,
                        "reason": "Emergency pause",
                        "updatedBy": "ops@openagents.com"
                    }
                })
                .to_string(),
            ))?;
        let global_pause_response = app.clone().oneshot(global_pause_request).await?;
        assert_eq!(global_pause_response.status(), StatusCode::OK);
        let global_pause_body = read_json(global_pause_response).await?;
        assert_eq!(global_pause_body["global"]["globalPause"], json!(true));
        assert_eq!(
            global_pause_body["global"]["denyReasonCode"],
            json!("global_pause_active")
        );

        let owner_kill_switch_request = Request::builder()
            .method("POST")
            .uri("/api/internal/lightning-ops/control-plane/mutation")
            .header("content-type", "application/json")
            .body(Body::from(
                json!({
                    "functionName": "lightning/security:setOwnerKillSwitch",
                    "args": {
                        "secret": "ops-secret-test",
                        "ownerId": "owner_usr_ops",
                        "active": true,
                        "reason": "Owner pause",
                        "updatedBy": "ops@openagents.com"
                    }
                })
                .to_string(),
            ))?;
        let owner_kill_switch_response = app.clone().oneshot(owner_kill_switch_request).await?;
        assert_eq!(owner_kill_switch_response.status(), StatusCode::OK);
        let owner_kill_switch_body = read_json(owner_kill_switch_response).await?;
        assert_eq!(
            owner_kill_switch_body["ownerControl"]["ownerId"],
            json!("owner_usr_ops")
        );
        assert_eq!(
            owner_kill_switch_body["ownerControl"]["killSwitch"],
            json!(true)
        );

        let role_rotate_request = Request::builder()
            .method("POST")
            .uri("/api/internal/lightning-ops/control-plane/mutation")
            .header("content-type", "application/json")
            .body(Body::from(
                json!({
                    "functionName": "lightning/security:rotateCredentialRole",
                    "args": {
                        "secret": "ops-secret-test",
                        "role": "gateway_signer",
                        "fingerprint": "fingerprint_v1",
                        "note": "rotation start"
                    }
                })
                .to_string(),
            ))?;
        let role_rotate_response = app.clone().oneshot(role_rotate_request).await?;
        assert_eq!(role_rotate_response.status(), StatusCode::OK);
        let role_rotate_body = read_json(role_rotate_response).await?;
        assert_eq!(role_rotate_body["role"]["status"], json!("rotating"));
        assert_eq!(role_rotate_body["role"]["version"], json!(1));

        let role_activate_request = Request::builder()
            .method("POST")
            .uri("/api/internal/lightning-ops/control-plane/mutation")
            .header("content-type", "application/json")
            .body(Body::from(
                json!({
                    "functionName": "lightning/security:activateCredentialRole",
                    "args": {
                        "secret": "ops-secret-test",
                        "role": "gateway_signer",
                        "fingerprint": "fingerprint_v1"
                    }
                })
                .to_string(),
            ))?;
        let role_activate_response = app.clone().oneshot(role_activate_request).await?;
        assert_eq!(role_activate_response.status(), StatusCode::OK);
        let role_activate_body = read_json(role_activate_response).await?;
        assert_eq!(role_activate_body["role"]["status"], json!("active"));
        assert_eq!(role_activate_body["role"]["version"], json!(1));

        let role_revoke_request = Request::builder()
            .method("POST")
            .uri("/api/internal/lightning-ops/control-plane/mutation")
            .header("content-type", "application/json")
            .body(Body::from(
                json!({
                    "functionName": "lightning/security:revokeCredentialRole",
                    "args": {
                        "secret": "ops-secret-test",
                        "role": "gateway_signer",
                        "note": "revoke key"
                    }
                })
                .to_string(),
            ))?;
        let role_revoke_response = app.clone().oneshot(role_revoke_request).await?;
        assert_eq!(role_revoke_response.status(), StatusCode::OK);
        let role_revoke_body = read_json(role_revoke_response).await?;
        assert_eq!(role_revoke_body["role"]["status"], json!("revoked"));
        assert_eq!(role_revoke_body["role"]["version"], json!(1));

        let security_after_request = Request::builder()
            .method("POST")
            .uri("/api/internal/lightning-ops/control-plane/query")
            .header("content-type", "application/json")
            .body(Body::from(
                json!({
                    "functionName": "lightning/security:getControlPlaneSecurityState",
                    "args": {
                        "secret": "ops-secret-test"
                    }
                })
                .to_string(),
            ))?;
        let security_after_response = app.clone().oneshot(security_after_request).await?;
        assert_eq!(security_after_response.status(), StatusCode::OK);
        let security_after_body = read_json(security_after_response).await?;
        assert_eq!(security_after_body["global"]["globalPause"], json!(true));
        assert_eq!(
            security_after_body["ownerControls"]
                .as_array()
                .map(|rows| rows.len()),
            Some(1)
        );
        assert_eq!(
            security_after_body["credentialRoles"]
                .as_array()
                .map(|rows| rows.len()),
            Some(1)
        );

        let compile_intent_request = Request::builder()
            .method("POST")
            .uri("/api/internal/lightning-ops/control-plane/mutation")
            .header("content-type", "application/json")
            .body(Body::from(
                json!({
                    "functionName": "lightning/ops:recordGatewayCompileIntent",
                    "args": {
                        "secret": "ops-secret-test",
                        "paywallId": active_paywall.id,
                        "ownerId": "owner_usr_ops",
                        "configHash": "cfg_hash_1",
                        "imageDigest": "sha256:abc",
                        "status": "queued",
                        "diagnostics": {"queue":"ready"},
                        "metadata": {"region":"us-central1"},
                        "requestId": "req_1",
                        "appliedAtMs": 12345
                    }
                })
                .to_string(),
            ))?;
        let compile_intent_response = app.clone().oneshot(compile_intent_request).await?;
        assert_eq!(compile_intent_response.status(), StatusCode::OK);
        let compile_intent_body = read_json(compile_intent_response).await?;
        assert_eq!(compile_intent_body["deployment"]["status"], json!("queued"));
        let deployment_id = compile_intent_body["deployment"]["deploymentId"]
            .as_str()
            .unwrap_or_default()
            .to_string();
        assert!(!deployment_id.is_empty());

        let compile_intent_update_request = Request::builder()
            .method("POST")
            .uri("/api/internal/lightning-ops/control-plane/mutation")
            .header("content-type", "application/json")
            .body(Body::from(
                json!({
                    "functionName": "lightning/ops:recordGatewayCompileIntent",
                    "args": {
                        "secret": "ops-secret-test",
                        "deploymentId": deployment_id,
                        "paywallId": active_paywall.id,
                        "ownerId": "owner_usr_ops",
                        "configHash": "cfg_hash_2",
                        "status": "applied"
                    }
                })
                .to_string(),
            ))?;
        let compile_intent_update_response =
            app.clone().oneshot(compile_intent_update_request).await?;
        assert_eq!(compile_intent_update_response.status(), StatusCode::OK);
        let compile_intent_update_body = read_json(compile_intent_update_response).await?;
        assert_eq!(
            compile_intent_update_body["deployment"]["status"],
            json!("applied")
        );

        let deployment_event_request = Request::builder()
            .method("POST")
            .uri("/api/internal/lightning-ops/control-plane/mutation")
            .header("content-type", "application/json")
            .body(Body::from(
                json!({
                    "functionName": "lightning/ops:recordGatewayDeploymentEvent",
                    "args": {
                        "secret": "ops-secret-test",
                        "paywallId": active_paywall.id,
                        "ownerId": "owner_usr_ops",
                        "eventType": "deployment_applied",
                        "level": "info",
                        "requestId": "req_2",
                        "metadata": {"target":"gateway"}
                    }
                })
                .to_string(),
            ))?;
        let deployment_event_response = app.clone().oneshot(deployment_event_request).await?;
        assert_eq!(deployment_event_response.status(), StatusCode::OK);
        let deployment_event_body = read_json(deployment_event_response).await?;
        assert!(
            deployment_event_body["event"]["eventId"]
                .as_str()
                .unwrap_or_default()
                .starts_with("evt_")
        );

        let invoice_lifecycle_request = Request::builder()
            .method("POST")
            .uri("/api/internal/lightning-ops/control-plane/mutation")
            .header("content-type", "application/json")
            .body(Body::from(
                json!({
                    "functionName": "lightning/settlements:ingestInvoiceLifecycle",
                    "args": {
                        "secret": "ops-secret-test",
                        "invoiceId": "inv_1",
                        "paywallId": active_paywall.id,
                        "ownerId": "owner_usr_ops",
                        "amountMsats": 2100,
                        "status": "open",
                        "requestId": "inv_req_1"
                    }
                })
                .to_string(),
            ))?;
        let invoice_lifecycle_response = app.clone().oneshot(invoice_lifecycle_request).await?;
        assert_eq!(invoice_lifecycle_response.status(), StatusCode::OK);
        let invoice_lifecycle_body = read_json(invoice_lifecycle_response).await?;
        assert_eq!(invoice_lifecycle_body["changed"], json!(true));
        assert_eq!(invoice_lifecycle_body["invoice"]["status"], json!("open"));

        let invoice_settled_request = Request::builder()
            .method("POST")
            .uri("/api/internal/lightning-ops/control-plane/mutation")
            .header("content-type", "application/json")
            .body(Body::from(
                json!({
                    "functionName": "lightning/settlements:ingestInvoiceLifecycle",
                    "args": {
                        "secret": "ops-secret-test",
                        "invoiceId": "inv_1",
                        "paywallId": active_paywall.id,
                        "ownerId": "owner_usr_ops",
                        "amountMsats": 2100,
                        "status": "settled",
                        "paymentHash": "hash_123",
                        "settledAtMs": 33333
                    }
                })
                .to_string(),
            ))?;
        let invoice_settled_response = app.clone().oneshot(invoice_settled_request).await?;
        assert_eq!(invoice_settled_response.status(), StatusCode::OK);
        let invoice_settled_body = read_json(invoice_settled_response).await?;
        assert_eq!(invoice_settled_body["invoice"]["status"], json!("settled"));
        assert_eq!(invoice_settled_body["invoice"]["settledAtMs"], json!(33333));

        let settlement_request = Request::builder()
            .method("POST")
            .uri("/api/internal/lightning-ops/control-plane/mutation")
            .header("content-type", "application/json")
            .body(Body::from(
                json!({
                    "functionName": "lightning/settlements:ingestSettlement",
                    "args": {
                        "secret": "ops-secret-test",
                        "settlementId": "settle_1",
                        "invoiceId": "inv_1",
                        "paywallId": active_paywall.id,
                        "ownerId": "owner_usr_ops",
                        "amountMsats": 2100,
                        "paymentProofType": "lightning_preimage",
                        "paymentProofValue": "AABBCC11223344556677889900aabbcc",
                        "metadata": {"source":"test"}
                    }
                })
                .to_string(),
            ))?;
        let settlement_response = app.clone().oneshot(settlement_request).await?;
        assert_eq!(settlement_response.status(), StatusCode::OK);
        let settlement_body = read_json(settlement_response).await?;
        assert_eq!(settlement_body["existed"], json!(false));
        assert!(
            settlement_body["settlement"]["paymentProofRef"]
                .as_str()
                .unwrap_or_default()
                .starts_with("lightning_preimage:")
        );

        let settlement_replay_request = Request::builder()
            .method("POST")
            .uri("/api/internal/lightning-ops/control-plane/mutation")
            .header("content-type", "application/json")
            .body(Body::from(
                json!({
                    "functionName": "lightning/settlements:ingestSettlement",
                    "args": {
                        "secret": "ops-secret-test",
                        "settlementId": "settle_1",
                        "invoiceId": "inv_1",
                        "paywallId": active_paywall.id,
                        "ownerId": "owner_usr_ops",
                        "amountMsats": 2100,
                        "paymentProofType": "lightning_preimage",
                        "paymentProofValue": "aabbcc11223344556677889900aabbcc"
                    }
                })
                .to_string(),
            ))?;
        let settlement_replay_response = app.clone().oneshot(settlement_replay_request).await?;
        assert_eq!(settlement_replay_response.status(), StatusCode::OK);
        let settlement_replay_body = read_json(settlement_replay_response).await?;
        assert_eq!(settlement_replay_body["existed"], json!(true));

        let invalid_invoice_status_request = Request::builder()
            .method("POST")
            .uri("/api/internal/lightning-ops/control-plane/mutation")
            .header("content-type", "application/json")
            .body(Body::from(
                json!({
                    "functionName": "lightning/settlements:ingestInvoiceLifecycle",
                    "args": {
                        "secret": "ops-secret-test",
                        "invoiceId": "inv_invalid",
                        "paywallId": active_paywall.id,
                        "ownerId": "owner_usr_ops",
                        "amountMsats": 1,
                        "status": "bad_status"
                    }
                })
                .to_string(),
            ))?;
        let invalid_invoice_status_response =
            app.clone().oneshot(invalid_invoice_status_request).await?;
        assert_eq!(
            invalid_invoice_status_response.status(),
            StatusCode::UNPROCESSABLE_ENTITY
        );
        let invalid_invoice_status_body = read_json(invalid_invoice_status_response).await?;
        assert_eq!(
            invalid_invoice_status_body["error"]["code"],
            json!("invalid_arguments")
        );
        assert_eq!(
            invalid_invoice_status_body["error"]["message"],
            json!("invalid_invoice_status")
        );

        let unsupported_function_request = Request::builder()
            .method("POST")
            .uri("/api/internal/lightning-ops/control-plane/query")
            .header("content-type", "application/json")
            .body(Body::from(
                json!({
                    "functionName": "lightning/ops:missing",
                    "args": {
                        "secret": "ops-secret-test"
                    }
                })
                .to_string(),
            ))?;
        let unsupported_function_response = app.oneshot(unsupported_function_request).await?;
        assert_eq!(
            unsupported_function_response.status(),
            StatusCode::NOT_FOUND
        );
        let unsupported_function_body = read_json(unsupported_function_response).await?;
        assert_eq!(
            unsupported_function_body["error"]["code"],
            json!("unsupported_function")
        );

        Ok(())
    }

    #[tokio::test]
    async fn agent_payments_wallet_balance_and_alias_routes_match() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));

        let token = seed_local_test_token(&config, "agent-payments-user@openagents.com").await?;
        let app = build_router(config);

        let missing_wallet_request = Request::builder()
            .method("GET")
            .uri("/api/agent-payments/wallet")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let missing_wallet_response = app.clone().oneshot(missing_wallet_request).await?;
        assert_eq!(missing_wallet_response.status(), StatusCode::NOT_FOUND);
        let missing_wallet_body = read_json(missing_wallet_response).await?;
        assert_eq!(missing_wallet_body["message"], json!("wallet_not_found"));

        let upsert_request = Request::builder()
            .method("POST")
            .uri("/api/agent-payments/wallet")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from("{}"))?;
        let upsert_response = app.clone().oneshot(upsert_request).await?;
        assert_eq!(upsert_response.status(), StatusCode::OK);
        let upsert_body = read_json(upsert_response).await?;
        let wallet_id = upsert_body["data"]["wallet"]["walletId"]
            .as_str()
            .unwrap_or_default()
            .to_string();
        assert!(!wallet_id.is_empty());
        assert_eq!(upsert_body["data"]["action"], json!("ensured"));

        let wallet_request = Request::builder()
            .method("GET")
            .uri("/api/agent-payments/wallet")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let wallet_response = app.clone().oneshot(wallet_request).await?;
        assert_eq!(wallet_response.status(), StatusCode::OK);
        let wallet_body = read_json(wallet_response).await?;
        assert_eq!(
            wallet_body["data"]["wallet"]["walletId"],
            json!(wallet_id.clone())
        );

        let wallet_alias_request = Request::builder()
            .method("GET")
            .uri("/api/agents/me/wallet")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let wallet_alias_response = app.clone().oneshot(wallet_alias_request).await?;
        assert_eq!(wallet_alias_response.status(), StatusCode::OK);
        let wallet_alias_body = read_json(wallet_alias_response).await?;
        assert_eq!(
            wallet_alias_body["data"]["wallet"]["walletId"],
            json!(wallet_id.clone())
        );

        let balance_request = Request::builder()
            .method("GET")
            .uri("/api/agent-payments/balance")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let balance_response = app.clone().oneshot(balance_request).await?;
        assert_eq!(balance_response.status(), StatusCode::OK);
        let balance_body = read_json(balance_response).await?;
        assert_eq!(balance_body["data"]["walletId"], json!(wallet_id.clone()));

        let balance_alias_request = Request::builder()
            .method("GET")
            .uri("/api/agents/me/balance")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let balance_alias_response = app.oneshot(balance_alias_request).await?;
        assert_eq!(balance_alias_response.status(), StatusCode::OK);
        let balance_alias_body = read_json(balance_alias_response).await?;
        assert_eq!(balance_alias_body["data"]["walletId"], json!(wallet_id));

        Ok(())
    }

    #[tokio::test]
    async fn agent_payments_invoice_pay_send_and_alias_routes_match() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));

        let token = seed_local_test_token(&config, "agent-payments-ops@openagents.com").await?;
        let app = build_router(config);

        let _ = app
            .clone()
            .oneshot(
                Request::builder()
                    .method("POST")
                    .uri("/api/agent-payments/wallet")
                    .header("content-type", "application/json")
                    .header("authorization", format!("Bearer {token}"))
                    .body(Body::from("{}"))?,
            )
            .await?;

        let create_invoice_request = Request::builder()
            .method("POST")
            .uri("/api/agent-payments/invoice")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"amountSats":42,"description":"OpenAgents test invoice"}"#,
            ))?;
        let create_invoice_response = app.clone().oneshot(create_invoice_request).await?;
        assert_eq!(create_invoice_response.status(), StatusCode::OK);
        let create_invoice_body = read_json(create_invoice_response).await?;
        let payment_request = create_invoice_body["data"]["invoice"]["paymentRequest"]
            .as_str()
            .unwrap_or_default()
            .to_string();
        assert!(!payment_request.is_empty());

        let create_invoice_alias_request = Request::builder()
            .method("POST")
            .uri("/api/payments/invoice")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(r#"{"amountSats":21}"#))?;
        let create_invoice_alias_response =
            app.clone().oneshot(create_invoice_alias_request).await?;
        assert_eq!(create_invoice_alias_response.status(), StatusCode::OK);
        let create_invoice_alias_body = read_json(create_invoice_alias_response).await?;
        assert!(
            create_invoice_alias_body["data"]["invoice"]["paymentRequest"]
                .as_str()
                .unwrap_or_default()
                .starts_with("lnbc")
        );

        let rejected_pay_request = Request::builder()
            .method("POST")
            .uri("/api/agent-payments/pay")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"invoice":"lnbc1popenagentsinvoice0000000000000"}"#,
            ))?;
        let rejected_pay_response = app.clone().oneshot(rejected_pay_request).await?;
        assert_eq!(
            rejected_pay_response.status(),
            StatusCode::UNPROCESSABLE_ENTITY
        );
        let rejected_pay_body = read_json(rejected_pay_response).await?;
        assert_eq!(
            rejected_pay_body["error"]["code"],
            json!("max_amount_missing")
        );

        let pay_request = Request::builder()
            .method("POST")
            .uri("/api/agent-payments/pay")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(format!(
                r#"{{"invoice":"{payment_request}","maxAmountSats":42}}"#
            )))?;
        let pay_response = app.clone().oneshot(pay_request).await?;
        assert_eq!(pay_response.status(), StatusCode::OK);
        let pay_body = read_json(pay_response).await?;
        assert_eq!(pay_body["data"]["payment"]["status"], json!("completed"));
        let pay_payment_id = pay_body["data"]["payment"]["paymentId"]
            .as_str()
            .unwrap_or_default()
            .to_string();
        let pay_preimage = pay_body["data"]["payment"]["preimage"]
            .as_str()
            .unwrap_or_default()
            .to_string();
        assert!(pay_payment_id.starts_with("fake:"));
        assert_eq!(pay_preimage.len(), 64);

        let pay_alias_request = Request::builder()
            .method("POST")
            .uri("/api/payments/pay")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(format!(
                r#"{{"invoice":"{payment_request}","maxAmountSats":42}}"#
            )))?;
        let pay_alias_response = app.clone().oneshot(pay_alias_request).await?;
        assert_eq!(pay_alias_response.status(), StatusCode::OK);
        let pay_alias_body = read_json(pay_alias_response).await?;
        assert_eq!(
            pay_alias_body["data"]["payment"]["status"],
            json!("completed")
        );
        assert_eq!(
            pay_alias_body["data"]["payment"]["paymentId"],
            json!(pay_payment_id)
        );
        assert_eq!(
            pay_alias_body["data"]["payment"]["preimage"],
            json!(pay_preimage)
        );

        let send_request = Request::builder()
            .method("POST")
            .uri("/api/agent-payments/send-spark")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"sparkAddress":"spark:recipient","amountSats":21}"#,
            ))?;
        let send_response = app.clone().oneshot(send_request).await?;
        assert_eq!(send_response.status(), StatusCode::OK);
        let send_body = read_json(send_response).await?;
        assert_eq!(send_body["data"]["transfer"]["status"], json!("completed"));

        let send_alias_request = Request::builder()
            .method("POST")
            .uri("/api/payments/send-spark")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"sparkAddress":"spark:recipient","amountSats":21}"#,
            ))?;
        let send_alias_response = app.oneshot(send_alias_request).await?;
        assert_eq!(send_alias_response.status(), StatusCode::OK);
        let send_alias_body = read_json(send_alias_response).await?;
        assert_eq!(
            send_alias_body["data"]["transfer"]["status"],
            json!("completed")
        );

        Ok(())
    }

    #[tokio::test]
    async fn agent_payments_fake_payer_is_deterministic_and_cap_guard_rejects_overage() {
        let invoice = "lnbc42n1invoicefixture";
        let payment = super::agent_payments_pay_invoice_fake(
            invoice,
            42_000,
            12_000,
            Some("Sats4Ai.Com".to_string()),
        )
        .await
        .expect("fake payer should succeed");

        let expected_payment_hash = super::sha256_hex(format!("payment:{invoice}").as_bytes());
        let expected_payment_id = format!("fake:{}", &expected_payment_hash[..16]);
        let expected_preimage = super::sha256_hex(format!("preimage:{invoice}").as_bytes());
        assert_eq!(payment.payment_id, Some(expected_payment_id));
        assert_eq!(payment.preimage, expected_preimage);
        assert_eq!(payment.raw["host"], json!("sats4ai.com"));

        let cap_error = super::agent_payments_invoice_cap_guard("lnbc2000n1toobig", 10_000)
            .expect_err("expected over-cap guard failure");
        assert_eq!(cap_error.status, StatusCode::UNPROCESSABLE_ENTITY);
        assert_eq!(cap_error.code, "quoted_amount_exceeds_cap");
    }

    #[test]
    fn normalize_preimage_hex_handles_hex_and_base64_forms() {
        let hex_input = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
        let normalized_hex = super::normalize_preimage_hex(hex_input).expect("hex normalization");
        assert_eq!(
            normalized_hex,
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
        );

        let bytes = vec![0x11u8; 32];
        let encoded = base64::engine::general_purpose::STANDARD.encode(&bytes);
        let normalized_b64 =
            super::normalize_preimage_hex(&encoded).expect("base64 normalization to hex");
        assert_eq!(normalized_b64, super::bytes_to_hex(&bytes));
    }

    #[tokio::test]
    async fn resend_webhook_rejects_invalid_signature_and_reuses_audit_event_id() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let secret = format!(
            "whsec_{}",
            base64::engine::general_purpose::STANDARD.encode("resend-webhook-test-secret")
        );
        let mut config = test_config(static_dir.path().to_path_buf());
        config.resend_webhook_secret = Some(secret.clone());
        let app = build_router(config);

        let payload = serde_json::json!({
            "type": "email.delivered",
            "created_at": "2026-02-22T00:00:00Z",
            "data": {
                "email_id": "email_invalid_signature",
                "to": ["user@example.com"],
                "tags": [{"name":"integration_id","value":"resend.primary"}]
            }
        })
        .to_string();

        let mut headers = signed_resend_webhook_headers(
            &payload,
            &secret,
            "evt_invalid_signature",
            Utc::now().timestamp(),
        );
        headers.insert("svix-signature", HeaderValue::from_static("v1,invalid"));

        let mut request_builder = Request::builder()
            .method("POST")
            .uri("/api/webhooks/resend")
            .header("content-type", "application/json");
        for (name, value) in &headers {
            request_builder = request_builder.header(name, value);
        }
        let first_request = request_builder.body(Body::from(payload.clone()))?;
        let first_response = app.clone().oneshot(first_request).await?;
        assert_eq!(first_response.status(), StatusCode::UNAUTHORIZED);
        let first_body = read_json(first_response).await?;
        assert_eq!(first_body["error"]["code"], json!("invalid_signature"));
        let first_event_id = first_body["audit"]["event_id"].as_u64().expect("event id");

        let mut replay_builder = Request::builder()
            .method("POST")
            .uri("/api/webhooks/resend")
            .header("content-type", "application/json");
        for (name, value) in &headers {
            replay_builder = replay_builder.header(name, value);
        }
        let replay_request = replay_builder.body(Body::from(payload))?;
        let replay_response = app.oneshot(replay_request).await?;
        assert_eq!(replay_response.status(), StatusCode::UNAUTHORIZED);
        let replay_body = read_json(replay_response).await?;
        assert_eq!(replay_body["error"]["code"], json!("invalid_signature"));
        assert_eq!(replay_body["audit"]["event_id"], json!(first_event_id));

        Ok(())
    }

    #[tokio::test]
    async fn resend_webhook_rejects_stale_timestamp_signature() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let secret = format!(
            "whsec_{}",
            base64::engine::general_purpose::STANDARD.encode("resend-webhook-test-secret")
        );
        let mut config = test_config(static_dir.path().to_path_buf());
        config.resend_webhook_secret = Some(secret.clone());
        config.resend_webhook_tolerance_seconds = 60;
        let app = build_router(config);

        let payload = serde_json::json!({
            "type": "email.delivered",
            "created_at": "2026-02-22T00:00:00Z",
            "data": {
                "email_id": "email_stale_timestamp",
                "to": ["user@example.com"],
                "tags": [{"name":"integration_id","value":"resend.primary"}]
            }
        })
        .to_string();
        let headers = signed_resend_webhook_headers(
            &payload,
            &secret,
            "evt_stale_timestamp",
            Utc::now().timestamp() - 600,
        );

        let mut request_builder = Request::builder()
            .method("POST")
            .uri("/api/webhooks/resend")
            .header("content-type", "application/json");
        for (name, value) in &headers {
            request_builder = request_builder.header(name, value);
        }
        let request = request_builder.body(Body::from(payload))?;
        let response = app.oneshot(request).await?;
        assert_eq!(response.status(), StatusCode::UNAUTHORIZED);
        let response_body = read_json(response).await?;
        assert_eq!(response_body["error"]["code"], json!("invalid_signature"));

        Ok(())
    }

    #[tokio::test]
    async fn resend_webhook_deduplicates_replays_and_detects_conflicts() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let secret = format!(
            "whsec_{}",
            base64::engine::general_purpose::STANDARD.encode("resend-webhook-test-secret")
        );
        let mut config = test_config(static_dir.path().to_path_buf());
        config.resend_webhook_secret = Some(secret.clone());
        config.runtime_comms_delivery_max_retries = 0;
        let app = build_router(config);

        let delivered_payload = serde_json::json!({
            "type": "email.delivered",
            "created_at": "2026-02-22T00:00:00Z",
            "data": {
                "email_id": "email_conflict_1",
                "to": ["user@example.com"],
                "tags": [{"name":"integration_id","value":"resend.primary"}]
            }
        })
        .to_string();
        let bounced_payload = serde_json::json!({
            "type": "email.bounced",
            "created_at": "2026-02-22T00:00:00Z",
            "data": {
                "email_id": "email_conflict_2",
                "to": ["user@example.com"],
                "reason": "mailbox_not_found",
                "tags": [{"name":"integration_id","value":"resend.primary"}]
            }
        })
        .to_string();
        let headers = signed_resend_webhook_headers(
            &delivered_payload,
            &secret,
            "evt_conflict",
            Utc::now().timestamp(),
        );

        let mut first_builder = Request::builder()
            .method("POST")
            .uri("/api/webhooks/resend")
            .header("content-type", "application/json");
        for (name, value) in &headers {
            first_builder = first_builder.header(name, value);
        }
        let first_request = first_builder.body(Body::from(delivered_payload.clone()))?;
        let first_response = app.clone().oneshot(first_request).await?;
        assert_eq!(first_response.status(), StatusCode::ACCEPTED);
        let first_body = read_json(first_response).await?;
        assert_eq!(first_body["data"]["status"], json!("received"));
        assert_eq!(first_body["data"]["idempotent_replay"], json!(false));
        let event_id = first_body["data"]["event_id"].as_u64().expect("event id");

        let mut replay_builder = Request::builder()
            .method("POST")
            .uri("/api/webhooks/resend")
            .header("content-type", "application/json");
        for (name, value) in &headers {
            replay_builder = replay_builder.header(name, value);
        }
        let replay_request = replay_builder.body(Body::from(delivered_payload))?;
        let replay_response = app.clone().oneshot(replay_request).await?;
        assert_eq!(replay_response.status(), StatusCode::OK);
        let replay_body = read_json(replay_response).await?;
        assert_eq!(replay_body["data"]["idempotent_replay"], json!(true));
        assert_eq!(replay_body["data"]["event_id"], json!(event_id));

        let conflict_headers = signed_resend_webhook_headers(
            &bounced_payload,
            &secret,
            "evt_conflict",
            Utc::now().timestamp(),
        );
        let mut conflict_builder = Request::builder()
            .method("POST")
            .uri("/api/webhooks/resend")
            .header("content-type", "application/json");
        for (name, value) in &conflict_headers {
            conflict_builder = conflict_builder.header(name, value);
        }
        let conflict_request = conflict_builder.body(Body::from(bounced_payload))?;
        let conflict_response = app.oneshot(conflict_request).await?;
        assert_eq!(conflict_response.status(), StatusCode::CONFLICT);
        let conflict_body = read_json(conflict_response).await?;
        assert_eq!(
            conflict_body["error"]["code"],
            json!("idempotency_conflict")
        );

        Ok(())
    }

    #[tokio::test]
    async fn resend_webhook_forwarding_retries_and_projects_delivery() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let secret = format!(
            "whsec_{}",
            base64::engine::general_purpose::STANDARD.encode("resend-webhook-test-secret")
        );
        let response_statuses = Arc::new(Mutex::new(vec![500u16, 202u16]));
        let captured_payloads = Arc::new(Mutex::new(Vec::<Value>::new()));
        let (runtime_addr, runtime_handle) =
            start_runtime_comms_delivery_stub(response_statuses.clone(), captured_payloads.clone())
                .await?;

        let mut config = test_config(static_dir.path().to_path_buf());
        config.resend_webhook_secret = Some(secret.clone());
        config.runtime_elixir_base_url = Some(format!("http://{runtime_addr}"));
        config.runtime_signing_key = Some("runtime-signing-key".to_string());
        config.runtime_signing_key_id = "runtime-v1".to_string();
        config.runtime_comms_delivery_ingest_path =
            "/internal/v1/comms/delivery-events".to_string();
        config.runtime_comms_delivery_timeout_ms = 1000;
        config.runtime_comms_delivery_max_retries = 1;
        config.runtime_comms_delivery_retry_backoff_ms = 1;
        let state = test_app_state(config);

        state
            ._domain_store
            .upsert_resend_integration(UpsertResendIntegrationInput {
                user_id: "123".to_string(),
                api_key: "re_runtime_projection_1234567890".to_string(),
                sender_email: Some("noreply@example.com".to_string()),
                sender_name: Some("OpenAgents".to_string()),
            })
            .await
            .expect("seed resend integration");

        let payload = serde_json::json!({
            "type": "email.delivered",
            "created_at": "2026-02-22T00:00:00Z",
            "data": {
                "email_id": "email_projection",
                "to": ["user@example.com"],
                "tags": [
                    {"name":"integration_id","value":"resend.primary"},
                    {"name":"user_id","value":"123"}
                ]
            }
        })
        .to_string();
        let headers = signed_resend_webhook_headers(
            &payload,
            &secret,
            "evt_projection",
            Utc::now().timestamp(),
        );

        let response =
            super::webhooks_resend_store(State(state.clone()), headers, Bytes::from(payload)).await;
        assert_eq!(response.status(), StatusCode::ACCEPTED);
        let response_body = read_json(response).await?;
        assert_eq!(response_body["data"]["status"], json!("received"));

        wait_for_webhook_status(&state, "resend:evt_projection", "forwarded").await?;

        let event = state
            ._domain_store
            .webhook_event_by_idempotency_key("resend:evt_projection")
            .await?
            .expect("webhook event");
        assert_eq!(event.status, "forwarded");
        assert_eq!(event.runtime_attempts, 2);
        assert_eq!(event.runtime_status_code, Some(202));
        assert!(event.forwarded_at.is_some());

        let projection = state
            ._domain_store
            .delivery_projection("123", "resend", Some("resend.primary"))
            .await?
            .expect("delivery projection");
        assert_eq!(projection.last_state.as_deref(), Some("delivered"));
        assert_eq!(
            projection.last_message_id.as_deref(),
            Some("email_projection")
        );
        assert_eq!(projection.source, "runtime_forwarder");
        assert_eq!(projection.last_webhook_event_id, Some(event.id));

        let audits = state
            ._domain_store
            .list_integration_audits_for_user("123")
            .await?;
        assert!(
            audits
                .iter()
                .any(|audit| audit.action == "delivery_projection_updated")
        );

        let captured = captured_payloads.lock().await.clone();
        assert_eq!(captured.len(), 2);

        runtime_handle.abort();
        Ok(())
    }

    #[tokio::test]
    async fn resend_webhook_records_forward_retrying_state_before_success() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let secret = format!(
            "whsec_{}",
            base64::engine::general_purpose::STANDARD.encode("resend-webhook-test-secret")
        );
        let response_statuses = Arc::new(Mutex::new(vec![500u16, 202u16]));
        let captured_payloads = Arc::new(Mutex::new(Vec::<Value>::new()));
        let (runtime_addr, runtime_handle) =
            start_runtime_comms_delivery_stub(response_statuses.clone(), captured_payloads.clone())
                .await?;

        let mut config = test_config(static_dir.path().to_path_buf());
        config.resend_webhook_secret = Some(secret.clone());
        config.runtime_elixir_base_url = Some(format!("http://{runtime_addr}"));
        config.runtime_signing_key = Some("runtime-signing-key".to_string());
        config.runtime_signing_key_id = "runtime-v1".to_string();
        config.runtime_comms_delivery_ingest_path =
            "/internal/v1/comms/delivery-events".to_string();
        config.runtime_comms_delivery_timeout_ms = 1000;
        config.runtime_comms_delivery_max_retries = 1;
        config.runtime_comms_delivery_retry_backoff_ms = 250;
        let state = test_app_state(config);

        state
            ._domain_store
            .upsert_resend_integration(UpsertResendIntegrationInput {
                user_id: "456".to_string(),
                api_key: "re_runtime_projection_9876543210".to_string(),
                sender_email: Some("noreply@example.com".to_string()),
                sender_name: Some("OpenAgents".to_string()),
            })
            .await
            .expect("seed resend integration");

        let payload = serde_json::json!({
            "type": "email.delivered",
            "created_at": "2026-02-22T00:00:00Z",
            "data": {
                "email_id": "email_transition",
                "to": ["user@example.com"],
                "tags": [
                    {"name":"integration_id","value":"resend.primary"},
                    {"name":"user_id","value":"456"}
                ]
            }
        })
        .to_string();
        let headers = signed_resend_webhook_headers(
            &payload,
            &secret,
            "evt_retry_transition",
            Utc::now().timestamp(),
        );

        let response =
            super::webhooks_resend_store(State(state.clone()), headers, Bytes::from(payload)).await;
        assert_eq!(response.status(), StatusCode::ACCEPTED);

        let mut saw_retrying = false;
        for _ in 0..80 {
            if let Some(event) = state
                ._domain_store
                .webhook_event_by_idempotency_key("resend:evt_retry_transition")
                .await?
            {
                if event.status == "forward_retrying" {
                    saw_retrying = true;
                    break;
                }
                if event.status == "forwarded" {
                    break;
                }
            }
            tokio::time::sleep(std::time::Duration::from_millis(10)).await;
        }
        assert!(saw_retrying);

        wait_for_webhook_status(&state, "resend:evt_retry_transition", "forwarded").await?;
        let event = state
            ._domain_store
            .webhook_event_by_idempotency_key("resend:evt_retry_transition")
            .await?
            .expect("webhook event");
        assert_eq!(event.runtime_attempts, 2);
        assert_eq!(event.status, "forwarded");

        runtime_handle.abort();
        Ok(())
    }

    #[tokio::test]
    async fn shouts_create_list_and_zones_match_contract() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));

        let author_token = seed_local_test_token(&config, "shout-author@openagents.com").await?;
        let other_token = seed_local_test_token(&config, "shout-other@openagents.com").await?;
        let app = build_router(config.clone());

        let unauthorized_request = Request::builder()
            .method("POST")
            .uri("/api/shouts")
            .header("content-type", "application/json")
            .body(Body::from(r#"{"body":"unauthorized"}"#))?;
        let unauthorized_response = app.clone().oneshot(unauthorized_request).await?;
        assert_eq!(unauthorized_response.status(), StatusCode::UNAUTHORIZED);

        let create_l402_request = Request::builder()
            .method("POST")
            .uri("/api/shouts")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {author_token}"))
            .body(Body::from(
                r#"{"body":"L402 payment shipped","zone":"L402"}"#,
            ))?;
        let create_l402_response = app.clone().oneshot(create_l402_request).await?;
        assert_eq!(create_l402_response.status(), StatusCode::CREATED);
        let create_l402_body = read_json(create_l402_response).await?;
        assert_eq!(create_l402_body["data"]["zone"], json!("l402"));
        assert_eq!(
            create_l402_body["data"]["body"],
            json!("L402 payment shipped")
        );
        assert_eq!(
            create_l402_body["data"]["author"]["handle"],
            json!("shout-author")
        );

        let create_text_alias_request = Request::builder()
            .method("POST")
            .uri("/api/shouts")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {author_token}"))
            .body(Body::from(
                r#"{"text":"compat text alias shout","zone":"Global"}"#,
            ))?;
        let create_text_alias_response = app.clone().oneshot(create_text_alias_request).await?;
        assert_eq!(create_text_alias_response.status(), StatusCode::CREATED);
        let create_text_alias_body = read_json(create_text_alias_response).await?;
        assert_eq!(create_text_alias_body["data"]["zone"], json!("global"));
        assert_eq!(
            create_text_alias_body["data"]["body"],
            json!("compat text alias shout")
        );

        let create_global_request = Request::builder()
            .method("POST")
            .uri("/api/shouts")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {other_token}"))
            .body(Body::from(
                r#"{"body":"hello from global","zone":"global"}"#,
            ))?;
        let create_global_response = app.clone().oneshot(create_global_request).await?;
        assert_eq!(create_global_response.status(), StatusCode::CREATED);

        let list_l402_request = Request::builder()
            .method("GET")
            .uri("/api/shouts?zone=l402")
            .body(Body::empty())?;
        let list_l402_response = app.clone().oneshot(list_l402_request).await?;
        assert_eq!(list_l402_response.status(), StatusCode::OK);
        let list_l402_body = read_json(list_l402_response).await?;
        assert_eq!(
            list_l402_body["data"].as_array().map(|rows| rows.len()),
            Some(1)
        );
        assert_eq!(list_l402_body["data"][0]["zone"], json!("l402"));

        let zones_request = Request::builder()
            .method("GET")
            .uri("/api/shouts/zones")
            .body(Body::empty())?;
        let zones_response = app.oneshot(zones_request).await?;
        assert_eq!(zones_response.status(), StatusCode::OK);
        let zones_body = read_json(zones_response).await?;
        assert_eq!(zones_body["data"][0]["zone"], json!("global"));
        assert_eq!(zones_body["data"][0]["count24h"], json!(2));

        Ok(())
    }

    #[tokio::test]
    async fn shouts_feed_caps_limit_and_supports_before_id_pagination() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));

        let token = seed_local_test_token(&config, "shout-pagination@openagents.com").await?;
        let app = build_router(config.clone());
        for idx in 0..205 {
            let create_request = Request::builder()
                .method("POST")
                .uri("/api/shouts")
                .header("content-type", "application/json")
                .header("authorization", format!("Bearer {token}"))
                .body(Body::from(format!(
                    r#"{{"body":"feed-{idx}","zone":"global"}}"#
                )))?;
            let create_response = app.clone().oneshot(create_request).await?;
            assert_eq!(create_response.status(), StatusCode::CREATED);
        }

        let page_one_request = Request::builder()
            .method("GET")
            .uri("/api/shouts?limit=999")
            .body(Body::empty())?;
        let page_one_response = app.clone().oneshot(page_one_request).await?;
        assert_eq!(page_one_response.status(), StatusCode::OK);
        let page_one_body = read_json(page_one_response).await?;
        assert_eq!(
            page_one_body["data"].as_array().map(|rows| rows.len()),
            Some(200)
        );
        let last_id = page_one_body["data"][199]["id"]
            .as_u64()
            .expect("expected cursor id");
        assert_eq!(
            page_one_body["meta"]["nextCursor"],
            json!(last_id.to_string())
        );

        let page_two_request = Request::builder()
            .method("GET")
            .uri(format!("/api/shouts?limit=200&before_id={last_id}"))
            .body(Body::empty())?;
        let page_two_response = app.oneshot(page_two_request).await?;
        assert_eq!(page_two_response.status(), StatusCode::OK);
        let page_two_body = read_json(page_two_response).await?;
        assert_eq!(
            page_two_body["data"].as_array().map(|rows| rows.len()),
            Some(5)
        );

        Ok(())
    }

    #[tokio::test]
    async fn feed_page_renders_html_and_respects_zone_filters() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));

        let author_token = seed_local_test_token(&config, "feed-author@openagents.com").await?;
        let app = build_router(config.clone());

        for payload in [
            r#"{"body":"L402-only shout body","zone":"l402"}"#,
            r#"{"body":"Dev-only shout body","zone":"dev"}"#,
            r#"{"body":"Global shout body"}"#,
        ] {
            let create_request = Request::builder()
                .method("POST")
                .uri("/api/shouts")
                .header("content-type", "application/json")
                .header("authorization", format!("Bearer {author_token}"))
                .body(Body::from(payload.to_string()))?;
            let create_response = app.clone().oneshot(create_request).await?;
            assert_eq!(create_response.status(), StatusCode::CREATED);
        }

        let zone_request = Request::builder()
            .method("GET")
            .uri("/feed?zone=l402")
            .body(Body::empty())?;
        let zone_response = app.clone().oneshot(zone_request).await?;
        assert_eq!(zone_response.status(), StatusCode::OK);
        let zone_body = zone_response.into_body().collect().await?.to_bytes();
        let zone_html = String::from_utf8_lossy(&zone_body);
        assert!(zone_html.contains("rust shell"));
        assert!(zone_html.contains("L402-only shout body"));
        assert!(!zone_html.contains("Dev-only shout body"));

        let all_request = Request::builder()
            .method("GET")
            .uri("/feed?zone=all&limit=999")
            .body(Body::empty())?;
        let all_response = app.clone().oneshot(all_request).await?;
        assert_eq!(all_response.status(), StatusCode::OK);
        let all_body = all_response.into_body().collect().await?.to_bytes();
        let all_html = String::from_utf8_lossy(&all_body);
        assert!(all_html.contains("rust shell"));
        assert!(all_html.contains("L402-only shout body"));
        assert!(all_html.contains("Dev-only shout body"));
        assert!(all_html.contains("Global shout body"));

        let invalid_since_request = Request::builder()
            .method("GET")
            .uri("/feed?since=not-a-date")
            .body(Body::empty())?;
        let invalid_since_response = app.oneshot(invalid_since_request).await?;
        assert_eq!(
            invalid_since_response.status(),
            StatusCode::UNPROCESSABLE_ENTITY
        );
        let invalid_since_body = read_json(invalid_since_response).await?;
        assert_eq!(
            invalid_since_body["error"]["code"],
            json!("invalid_request")
        );
        assert_eq!(
            invalid_since_body["errors"]["since"],
            json!(["The since field must be a valid date."])
        );

        Ok(())
    }

    #[tokio::test]
    async fn feed_page_without_inertia_header_serves_rust_shell() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.route_split_mode = "rust".to_string();
        config.route_split_rust_routes = vec!["/".to_string()];
        let app = build_router(config);

        let request = Request::builder().uri("/feed").body(Body::empty())?;
        let response = app.oneshot(request).await?;
        assert_eq!(response.status(), StatusCode::OK);
        let body = response.into_body().collect().await?.to_bytes();
        let html = String::from_utf8_lossy(&body);
        assert!(html.contains("rust shell"));

        Ok(())
    }

    #[tokio::test]
    async fn feed_main_fragment_zone_transitions_support_named_and_all() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));
        let token = seed_local_test_token(&config, "feed-fragment-zone@openagents.com").await?;
        let app = build_router(config);

        for payload in [
            r#"{"body":"Zone-L402-only","zone":"l402"}"#,
            r#"{"body":"Zone-Dev-only","zone":"dev"}"#,
            r#"{"body":"Zone-Global-only"}"#,
        ] {
            let request = Request::builder()
                .method("POST")
                .uri("/api/shouts")
                .header("content-type", "application/json")
                .header("authorization", format!("Bearer {token}"))
                .body(Body::from(payload.to_string()))?;
            let response = app.clone().oneshot(request).await?;
            assert_eq!(response.status(), StatusCode::CREATED);
        }

        let named_zone_request = Request::builder()
            .method("GET")
            .uri("/feed/fragments/main?zone=l402")
            .header("hx-request", "true")
            .body(Body::empty())?;
        let named_zone_response = app.clone().oneshot(named_zone_request).await?;
        assert_eq!(named_zone_response.status(), StatusCode::OK);
        let named_zone_body = read_text(named_zone_response).await?;
        assert!(named_zone_body.contains("id=\"feed-main-panel\""));
        assert!(named_zone_body.contains("id=\"feed-zone-panel\""));
        assert!(named_zone_body.contains("hx-swap-oob=\"outerHTML\""));
        assert!(named_zone_body.contains("Zone-L402-only"));
        assert!(!named_zone_body.contains("Zone-Dev-only"));
        assert!(!named_zone_body.contains("Zone-Global-only"));

        let all_zone_request = Request::builder()
            .method("GET")
            .uri("/feed/fragments/main?zone=all")
            .header("hx-request", "true")
            .body(Body::empty())?;
        let all_zone_response = app.clone().oneshot(all_zone_request).await?;
        assert_eq!(all_zone_response.status(), StatusCode::OK);
        let all_zone_body = read_text(all_zone_response).await?;
        assert!(all_zone_body.contains("Zone-L402-only"));
        assert!(all_zone_body.contains("Zone-Dev-only"));
        assert!(all_zone_body.contains("Zone-Global-only"));

        let non_hx_request = Request::builder()
            .method("GET")
            .uri("/feed/fragments/main?zone=l402")
            .body(Body::empty())?;
        let non_hx_response = app.clone().oneshot(non_hx_request).await?;
        assert_eq!(non_hx_response.status(), StatusCode::TEMPORARY_REDIRECT);
        assert_eq!(
            non_hx_response
                .headers()
                .get("location")
                .and_then(|value| value.to_str().ok()),
            Some("/feed?zone=l402")
        );

        let direct_request = Request::builder()
            .method("GET")
            .uri("/feed?zone=l402")
            .body(Body::empty())?;
        let direct_response = app.oneshot(direct_request).await?;
        assert_eq!(direct_response.status(), StatusCode::OK);
        let direct_body = read_text(direct_response).await?;
        assert!(direct_body.contains("Zone-L402-only"));
        assert!(!direct_body.contains("Zone-Dev-only"));
        assert!(!direct_body.contains("Zone-Global-only"));

        Ok(())
    }

    #[tokio::test]
    async fn feed_items_fragment_supports_multi_page_loading_without_duplicates() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));
        let token = seed_local_test_token(&config, "feed-pagination-multi@openagents.com").await?;
        let app = build_router(config);

        for idx in 0..120 {
            let request = Request::builder()
                .method("POST")
                .uri("/api/shouts")
                .header("content-type", "application/json")
                .header("authorization", format!("Bearer {token}"))
                .body(Body::from(format!(
                    r#"{{"body":"inc-{idx}","zone":"global"}}"#
                )))?;
            let response = app.clone().oneshot(request).await?;
            assert_eq!(response.status(), StatusCode::CREATED);
        }

        let main_request = Request::builder()
            .method("GET")
            .uri("/feed/fragments/main?zone=all&limit=50")
            .header("hx-request", "true")
            .body(Body::empty())?;
        let main_response = app.clone().oneshot(main_request).await?;
        assert_eq!(main_response.status(), StatusCode::OK);
        let main_body = read_text(main_response).await?;
        assert!(main_body.contains("inc-119"));
        assert!(main_body.contains("inc-70"));
        assert!(!main_body.contains("inc-69"));
        let cursor_one = main_body
            .split("before_id=")
            .nth(1)
            .and_then(|tail| tail.split('"').next())
            .unwrap_or_default()
            .to_string();
        assert!(!cursor_one.is_empty());

        let page_two_request = Request::builder()
            .method("GET")
            .uri(format!(
                "/feed/fragments/items?zone=all&limit=50&before_id={cursor_one}"
            ))
            .header("hx-request", "true")
            .body(Body::empty())?;
        let page_two_response = app.clone().oneshot(page_two_request).await?;
        assert_eq!(page_two_response.status(), StatusCode::OK);
        let page_two_body = read_text(page_two_response).await?;
        assert!(!page_two_body.contains("inc-119"));
        assert!(page_two_body.contains("inc-69"));
        assert!(page_two_body.contains("inc-20"));
        assert!(!page_two_body.contains("inc-19"));
        let cursor_two = page_two_body
            .split("before_id=")
            .nth(1)
            .and_then(|tail| tail.split('"').next())
            .unwrap_or_default()
            .to_string();
        assert!(!cursor_two.is_empty());

        let page_three_request = Request::builder()
            .method("GET")
            .uri(format!(
                "/feed/fragments/items?zone=all&limit=50&before_id={cursor_two}"
            ))
            .header("hx-request", "true")
            .body(Body::empty())?;
        let page_three_response = app.oneshot(page_three_request).await?;
        assert_eq!(page_three_response.status(), StatusCode::OK);
        let page_three_body = read_text(page_three_response).await?;
        assert!(page_three_body.contains("inc-19"));
        assert!(page_three_body.contains("inc-0"));
        assert!(!page_three_body.contains("inc-20"));
        assert!(page_three_body.contains("No more items."));
        assert!(!page_three_body.contains("before_id="));

        Ok(())
    }

    #[tokio::test]
    async fn feed_items_fragment_partial_page_returns_no_more_marker() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));
        let token =
            seed_local_test_token(&config, "feed-pagination-partial@openagents.com").await?;
        let app = build_router(config);

        for idx in 0..60 {
            let request = Request::builder()
                .method("POST")
                .uri("/api/shouts")
                .header("content-type", "application/json")
                .header("authorization", format!("Bearer {token}"))
                .body(Body::from(format!(
                    r#"{{"body":"partial-{idx}","zone":"global"}}"#
                )))?;
            let response = app.clone().oneshot(request).await?;
            assert_eq!(response.status(), StatusCode::CREATED);
        }

        let main_request = Request::builder()
            .method("GET")
            .uri("/feed/fragments/main?zone=all&limit=50")
            .header("hx-request", "true")
            .body(Body::empty())?;
        let main_response = app.clone().oneshot(main_request).await?;
        let main_body = read_text(main_response).await?;
        let cursor = main_body
            .split("before_id=")
            .nth(1)
            .and_then(|tail| tail.split('"').next())
            .unwrap_or_default()
            .to_string();
        assert!(!cursor.is_empty());

        let partial_request = Request::builder()
            .method("GET")
            .uri(format!(
                "/feed/fragments/items?zone=all&limit=50&before_id={cursor}"
            ))
            .header("hx-request", "true")
            .body(Body::empty())?;
        let partial_response = app.oneshot(partial_request).await?;
        assert_eq!(partial_response.status(), StatusCode::OK);
        let partial_body = read_text(partial_response).await?;
        assert!(partial_body.contains("partial-9"));
        assert!(partial_body.contains("partial-0"));
        assert!(partial_body.contains("No more items."));
        assert!(!partial_body.contains("before_id="));

        Ok(())
    }

    #[tokio::test]
    async fn feed_items_fragment_empty_result_is_explicit() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let app = build_router(test_config(static_dir.path().to_path_buf()));

        let request = Request::builder()
            .method("GET")
            .uri("/feed/fragments/items?zone=all&limit=50&before_id=999999")
            .header("hx-request", "true")
            .body(Body::empty())?;
        let response = app.oneshot(request).await?;
        assert_eq!(response.status(), StatusCode::OK);
        let body = read_text(response).await?;
        assert!(body.contains("No more items."));
        assert!(!body.contains("oa-feed-item"));
        assert!(!body.contains("before_id="));

        Ok(())
    }

    #[tokio::test]
    async fn web_feed_shout_hx_success_emits_trigger_and_refreshes_list() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));
        let token = seed_local_test_token(&config, "feed-shout-hx@openagents.com").await?;
        let app = build_router(config);

        let post_request = Request::builder()
            .method("POST")
            .uri("/feed/shout")
            .header("content-type", "application/x-www-form-urlencoded")
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from("body=HTMX+zone+post&zone=l402"))?;
        let post_response = app.clone().oneshot(post_request).await?;
        assert_eq!(post_response.status(), StatusCode::OK);
        assert_eq!(
            post_response
                .headers()
                .get("HX-Trigger")
                .and_then(|value| value.to_str().ok()),
            Some("feed-shout-posted")
        );
        let post_body = read_text(post_response).await?;
        assert!(post_body.contains("id=\"feed-status\""));
        assert!(post_body.contains("Shout posted."));

        let fragment_request = Request::builder()
            .method("GET")
            .uri("/feed/fragments/main?zone=l402")
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::empty())?;
        let fragment_response = app.oneshot(fragment_request).await?;
        assert_eq!(fragment_response.status(), StatusCode::OK);
        let fragment_body = read_text(fragment_response).await?;
        assert!(fragment_body.contains("HTMX zone post"));
        assert!(fragment_body.contains("id=\"feed-main-panel\""));
        assert!(!fragment_body.contains("<html"));

        Ok(())
    }

    #[tokio::test]
    async fn web_feed_shout_hx_validation_errors_render_inline_without_trigger() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));
        let token = seed_local_test_token(&config, "feed-shout-hx-errors@openagents.com").await?;
        let app = build_router(config);

        let empty_request = Request::builder()
            .method("POST")
            .uri("/feed/shout")
            .header("content-type", "application/x-www-form-urlencoded")
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from("body=%20%20"))?;
        let empty_response = app.clone().oneshot(empty_request).await?;
        assert_eq!(empty_response.status(), StatusCode::UNPROCESSABLE_ENTITY);
        assert!(empty_response.headers().get("HX-Trigger").is_none());
        let empty_body = read_text(empty_response).await?;
        assert!(empty_body.contains("Message body cannot be empty."));

        let invalid_zone_request = Request::builder()
            .method("POST")
            .uri("/feed/shout")
            .header("content-type", "application/x-www-form-urlencoded")
            .header("hx-request", "true")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from("body=hello&zone=bad%20zone"))?;
        let invalid_zone_response = app.oneshot(invalid_zone_request).await?;
        assert_eq!(
            invalid_zone_response.status(),
            StatusCode::UNPROCESSABLE_ENTITY
        );
        assert!(invalid_zone_response.headers().get("HX-Trigger").is_none());
        let invalid_zone_body = read_text(invalid_zone_response).await?;
        assert!(invalid_zone_body.contains("Zone format is invalid."));

        Ok(())
    }

    #[tokio::test]
    async fn feed_page_hx_boost_request_returns_main_fragment() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let app = build_router(test_config(static_dir.path().to_path_buf()));

        let request = Request::builder()
            .method("GET")
            .uri("/feed")
            .header("hx-request", "true")
            .header("hx-boosted", "true")
            .body(Body::empty())?;
        let response = app.oneshot(request).await?;
        assert_eq!(response.status(), StatusCode::OK);
        let content_type = response
            .headers()
            .get(CONTENT_TYPE)
            .and_then(|value| value.to_str().ok())
            .unwrap_or_default();
        assert!(content_type.starts_with("text/html"));

        let body = response.into_body().collect().await?.to_bytes();
        let html = String::from_utf8_lossy(&body);
        assert!(html.starts_with("<main id=\"oa-main-shell\""));
        assert!(html.contains("oa-feed"));
        assert!(!html.contains("<html"));
        assert!(!html.contains("<head"));
        assert!(!html.contains("<body"));

        Ok(())
    }

    #[tokio::test]
    async fn htmx_get_routes_return_fragment_while_direct_get_returns_shell() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));
        let app = build_router(config);

        for path in ["/", "/login", "/feed"] {
            let hx_request = Request::builder()
                .method("GET")
                .uri(path)
                .header("hx-request", "true")
                .header("hx-boosted", "true")
                .header("hx-target", "oa-main-shell")
                .body(Body::empty())?;
            let hx_response = app.clone().oneshot(hx_request).await?;
            assert_eq!(hx_response.status(), StatusCode::OK);
            let hx_body = hx_response.into_body().collect().await?.to_bytes();
            let hx_html = String::from_utf8_lossy(&hx_body);
            assert!(hx_html.starts_with("<main id=\"oa-main-shell\""));
            assert!(!hx_html.contains("<html"));

            let direct_request = Request::builder()
                .method("GET")
                .uri(path)
                .body(Body::empty())?;
            let direct_response = app.clone().oneshot(direct_request).await?;
            assert_eq!(direct_response.status(), StatusCode::OK);
            let direct_body = direct_response.into_body().collect().await?.to_bytes();
            let direct_html = String::from_utf8_lossy(&direct_body);
            assert!(direct_html.contains("<html"));
            assert!(direct_html.contains("id=\"oa-shell\""));
            assert!(direct_html.contains("id=\"oa-main-shell\""));
        }

        Ok(())
    }

    #[tokio::test]
    async fn htmx_route_group_override_can_force_full_page_mode_per_domain() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.route_split_mode = "rust".to_string();
        config.route_split_rust_routes = vec!["/".to_string()];
        let app = build_router(config);
        let token = authenticate_token(app.clone(), "routes@openagents.com").await?;

        let override_request = Request::builder()
            .method("POST")
            .uri("/api/v1/control/route-split/override")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{"target":"htmx_full_page","domain":"chat_pilot"}"#,
            ))?;
        let override_response = app.clone().oneshot(override_request).await?;
        assert_eq!(override_response.status(), StatusCode::OK);

        let hx_feed_request = Request::builder()
            .method("GET")
            .uri("/feed")
            .header("hx-request", "true")
            .header("hx-boosted", "true")
            .header("hx-target", "oa-main-shell")
            .body(Body::empty())?;
        let hx_feed_response = app.clone().oneshot(hx_feed_request).await?;
        assert_eq!(hx_feed_response.status(), StatusCode::OK);
        assert_eq!(
            hx_feed_response
                .headers()
                .get("HX-Redirect")
                .and_then(|value| value.to_str().ok()),
            Some("/feed")
        );

        let full_feed_request = Request::builder()
            .method("GET")
            .uri("/feed")
            .body(Body::empty())?;
        let full_feed_response = app.clone().oneshot(full_feed_request).await?;
        assert_eq!(full_feed_response.status(), StatusCode::OK);
        let full_feed_body = full_feed_response.into_body().collect().await?.to_bytes();
        let full_feed_html = String::from_utf8_lossy(&full_feed_body);
        assert!(full_feed_html.contains("<html"));
        assert!(full_feed_html.contains("id=\"oa-shell\" hx-disable=\"true\""));
        assert!(full_feed_html.contains("name=\"openagents-htmx-mode\" content=\"full_page\""));

        let fragment_request = Request::builder()
            .method("GET")
            .uri("/feed/fragments/main?zone=all")
            .header("hx-request", "true")
            .body(Body::empty())?;
        let fragment_response = app.clone().oneshot(fragment_request).await?;
        assert_eq!(fragment_response.status(), StatusCode::TEMPORARY_REDIRECT);
        assert_eq!(
            fragment_response
                .headers()
                .get("location")
                .and_then(|value| value.to_str().ok()),
            Some("/feed?zone=all")
        );

        Ok(())
    }

    #[tokio::test]
    async fn htmx_history_restore_preserves_feed_zone_and_status_queries() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));

        let author_token = seed_local_test_token(&config, "history-author@openagents.com").await?;
        let app = build_router(config);

        for payload in [
            r#"{"body":"History-L402 shout","zone":"l402"}"#,
            r#"{"body":"History-Dev shout","zone":"dev"}"#,
        ] {
            let create_request = Request::builder()
                .method("POST")
                .uri("/api/shouts")
                .header("content-type", "application/json")
                .header("authorization", format!("Bearer {author_token}"))
                .body(Body::from(payload.to_string()))?;
            let create_response = app.clone().oneshot(create_request).await?;
            assert_eq!(create_response.status(), StatusCode::CREATED);
        }

        let l402_request = Request::builder()
            .method("GET")
            .uri("/feed?zone=l402&status=shout-posted")
            .header("hx-request", "true")
            .header("hx-boosted", "true")
            .header("hx-target", "oa-main-shell")
            .body(Body::empty())?;
        let l402_response = app.clone().oneshot(l402_request).await?;
        assert_eq!(l402_response.status(), StatusCode::OK);
        let l402_body = l402_response.into_body().collect().await?.to_bytes();
        let l402_html = String::from_utf8_lossy(&l402_body);
        assert!(l402_html.contains("History-L402 shout"));
        assert!(!l402_html.contains("History-Dev shout"));
        assert!(l402_html.contains("Shout posted."));

        let dev_request = Request::builder()
            .method("GET")
            .uri("/feed?zone=dev")
            .header("hx-request", "true")
            .header("hx-boosted", "true")
            .header("hx-target", "oa-main-shell")
            .body(Body::empty())?;
        let dev_response = app.clone().oneshot(dev_request).await?;
        assert_eq!(dev_response.status(), StatusCode::OK);
        let dev_body = dev_response.into_body().collect().await?.to_bytes();
        let dev_html = String::from_utf8_lossy(&dev_body);
        assert!(!dev_html.contains("History-L402 shout"));
        assert!(dev_html.contains("History-Dev shout"));

        let history_restore_request = Request::builder()
            .method("GET")
            .uri("/feed?zone=l402&status=shout-posted")
            .header("hx-request", "true")
            .header("hx-history-restore-request", "true")
            .header("hx-target", "oa-main-shell")
            .body(Body::empty())?;
        let history_restore_response = app.clone().oneshot(history_restore_request).await?;
        assert_eq!(history_restore_response.status(), StatusCode::OK);
        let history_restore_body = history_restore_response
            .into_body()
            .collect()
            .await?
            .to_bytes();
        let history_restore_html = String::from_utf8_lossy(&history_restore_body);
        assert!(history_restore_html.starts_with("<main id=\"oa-main-shell\""));
        assert!(history_restore_html.contains("History-L402 shout"));
        assert!(!history_restore_html.contains("History-Dev shout"));
        assert!(history_restore_html.contains("Shout posted."));

        let refresh_request = Request::builder()
            .method("GET")
            .uri("/feed?zone=l402&status=shout-posted")
            .body(Body::empty())?;
        let refresh_response = app.oneshot(refresh_request).await?;
        assert_eq!(refresh_response.status(), StatusCode::OK);
        let refresh_body = refresh_response.into_body().collect().await?.to_bytes();
        let refresh_html = String::from_utf8_lossy(&refresh_body);
        assert!(refresh_html.contains("<html"));
        assert!(refresh_html.contains("History-L402 shout"));
        assert!(refresh_html.contains("Shout posted."));

        Ok(())
    }

    #[tokio::test]
    async fn html_routes_include_csp_and_security_headers() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));
        let app = build_router(config);

        for path in ["/", "/login", "/feed"] {
            let request = Request::builder().uri(path).body(Body::empty())?;
            let response = app.clone().oneshot(request).await?;
            assert_eq!(response.status(), StatusCode::OK);

            assert_eq!(
                response
                    .headers()
                    .get(super::HEADER_CONTENT_SECURITY_POLICY)
                    .and_then(|value| value.to_str().ok()),
                Some(super::HTML_CONTENT_SECURITY_POLICY)
            );
            assert_eq!(
                response
                    .headers()
                    .get(super::HEADER_X_CONTENT_TYPE_OPTIONS)
                    .and_then(|value| value.to_str().ok()),
                Some(super::X_CONTENT_TYPE_OPTIONS_NOSNIFF)
            );
            assert_eq!(
                response
                    .headers()
                    .get(super::HEADER_REFERRER_POLICY)
                    .and_then(|value| value.to_str().ok()),
                Some(super::HTML_REFERRER_POLICY)
            );
            assert_eq!(
                response
                    .headers()
                    .get(super::HEADER_X_FRAME_OPTIONS)
                    .and_then(|value| value.to_str().ok()),
                Some(super::HTML_X_FRAME_OPTIONS)
            );
            assert_eq!(
                response
                    .headers()
                    .get(super::HEADER_PERMISSIONS_POLICY)
                    .and_then(|value| value.to_str().ok()),
                Some(super::HTML_PERMISSIONS_POLICY)
            );
        }

        Ok(())
    }

    #[tokio::test]
    async fn whispers_create_list_and_read_match_contract() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));

        let sender_token = seed_local_test_token(&config, "whisper-sender@openagents.com").await?;
        let recipient_token =
            seed_local_test_token(&config, "whisper-recipient@openagents.com").await?;
        let third_token = seed_local_test_token(&config, "whisper-third@openagents.com").await?;
        let app = build_router(config.clone());

        let unauthorized_request = Request::builder()
            .method("POST")
            .uri("/api/whispers")
            .header("content-type", "application/json")
            .body(Body::from(
                r#"{"recipientHandle":"whisper-recipient","body":"unauthorized"}"#,
            ))?;
        let unauthorized_response = app.clone().oneshot(unauthorized_request).await?;
        assert_eq!(unauthorized_response.status(), StatusCode::UNAUTHORIZED);

        let create_request = Request::builder()
            .method("POST")
            .uri("/api/whispers")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {sender_token}"))
            .body(Body::from(
                r#"{"recipientHandle":"whisper-recipient","body":"hey"}"#,
            ))?;
        let create_response = app.clone().oneshot(create_request).await?;
        assert_eq!(create_response.status(), StatusCode::CREATED);
        let create_body = read_json(create_response).await?;
        assert_eq!(create_body["data"]["body"], json!("hey"));
        assert_eq!(
            create_body["data"]["sender"]["handle"],
            json!("whisper-sender")
        );
        assert_eq!(
            create_body["data"]["recipient"]["handle"],
            json!("whisper-recipient")
        );
        assert_eq!(create_body["data"]["readAt"], json!(null));
        let whisper_id = create_body["data"]["id"]
            .as_u64()
            .expect("expected whisper id");

        let sender_list_request = Request::builder()
            .method("GET")
            .uri("/api/whispers?with=whisper-recipient")
            .header("authorization", format!("Bearer {sender_token}"))
            .body(Body::empty())?;
        let sender_list_response = app.clone().oneshot(sender_list_request).await?;
        assert_eq!(sender_list_response.status(), StatusCode::OK);
        let sender_list_body = read_json(sender_list_response).await?;
        assert_eq!(
            sender_list_body["data"].as_array().map(|rows| rows.len()),
            Some(1)
        );
        assert_eq!(sender_list_body["meta"]["with"], json!("whisper-recipient"));

        let recipient_list_request = Request::builder()
            .method("GET")
            .uri("/api/whispers?with=whisper-sender")
            .header("authorization", format!("Bearer {recipient_token}"))
            .body(Body::empty())?;
        let recipient_list_response = app.clone().oneshot(recipient_list_request).await?;
        assert_eq!(recipient_list_response.status(), StatusCode::OK);
        let recipient_list_body = read_json(recipient_list_response).await?;
        assert_eq!(
            recipient_list_body["data"]
                .as_array()
                .map(|rows| rows.len()),
            Some(1)
        );

        let mark_read_request = Request::builder()
            .method("PATCH")
            .uri(format!("/api/whispers/{whisper_id}/read"))
            .header("authorization", format!("Bearer {recipient_token}"))
            .body(Body::empty())?;
        let mark_read_response = app.clone().oneshot(mark_read_request).await?;
        assert_eq!(mark_read_response.status(), StatusCode::OK);
        let mark_read_body = read_json(mark_read_response).await?;
        assert!(mark_read_body["data"]["readAt"].as_str().is_some());

        let sender_mark_read_request = Request::builder()
            .method("PATCH")
            .uri(format!("/api/whispers/{whisper_id}/read"))
            .header("authorization", format!("Bearer {sender_token}"))
            .body(Body::empty())?;
        let sender_mark_read_response = app.clone().oneshot(sender_mark_read_request).await?;
        assert_eq!(sender_mark_read_response.status(), StatusCode::FORBIDDEN);

        let third_mark_read_request = Request::builder()
            .method("PATCH")
            .uri(format!("/api/whispers/{whisper_id}/read"))
            .header("authorization", format!("Bearer {third_token}"))
            .body(Body::empty())?;
        let third_mark_read_response = app.oneshot(third_mark_read_request).await?;
        assert_eq!(third_mark_read_response.status(), StatusCode::FORBIDDEN);

        Ok(())
    }

    #[tokio::test]
    async fn whispers_pagination_and_validation_edges_match_contract() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.auth_store_path = Some(static_dir.path().join("auth-store.json"));
        config.domain_store_path = Some(static_dir.path().join("domain-store.json"));

        let sender_token =
            seed_local_test_token(&config, "whisper-page-sender@openagents.com").await?;
        let recipient_token =
            seed_local_test_token(&config, "whisper-page-recipient@openagents.com").await?;
        let app = build_router(config.clone());

        let recipient_id = authenticated_user_id(app.clone(), &recipient_token).await?;
        for idx in 0..205 {
            let create_request = Request::builder()
                .method("POST")
                .uri("/api/whispers")
                .header("content-type", "application/json")
                .header("authorization", format!("Bearer {sender_token}"))
                .body(Body::from(format!(
                    r#"{{"recipientId":"{recipient_id}","body":"feed-{idx}"}}"#
                )))?;
            let create_response = app.clone().oneshot(create_request).await?;
            assert_eq!(create_response.status(), StatusCode::CREATED);
        }

        let page_one_request = Request::builder()
            .method("GET")
            .uri("/api/whispers?limit=999")
            .header("authorization", format!("Bearer {recipient_token}"))
            .body(Body::empty())?;
        let page_one_response = app.clone().oneshot(page_one_request).await?;
        assert_eq!(page_one_response.status(), StatusCode::OK);
        let page_one_body = read_json(page_one_response).await?;
        assert_eq!(
            page_one_body["data"].as_array().map(|rows| rows.len()),
            Some(200)
        );
        let last_id = page_one_body["data"][199]["id"]
            .as_u64()
            .expect("expected cursor id");
        assert_eq!(
            page_one_body["meta"]["nextCursor"],
            json!(last_id.to_string())
        );

        let page_two_request = Request::builder()
            .method("GET")
            .uri(format!("/api/whispers?limit=200&before_id={last_id}"))
            .header("authorization", format!("Bearer {recipient_token}"))
            .body(Body::empty())?;
        let page_two_response = app.clone().oneshot(page_two_request).await?;
        assert_eq!(page_two_response.status(), StatusCode::OK);
        let page_two_body = read_json(page_two_response).await?;
        assert_eq!(
            page_two_body["data"].as_array().map(|rows| rows.len()),
            Some(5)
        );

        let invalid_with_request = Request::builder()
            .method("GET")
            .uri("/api/whispers?with=bad*handle")
            .header("authorization", format!("Bearer {recipient_token}"))
            .body(Body::empty())?;
        let invalid_with_response = app.clone().oneshot(invalid_with_request).await?;
        assert_eq!(
            invalid_with_response.status(),
            StatusCode::UNPROCESSABLE_ENTITY
        );

        let missing_recipient_request = Request::builder()
            .method("POST")
            .uri("/api/whispers")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {sender_token}"))
            .body(Body::from(r#"{"body":"no recipient"}"#))?;
        let missing_recipient_response = app.clone().oneshot(missing_recipient_request).await?;
        assert_eq!(
            missing_recipient_response.status(),
            StatusCode::UNPROCESSABLE_ENTITY
        );

        let both_recipient_fields_request = Request::builder()
            .method("POST")
            .uri("/api/whispers")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {sender_token}"))
            .body(Body::from(format!(
                r#"{{"recipientId":"{recipient_id}","recipientHandle":"whisper-page-recipient","body":"mutually exclusive"}}"#
            )))?;
        let both_recipient_fields_response =
            app.clone().oneshot(both_recipient_fields_request).await?;
        assert_eq!(
            both_recipient_fields_response.status(),
            StatusCode::UNPROCESSABLE_ENTITY
        );

        let sender_id = authenticated_user_id(app.clone(), &sender_token).await?;
        let self_whisper_request = Request::builder()
            .method("POST")
            .uri("/api/whispers")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {sender_token}"))
            .body(Body::from(format!(
                r#"{{"recipientId":"{sender_id}","body":"self whisper"}}"#
            )))?;
        let self_whisper_response = app.clone().oneshot(self_whisper_request).await?;
        assert_eq!(
            self_whisper_response.status(),
            StatusCode::UNPROCESSABLE_ENTITY
        );

        let invalid_id_read_request = Request::builder()
            .method("PATCH")
            .uri("/api/whispers/not-a-number/read")
            .header("authorization", format!("Bearer {recipient_token}"))
            .body(Body::empty())?;
        let invalid_id_read_response = app.clone().oneshot(invalid_id_read_request).await?;
        assert_eq!(invalid_id_read_response.status(), StatusCode::NOT_FOUND);

        let missing_read_request = Request::builder()
            .method("PATCH")
            .uri("/api/whispers/999999/read")
            .header("authorization", format!("Bearer {recipient_token}"))
            .body(Body::empty())?;
        let missing_read_response = app.oneshot(missing_read_request).await?;
        assert_eq!(missing_read_response.status(), StatusCode::NOT_FOUND);

        Ok(())
    }

    #[tokio::test]
    async fn runtime_routing_force_legacy_wins_over_user_override() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.admin_emails = vec!["runtime-router@openagents.com".to_string()];
        config.runtime_driver = "elixir".to_string();
        config.runtime_force_legacy = true;
        config.runtime_overrides_enabled = true;
        let app = build_router(config);
        let token = authenticate_token(app.clone(), "runtime-router@openagents.com").await?;
        let user_id = authenticated_user_id(app.clone(), &token).await?;

        let override_request = Request::builder()
            .method("POST")
            .uri("/api/v1/control/runtime-routing/override")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(format!(
                r#"{{
                    "scope_type":"user",
                    "scope_id":"{user_id}",
                    "driver":"elixir",
                    "is_active":true,
                    "reason":"canary"
                }}"#
            )))?;
        let override_response = app.clone().oneshot(override_request).await?;
        assert_eq!(override_response.status(), StatusCode::OK);

        let evaluate_request = Request::builder()
            .method("POST")
            .uri("/api/v1/control/runtime-routing/evaluate")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(r#"{"thread_id":"thread-runtime-1"}"#))?;
        let evaluate_response = app.oneshot(evaluate_request).await?;
        assert_eq!(evaluate_response.status(), StatusCode::OK);
        let body = read_json(evaluate_response).await?;
        assert_eq!(body["data"]["driver"], json!("legacy"));
        assert_eq!(body["data"]["reason"], json!("force_legacy"));

        Ok(())
    }

    #[tokio::test]
    async fn runtime_routing_applies_autopilot_override_from_thread_binding() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut config = test_config(static_dir.path().to_path_buf());
        config.admin_emails = vec!["runtime-router@openagents.com".to_string()];
        config.runtime_driver = "legacy".to_string();
        config.runtime_force_legacy = false;
        config.runtime_overrides_enabled = true;
        let app = build_router(config);
        let token = authenticate_token(app.clone(), "runtime-router@openagents.com").await?;

        let create_autopilot_request = Request::builder()
            .method("POST")
            .uri("/api/autopilots")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(
                r#"{
                    "displayName":"Runtime Override Pilot",
                    "handle":"runtime-override-pilot",
                    "status":"active",
                    "visibility":"private"
                }"#,
            ))?;
        let create_autopilot_response = app.clone().oneshot(create_autopilot_request).await?;
        assert_eq!(create_autopilot_response.status(), StatusCode::CREATED);
        let autopilot_body = read_json(create_autopilot_response).await?;
        let autopilot_id = autopilot_body["data"]["id"]
            .as_str()
            .unwrap_or_default()
            .to_string();

        let create_thread_request = Request::builder()
            .method("POST")
            .uri(format!("/api/autopilots/{autopilot_id}/threads"))
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(r#"{"title":"Runtime override thread"}"#))?;
        let create_thread_response = app.clone().oneshot(create_thread_request).await?;
        assert_eq!(create_thread_response.status(), StatusCode::CREATED);
        let thread_body = read_json(create_thread_response).await?;
        let thread_id = thread_body["data"]["id"]
            .as_str()
            .unwrap_or_default()
            .to_string();

        let override_request = Request::builder()
            .method("POST")
            .uri("/api/v1/control/runtime-routing/override")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(format!(
                r#"{{
                    "scope_type":"autopilot",
                    "scope_id":"{autopilot_id}",
                    "driver":"elixir",
                    "is_active":true
                }}"#
            )))?;
        let override_response = app.clone().oneshot(override_request).await?;
        assert_eq!(override_response.status(), StatusCode::OK);

        let evaluate_request = Request::builder()
            .method("POST")
            .uri("/api/v1/control/runtime-routing/evaluate")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {token}"))
            .body(Body::from(format!(r#"{{"thread_id":"{thread_id}"}}"#)))?;
        let evaluate_response = app.oneshot(evaluate_request).await?;
        assert_eq!(evaluate_response.status(), StatusCode::OK);
        let body = read_json(evaluate_response).await?;
        assert_eq!(body["data"]["driver"], json!("elixir"));
        assert_eq!(body["data"]["reason"], json!("autopilot_override"));
        assert_eq!(body["data"]["autopilot_id"], json!(autopilot_id));

        Ok(())
    }

    #[tokio::test]
    async fn runtime_routing_canary_and_shadow_semantics_match_config() -> Result<()> {
        let static_dir = tempdir()?;
        std::fs::write(
            static_dir.path().join("index.html"),
            "<!doctype html><html><body>rust shell</body></html>",
        )?;
        let mut canary_config = test_config(static_dir.path().to_path_buf());
        canary_config.runtime_driver = "legacy".to_string();
        canary_config.runtime_overrides_enabled = false;
        canary_config.runtime_canary_seed = "test-seed".to_string();
        canary_config.runtime_canary_user_percent = 100;
        canary_config.runtime_shadow_enabled = true;
        canary_config.runtime_shadow_sample_rate = 1.0;
        let canary_app = build_router(canary_config);
        let canary_token =
            authenticate_token(canary_app.clone(), "runtime-canary@openagents.com").await?;

        let canary_eval = Request::builder()
            .method("POST")
            .uri("/api/v1/control/runtime-routing/evaluate")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {canary_token}"))
            .body(Body::from(r#"{"thread_id":"thread-canary-1"}"#))?;
        let canary_response = canary_app.oneshot(canary_eval).await?;
        assert_eq!(canary_response.status(), StatusCode::OK);
        let canary_body = read_json(canary_response).await?;
        assert_eq!(canary_body["data"]["driver"], json!("elixir"));
        assert_eq!(canary_body["data"]["reason"], json!("user_canary"));
        assert_eq!(canary_body["data"]["shadow"]["mirrored"], json!(false));

        let mut default_config = test_config(static_dir.path().to_path_buf());
        default_config.runtime_driver = "legacy".to_string();
        default_config.runtime_overrides_enabled = false;
        default_config.runtime_canary_user_percent = 0;
        default_config.runtime_shadow_enabled = true;
        default_config.runtime_shadow_sample_rate = 1.0;
        let default_app = build_router(default_config);
        let default_token =
            authenticate_token(default_app.clone(), "runtime-default@openagents.com").await?;

        let default_eval = Request::builder()
            .method("POST")
            .uri("/api/v1/control/runtime-routing/evaluate")
            .header("content-type", "application/json")
            .header("authorization", format!("Bearer {default_token}"))
            .body(Body::from(r#"{"thread_id":"thread-default-1"}"#))?;
        let default_response = default_app.oneshot(default_eval).await?;
        assert_eq!(default_response.status(), StatusCode::OK);
        let default_body = read_json(default_response).await?;
        assert_eq!(default_body["data"]["driver"], json!("legacy"));
        assert_eq!(default_body["data"]["reason"], json!("default_driver"));
        assert_eq!(default_body["data"]["shadow"]["mirrored"], json!(true));
        assert_eq!(
            default_body["data"]["shadow"]["shadow_driver"],
            json!("elixir")
        );

        Ok(())
    }
}
